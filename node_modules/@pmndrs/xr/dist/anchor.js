import { Matrix4, Quaternion, Vector3 } from 'three';
const OneVector = new Vector3(1, 1, 1);
const ZeroVector = new Vector3(1, 1, 1);
const NeutralQuaternion = new Quaternion();
const matrixHelper1 = new Matrix4();
const matrixHelper2 = new Matrix4();
const quaternionHelper = new Quaternion();
const positionHelper = new Vector3();
const directionHelper = new Vector3();
export async function requestXRAnchor(store, options) {
    if (options.relativeTo === 'hit-test-result') {
        directionHelper.set(0, 0, 1);
        if (options.offsetQuaternion != null) {
            directionHelper.applyQuaternion(options.offsetQuaternion);
        }
        return options.hitTestResult.createAnchor?.(new XRRigidTransform({ ...options.offsetPosition }, { ...directionHelper }));
    }
    let frame;
    let space;
    if (options.relativeTo === 'world') {
        frame = options.frame ?? (await store.requestFrame());
        const { origin, originReferenceSpace } = store.getState();
        if (originReferenceSpace == null) {
            return undefined;
        }
        space = originReferenceSpace;
        const { worldPosition, worldQuaternion } = options;
        if (origin != null) {
            //compute vectorHelper and quaternionHelper in the local space of the origin
            matrixHelper1.copy(origin.matrixWorld).invert();
            matrixHelper2.compose(worldPosition, worldQuaternion, OneVector).multiply(matrixHelper1);
            matrixHelper2.decompose(positionHelper, quaternionHelper, directionHelper);
            quaternionHelper.setFromRotationMatrix(matrixHelper2);
        }
        else {
            positionHelper.copy(worldPosition);
            quaternionHelper.copy(worldQuaternion);
        }
    }
    else {
        frame = options.frame ?? (await store.requestFrame());
        space = options.space;
        const { offsetPosition, offsetQuaternion } = options;
        positionHelper.copy(offsetPosition ?? ZeroVector);
        quaternionHelper.copy(offsetQuaternion ?? NeutralQuaternion);
    }
    directionHelper.set(0, 0, 1);
    directionHelper.applyQuaternion(quaternionHelper);
    return frame.createAnchor?.(new XRRigidTransform({ ...positionHelper }, { ...directionHelper }), space);
}
