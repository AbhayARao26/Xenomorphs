import { createStore } from 'zustand/vanilla';
import { updateXRHandState } from './hand/state.js';
import { updateXRControllerState } from './controller/index.js';
import { createSyncXRInputSourceStates } from './input.js';
import { buildXRSessionInit } from './init.js';
export function resolveInputSourceImplementation(implementation, handedness, defaultValue) {
    if (typeof implementation === 'function') {
        return implementation;
    }
    if (typeof implementation === 'object') {
        if (handedness != null && hasKey(implementation, handedness)) {
            implementation = implementation[handedness];
        }
        else if ('default' in implementation) {
            implementation = implementation.default;
        }
    }
    if (implementation === false) {
        return false;
    }
    if (implementation === true) {
        return defaultValue;
    }
    return implementation ?? defaultValue;
}
function hasKey(val, key) {
    return key in val;
}
export function resolveDetectedImplementation(implementation, semanticLabel, defaultValue) {
    implementation ??= defaultValue;
    if (implementation === false) {
        return false;
    }
    if (typeof implementation === 'function') {
        return implementation;
    }
    if (semanticLabel != null && semanticLabel in implementation) {
        return implementation[semanticLabel] ?? defaultValue;
    }
    if ('default' in implementation) {
        return implementation.default ?? defaultValue;
    }
    return implementation;
}
const baseInitialState = {
    session: undefined,
    originReferenceSpace: undefined,
    visibilityState: undefined,
    mode: null,
    frameRate: undefined,
    handStates: [],
    controllerStates: [],
    transientPointerStates: [],
    gazeStates: [],
    screenInputStates: [],
    detectedMeshes: [],
    detectedPlanes: [],
};
function startEmulate(emulate, alert) {
    Promise.all([navigator.xr?.isSessionSupported('immersive-vr'), navigator.xr?.isSessionSupported('immersive-ar')])
        .then(([vr, ar]) => (!ar && !vr ? import('./emulate.js') : undefined))
        .then((pkg) => {
        if (alert) {
            window.alert(`emulator started`);
        }
        pkg?.emulate(emulate === true ? 'metaQuest3' : emulate);
    });
}
export function createXRStore(options) {
    const emulate = options?.emulate ?? 'metaQuest3';
    let cleanupEmulate;
    if (emulate != false) {
        if (window.location.hostname === 'localhost') {
            startEmulate(emulate, false);
        }
        const keydownListener = (e) => {
            if (e.altKey && e.metaKey && e.code === 'KeyE') {
                startEmulate(emulate, true);
            }
        };
        window.addEventListener('keydown', keydownListener);
        cleanupEmulate = () => window.removeEventListener('keydown', keydownListener);
    }
    const domOverlayRoot = options?.domOverlay instanceof HTMLElement ? options.domOverlay : document.createElement('div');
    const store = createStore(() => ({
        ...baseInitialState,
        controller: options?.controller,
        hand: options?.hand,
        gaze: options?.gaze,
        screenInput: options?.screenInput,
        transientPointer: options?.transientPointer,
        detectedMesh: options?.detectedMesh,
        detectedPlane: options?.detectedPlane,
        domOverlayRoot,
    }));
    let cleanupDomOverlayRoot;
    if (domOverlayRoot.parentNode == null) {
        const setupDisplay = (state) => {
            domOverlayRoot.style.display = state.session != null ? 'block' : 'none';
        };
        const unsubscribe = store.subscribe(setupDisplay);
        setupDisplay(store.getState());
        document.body.appendChild(domOverlayRoot);
        cleanupDomOverlayRoot = () => {
            domOverlayRoot.remove();
            unsubscribe();
        };
    }
    document.body.append(domOverlayRoot);
    const syncXRInputSourceStates = createSyncXRInputSourceStates({
        controller: (state) => store.setState({ controllerStates: [...store.getState().controllerStates, state] }),
    }, options);
    const bindToSession = createBindToSession(store, syncXRInputSourceStates);
    const cleanupSessionGrantedListener = setupSessionGrantedListener(options?.enterGrantedSession, (mode) => enterXR(domOverlayRoot, mode, options, xrManager));
    let cleanupSessionStartListener;
    const frameRequests = [];
    let xrManager;
    return Object.assign(store, {
        requestFrame() {
            return new Promise((resolve) => frameRequests.push(resolve));
        },
        setWebXRManager(newXrManager) {
            if (xrManager === newXrManager) {
                return;
            }
            xrManager = newXrManager;
            const { foveation, originReferenceSpace = 'local-floor' } = options ?? {};
            newXrManager.setReferenceSpaceType(originReferenceSpace);
            if (foveation != null) {
                newXrManager.setFoveation(foveation);
            }
            cleanupSessionStartListener?.();
            cleanupSessionStartListener = setupSessionStartListener(newXrManager, bindToSession);
        },
        setFrameRate(value) {
            const { session } = store.getState();
            if (session == null) {
                return;
            }
            setFrameRate(session, value);
        },
        setHand(implementation, handedness) {
            if (handedness == null) {
                store.setState({ hand: implementation });
                return;
            }
            const currentImplementation = store.getState().hand;
            const newControllerImplementation = {};
            if (typeof currentImplementation === 'object') {
                Object.assign(newControllerImplementation, currentImplementation);
            }
            Object.assign(newControllerImplementation, {
                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),
                [handedness]: implementation,
            });
            store.setState({
                hand: newControllerImplementation,
            });
        },
        setController(implementation, handedness) {
            if (handedness == null) {
                store.setState({ controller: implementation });
                return;
            }
            const currentImplementation = store.getState().controller;
            const newControllerImplementation = {};
            if (typeof currentImplementation === 'object') {
                Object.assign(newControllerImplementation, currentImplementation);
            }
            Object.assign(newControllerImplementation, {
                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),
                [handedness]: implementation,
            });
            store.setState({
                controller: newControllerImplementation,
            });
        },
        setTransientPointer(implementation, handedness) {
            if (handedness == null) {
                store.setState({ transientPointer: implementation });
                return;
            }
            const currentImplementation = store.getState().transientPointer;
            const newControllerImplementation = {};
            if (typeof currentImplementation === 'object') {
                Object.assign(newControllerImplementation, currentImplementation);
            }
            Object.assign(newControllerImplementation, {
                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),
                [handedness]: implementation,
            });
            store.setState({
                transientPointer: newControllerImplementation,
            });
        },
        setGaze(implementation) {
            store.setState({ gaze: implementation });
        },
        setScreenInput(implementation) {
            store.setState({ screenInput: implementation });
        },
        setDetectedPlane(implementation, semanticLabel) {
            if (semanticLabel == null) {
                store.setState({ detectedPlane: implementation });
                return;
            }
            const currentImplementation = store.getState().detectedPlane;
            const newImplementation = {};
            if (typeof currentImplementation === 'object') {
                Object.assign(newImplementation, currentImplementation);
            }
            Object.assign(newImplementation, {
                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),
                [semanticLabel]: implementation,
            });
            store.setState({
                detectedPlane: newImplementation,
            });
        },
        setDetectedMesh(implementation, semanticLabel) {
            if (semanticLabel == null) {
                store.setState({ detectedMesh: implementation });
                return;
            }
            const currentImplementation = store.getState().detectedMesh;
            const newImplementation = {};
            if (typeof currentImplementation === 'object') {
                Object.assign(newImplementation, currentImplementation);
            }
            Object.assign(newImplementation, {
                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),
                [semanticLabel]: implementation,
            });
            store.setState({
                detectedMesh: newImplementation,
            });
        },
        destroy() {
            cleanupEmulate?.();
            cleanupDomOverlayRoot?.();
            cleanupSessionStartListener?.();
            cleanupSessionGrantedListener?.();
            //unbinding the session
            bindToSession(undefined, undefined);
        },
        enterXR: (mode) => enterXR(domOverlayRoot, mode, options, xrManager),
        enterAR: () => enterXR(domOverlayRoot, 'immersive-ar', options, xrManager),
        enterVR: () => enterXR(domOverlayRoot, 'immersive-vr', options, xrManager),
        onBeforeFrame(scene, camera, frame) {
            //update origin
            const { origin: oldOrigin } = store.getState();
            const origin = camera.parent ?? scene;
            const referenceSpace = xrManager?.getReferenceSpace() ?? undefined;
            if (oldOrigin != origin) {
                origin.xrSpace = referenceSpace;
                store.setState({ origin });
            }
            //update reference space
            const { originReferenceSpace: oldReferenceSpace } = store.getState();
            if (referenceSpace != oldReferenceSpace) {
                origin.xrSpace = referenceSpace;
                store.setState({ originReferenceSpace: referenceSpace });
            }
            if (frame == null) {
                return;
            }
            if (xrManager != null) {
                updateSession(store, frame, xrManager);
            }
            const length = frameRequests.length;
            for (let i = 0; i < length; i++) {
                frameRequests[i](frame);
            }
            frameRequests.length = 0;
        },
    });
}
async function setFrameRate(session, frameRate) {
    if (frameRate === false) {
        return;
    }
    const { supportedFrameRates } = session;
    if (supportedFrameRates == null || supportedFrameRates.length === 0) {
        return;
    }
    if (typeof frameRate === 'function') {
        const value = frameRate(supportedFrameRates);
        if (value === false) {
            return;
        }
        return session.updateTargetFrameRate(value);
    }
    const multiplier = frameRate === 'high' ? 1 : frameRate === 'mid' ? 0.5 : 0;
    return session.updateTargetFrameRate(supportedFrameRates[Math.ceil((supportedFrameRates.length - 1) * multiplier)]);
}
async function enterXR(domOverlayRoot, mode, options, xrManager) {
    if (navigator.xr == null) {
        return Promise.reject(new Error(`WebXR not supported`));
    }
    if (xrManager == null) {
        return Promise.reject(new Error(`not connected to three.js. Missing are <XR> component?`));
    }
    const session = await navigator.xr.requestSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));
    setFrameRate(session, options?.frameRate ?? 'high');
    setupXRManager(xrManager, session, options);
    return session;
}
function setupXRManager(xr, session, options) {
    if (xr == null) {
        return;
    }
    const maxFrameBufferScalingFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
    let frameBufferScaling = options?.frameBufferScaling;
    if (typeof frameBufferScaling === 'function') {
        frameBufferScaling = frameBufferScaling(maxFrameBufferScalingFactor);
    }
    if (typeof frameBufferScaling === 'string') {
        frameBufferScaling =
            frameBufferScaling === 'high' ? maxFrameBufferScalingFactor : frameBufferScaling === 'mid' ? 1 : 0.5;
    }
    if (frameBufferScaling != null) {
        xr?.setFramebufferScaleFactor(frameBufferScaling);
    }
    xr?.setSession(session);
}
const allSessionModes = ['immersive-ar', 'immersive-vr', 'inline'];
function setupSessionStartListener(xr, bindToSession) {
    const sessionStartListener = () => {
        const session = xr.getSession();
        bindToSession(session, session.environmentBlendMode === 'opaque' ? 'immersive-vr' : 'immersive-ar');
    };
    xr.addEventListener('sessionstart', sessionStartListener);
    return () => xr.removeEventListener('sessionstart', sessionStartListener);
}
function setupSessionGrantedListener(enterGrantedSession = allSessionModes, enterXR) {
    if (enterGrantedSession === false) {
        return;
    }
    if (enterGrantedSession === true) {
        enterGrantedSession = allSessionModes;
    }
    const sessionGrantedListener = async () => {
        for (const mode of enterGrantedSession) {
            if (!(await navigator.xr?.isSessionSupported(mode))) {
                continue;
            }
            enterXR(mode);
        }
    };
    navigator.xr?.addEventListener('sessiongranted', sessionGrantedListener);
    return () => navigator.xr?.removeEventListener('sessiongranted', sessionGrantedListener);
}
function createBindToSession(store, syncXRInputSourceStates) {
    let cleanupSession;
    return (session, mode) => {
        cleanupSession?.();
        if (session == null || mode == null) {
            return;
        }
        const onInputSourcesChange = (e) => store.setState(syncXRInputSourceStates(e.session, store.getState(), e.added, e.removed));
        session.addEventListener('inputsourceschange', onInputSourcesChange);
        //event handlers
        //trigger re-render just re-evaluating the values read from the session
        const onChange = () => store.setState({ frameRate: session.frameRate, visibilityState: session.visibilityState });
        const onEnd = () => {
            cleanupSession?.();
            cleanupSession = undefined;
            store.setState(baseInitialState);
        };
        session.addEventListener('end', onEnd);
        session.addEventListener('frameratechange', onChange);
        session.addEventListener('visibilitychange', onChange);
        store.setState({
            ...syncXRInputSourceStates(session, undefined, session.inputSources, undefined),
            frameRate: session.frameRate,
            visibilityState: session.visibilityState,
            detectedMeshes: [],
            detectedPlanes: [],
            mode,
            session,
        });
        cleanupSession = () => {
            //cleanup
            syncXRInputSourceStates(session, store.getState(), undefined, 'all');
            session.removeEventListener('end', onEnd);
            session.removeEventListener('frameratechange', onChange);
            session.removeEventListener('visibilitychange', onChange);
            session.removeEventListener('inputsourceschange', onInputSourcesChange);
        };
    };
}
function updateSession(store, frame, manager) {
    const referenceSpace = manager.getReferenceSpace();
    const { detectedMeshes: prevMeshes, detectedPlanes: prevPlanes, session, controllerStates: controllers, handStates: hands, } = store.getState();
    if (referenceSpace == null || session == null) {
        //not in a XR session
        return;
    }
    //update detected planes and meshes
    const detectedPlanes = updateDetectedEntities(prevPlanes, frame.detectedPlanes);
    const detectedMeshes = updateDetectedEntities(prevMeshes, frame.detectedMeshes);
    if (prevPlanes != detectedPlanes || prevMeshes != detectedMeshes) {
        store.setState({ detectedPlanes, detectedMeshes });
    }
    //update controllers
    const controllersLength = controllers.length;
    for (let i = 0; i < controllersLength; i++) {
        updateXRControllerState(controllers[i]);
    }
    //update hands
    const handsLength = hands.length;
    for (let i = 0; i < handsLength; i++) {
        updateXRHandState(hands[i], frame, manager);
    }
}
const emptyArray = [];
function updateDetectedEntities(prevDetectedEntities, detectedEntities) {
    if (detectedEntities == null) {
        return emptyArray;
    }
    if (prevDetectedEntities != null && equalContent(detectedEntities, prevDetectedEntities)) {
        return prevDetectedEntities;
    }
    return Array.from(detectedEntities);
}
function equalContent(set, arr) {
    if (set.size != arr.length) {
        return false;
    }
    for (const entry of arr) {
        if (!set.has(entry)) {
            return false;
        }
    }
    return true;
}
