import { Matrix4, Quaternion, Vector3 } from 'three';
import { computeOriginReferenceSpaceOffset, getSpaceFromAncestors } from './internals.js';
const matrixHelper = new Matrix4();
const vectorHelper = new Vector3();
const quaternionHelper = new Quaternion();
export async function createXRHitTestSource(store, relativeTo, trackableType = ['point', 'plane', 'mesh']) {
    let offsetRay;
    let space;
    let object;
    const state = store.getState();
    if (relativeTo instanceof XRSpace) {
        space = relativeTo;
        object = state.origin;
    }
    else {
        if (state.originReferenceSpace == null) {
            return undefined;
        }
        object = relativeTo;
        space =
            getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper) ??
                state.originReferenceSpace;
        if (space === state.originReferenceSpace) {
            computeOriginReferenceSpaceOffset(relativeTo, state.origin, matrixHelper);
        }
        vectorHelper.setFromMatrixPosition(matrixHelper);
        const point = { ...vectorHelper };
        quaternionHelper.setFromRotationMatrix(matrixHelper);
        vectorHelper.set(0, 0, -1).applyQuaternion(quaternionHelper);
        const direction = { ...vectorHelper };
        offsetRay = new XRRay(point, direction);
    }
    const source = await store.getState().session?.requestHitTestSource?.({
        space,
        entityTypes: Array.isArray(trackableType) ? trackableType : [trackableType],
        offsetRay,
    });
    if (source == null) {
        return undefined;
    }
    return {
        source,
        getWorldMatrix: computeWorldMatrixFromXRHitTestResult.bind(null, space, object),
    };
}
export async function requestXRHitTest(store, relativeTo, trackableType) {
    const sourceData = await createXRHitTestSource(store, relativeTo, trackableType);
    if (sourceData == null) {
        return undefined;
    }
    const { source, getWorldMatrix } = sourceData;
    const frame = await store.requestFrame();
    const results = frame.getHitTestResults?.(source) ?? [];
    source.cancel();
    if (results == null) {
        return undefined;
    }
    return { results, getWorldMatrix };
}
function computeWorldMatrixFromXRHitTestResult(space, object, target, result) {
    const pose = result.getPose(space);
    if (pose == null) {
        return false;
    }
    //target = ObjectMatrixWorld? * HitTestMatrix
    target.fromArray(pose.transform.matrix);
    if (object != null) {
        target.premultiply(object.matrixWorld);
    }
    return true;
}
