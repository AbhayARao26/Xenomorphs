import { hasObjectListeners } from '../utils.js';
export function computeIntersectionWorldPlane(target, intersection, object) {
    if (intersection.face == null) {
        return false;
    }
    target.setFromNormalAndCoplanarPoint(intersection.face.normal, intersection.localPoint);
    target.applyMatrix4(object.matrixWorld);
    return true;
}
function isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType, pointerId, pointerType, pointerState) {
    if (pointerEvents === 'none') {
        return false;
    }
    if (pointerEvents === 'listener' && !hasListener) {
        return false;
    }
    if (pointerEventsType === 'all') {
        return true;
    }
    if (typeof pointerEventsType === 'function') {
        return pointerEventsType(pointerId, pointerType, pointerState);
    }
    let value;
    let invert;
    if ('deny' in pointerEventsType) {
        invert = true;
        value = pointerEventsType.deny;
    }
    else {
        invert = false;
        value = pointerEventsType.allow;
    }
    let result;
    if (Array.isArray(value)) {
        result = value.includes(pointerType);
    }
    else {
        result = value === pointerType;
    }
    return invert ? !result : result;
}
export function traversePointerEventTargets(object, pointerId, pointerType, pointerState, callback, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {
    const hasListener = parentHasListener || hasObjectListeners(object);
    const pointerEvents = object.pointerEvents ?? parentPointerEvents;
    const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType;
    const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder;
    const isAllowed = isPointerEventsAllowed(hasListener, pointerEvents ?? 'listener', pointerEventsType ?? 'all', pointerId, pointerType, pointerState);
    if (isAllowed) {
        callback(object, pointerEventsOrder);
    }
    const length = object.children.length;
    for (let i = 0; i < length; i++) {
        traversePointerEventTargets(object.children[i], pointerId, pointerType, pointerState, callback, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);
    }
}
/**
 * @returns undefined if `i1` is the dominant intersection
 */
export function getDominantIntersectionIndex(i1, pointerEventsOrder1, i2, pointerEventsOrder2, { customFilter, customSort: compare = defaultSort } = {}) {
    let index = undefined;
    const length = i2.length;
    for (let i = 0; i < length; i++) {
        const intersection = i2[i];
        if (!(customFilter?.(intersection) ?? true)) {
            continue;
        }
        if (i1 == null || compare(i1, pointerEventsOrder1, intersection, pointerEventsOrder2) > 0) {
            i1 = intersection;
            index = i;
        }
    }
    return index;
}
/**
 * @returns a negative number if i1 should be sorted before i2
 */
function defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {
    if (pointerEventsOrder1 != pointerEventsOrder2) {
        //inverted order because order is sorted highest first
        return pointerEventsOrder2 - pointerEventsOrder1;
    }
    //i1 - i2 because negative values mean the sorting i1 before i2 is correct
    return i1.distance - i2.distance;
}
