import {
  GLTFLoader
} from "./chunk-OZQLFUUS.js";
import {
  MeshLineGeometry,
  MeshLineMaterial,
  tunnel
} from "./chunk-255NBUP7.js";
import {
  require_client
} from "./chunk-SSPF5MRB.js";
import "./chunk-RVDH2RUB.js";
import {
  context,
  createPortal,
  reconciler,
  suspend,
  useFrame,
  useLoader,
  useStore,
  useThree
} from "./chunk-ITWTBDRP.js";
import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  Box2,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  CylinderGeometry,
  DepthTexture,
  Euler,
  HalfFloatType,
  InstancedMesh,
  Line3,
  LinearFilter,
  Material,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  QuadraticBezierCurve3,
  Quaternion,
  Ray,
  Raycaster,
  SRGBColorSpace,
  Scene,
  Shape,
  ShapeGeometry,
  Sphere,
  SphereGeometry,
  Texture,
  Vector2,
  Vector3,
  VideoTexture,
  WebGLRenderTarget
} from "./chunk-567F6HUI.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@react-three/xr/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/@react-three/xr/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState10 = React.useState, useEffect14 = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue2 = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState10({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect14(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/@react-three/xr/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/@react-three/xr/node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@react-three/xr/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/@react-three/xr/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var shim = require_shim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore2 = shim.useSyncExternalStore;
        var useRef14 = React.useRef, useEffect14 = React.useEffect, useMemo15 = React.useMemo, useDebugValue2 = React.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef14(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo15(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore2(subscribe, getSelection, getServerSelection);
          useEffect14(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue2(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/@react-three/xr/node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/@react-three/xr/node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@react-three/xr/dist/space.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);

// node_modules/three/src/math/MathUtils.js
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

// node_modules/@pmndrs/xr/dist/controller/gamepad.js
var ButtonTouchThreshold = 0.05;
var AxisTouchThreshold = 0.1;
function updateXRControllerGamepadState(target, inputSource, layout) {
  const gamepad = inputSource.gamepad;
  if (gamepad == null) {
    return;
  }
  const layoutComponents = layout.components;
  for (const key in layoutComponents) {
    let component = target[key];
    if (component == null) {
      target[key] = component = {};
    }
    const { gamepadIndices } = layoutComponents[key];
    let pressed = false;
    let touched = false;
    if (gamepadIndices.button != null && gamepadIndices.button < gamepad.buttons.length) {
      const gamepadButton = gamepad.buttons[gamepadIndices.button];
      component.button = clamp(gamepadButton.value, 0, 1);
      pressed || (pressed = gamepadButton.pressed || component.button === 1);
      touched || (touched = gamepadButton.touched || component.button > ButtonTouchThreshold);
    }
    if (gamepadIndices.xAxis != null && gamepadIndices.xAxis < gamepad.axes.length) {
      component.xAxis = clamp(gamepad.axes[gamepadIndices.xAxis], -1, 1);
      touched || (touched = Math.abs(component.xAxis) > AxisTouchThreshold);
    }
    if (gamepadIndices.yAxis != null && gamepadIndices.yAxis < gamepad.axes.length) {
      component.yAxis = clamp(gamepad.axes[gamepadIndices.yAxis], -1, 1);
      touched || (touched = Math.abs(component.yAxis) > AxisTouchThreshold);
    }
    component.state = pressed ? "pressed" : touched ? "touched" : "default";
  }
}

// node_modules/@pmndrs/xr/dist/hand/pose.js
function createHandPoseState(hand) {
  return {
    //distances: {},
    //name: undefined,
    data: new Float32Array(hand.size * 16)
  };
}
function updateXRHandPoseState(state, frame, hand, manager, handedness) {
  const referenceSpace = manager.getReferenceSpace();
  if (referenceSpace == null || frame == null || frame.session.visibilityState === "visible-blurred" || frame.session.visibilityState === "hidden") {
    return;
  }
  const validPose = updateXRHandPoseData(frame, referenceSpace, hand, state.data);
  if (!validPose) {
    return;
  }
  let closestPoseName;
  let closestPoseDistance;
}
var invertedWirstHelper = new Matrix4();
var matrixHelper = new Matrix4();
function updateXRHandPoseData(frame, referenceSpace, hand, handPoseData) {
  const validPose = frame.fillPoses(hand.values(), referenceSpace, handPoseData);
  if (!validPose) {
    return false;
  }
  invertedWirstHelper.fromArray(handPoseData, 0);
  invertedWirstHelper.invert();
  for (let i2 = 0; i2 < handPoseData.length; i2 += 16) {
    matrixHelper.fromArray(handPoseData, i2);
    matrixHelper.premultiply(invertedWirstHelper);
    matrixHelper.toArray(handPoseData, i2);
  }
  return true;
}
var tempMat2 = new Matrix4();
var tempMat1 = new Matrix4();
var tempQuat2 = new Quaternion();
var tempQuat1 = new Quaternion();

// node_modules/three/examples/jsm/utils/SkeletonUtils.js
function clone(source) {
  const sourceLookup = /* @__PURE__ */ new Map();
  const cloneLookup = /* @__PURE__ */ new Map();
  const clone2 = source.clone();
  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {
    sourceLookup.set(clonedNode, sourceNode);
    cloneLookup.set(sourceNode, clonedNode);
  });
  clone2.traverse(function(node) {
    if (!node.isSkinnedMesh) return;
    const clonedMesh = node;
    const sourceMesh = sourceLookup.get(node);
    const sourceBones = sourceMesh.skeleton.bones;
    clonedMesh.skeleton = sourceMesh.skeleton.clone();
    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
      return cloneLookup.get(bone);
    });
    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
  });
  return clone2;
}
function parallelTraverse(a, b, callback) {
  callback(a, b);
  for (let i2 = 0; i2 < a.children.length; i2++) {
    parallelTraverse(a.children[i2], b.children[i2], callback);
  }
}

// node_modules/@pmndrs/xr/dist/hand/model.js
var DefaultDefaultXRHandProfileId = "generic-hand";
function getXRHandAssetPath(handedness, options) {
  const baseAssetPath = (options == null ? void 0 : options.baseAssetPath) ?? DefaultAssetBasePath;
  const defaultProfileId = (options == null ? void 0 : options.defaultXRHandProfileId) ?? DefaultDefaultXRHandProfileId;
  return new URL(`${defaultProfileId}/${handedness}.glb`, baseAssetPath).href;
}
function cloneXRHandGltf({ scene }) {
  const result = clone(scene);
  const mesh = result.getObjectByProperty("type", "SkinnedMesh");
  if (mesh == null) {
    throw new Error(`missing SkinnedMesh in loaded XRHand model`);
  }
  mesh.frustumCulled = false;
  return result;
}
function configureXRHandModel(model, options) {
  model.renderOrder = (options == null ? void 0 : options.renderOrder) ?? 0;
  model.traverse((child) => {
    if (child instanceof Mesh && child.material instanceof Material) {
      child.material.colorWrite = (options == null ? void 0 : options.colorWrite) ?? true;
    }
  });
}

// node_modules/@pmndrs/xr/dist/hand/state.js
function createXRHandState(id, inputSource, options, events, isPrimary) {
  return {
    id,
    isPrimary,
    type: "hand",
    inputSource,
    pose: createHandPoseState(inputSource.hand),
    assetPath: getXRHandAssetPath(inputSource.handedness, options),
    events
  };
}
function updateXRHandState({ inputSource, pose }, frame, manager) {
  updateXRHandPoseState(pose, frame, inputSource.hand, manager, inputSource.handedness);
}

// node_modules/@pmndrs/xr/dist/hand/visual.js
var joints = [
  "wrist",
  "thumb-metacarpal",
  "thumb-phalanx-proximal",
  "thumb-phalanx-distal",
  "thumb-tip",
  "index-finger-metacarpal",
  "index-finger-phalanx-proximal",
  "index-finger-phalanx-intermediate",
  "index-finger-phalanx-distal",
  "index-finger-tip",
  "middle-finger-metacarpal",
  "middle-finger-phalanx-proximal",
  "middle-finger-phalanx-intermediate",
  "middle-finger-phalanx-distal",
  "middle-finger-tip",
  "ring-finger-metacarpal",
  "ring-finger-phalanx-proximal",
  "ring-finger-phalanx-intermediate",
  "ring-finger-phalanx-distal",
  "ring-finger-tip",
  "pinky-finger-metacarpal",
  "pinky-finger-phalanx-proximal",
  "pinky-finger-phalanx-intermediate",
  "pinky-finger-phalanx-distal",
  "pinky-finger-tip"
];
function createUpdateXRHandVisuals(hand, handModel, referenceSpace) {
  const buffer = new Float32Array(hand.size * 16);
  const jointObjects = joints.map((joint) => {
    const jointObject = handModel.getObjectByName(joint);
    if (jointObject == null) {
      throw new Error(`missing joint "${joint}" in hand model`);
    }
    jointObject.matrixAutoUpdate = false;
    return jointObject;
  });
  return (frame) => {
    const resolvedReferenceSpace = typeof referenceSpace === "function" ? referenceSpace() : referenceSpace;
    if (frame == null || resolvedReferenceSpace == null) {
      return;
    }
    frame.fillPoses(hand.values(), resolvedReferenceSpace, buffer);
    const length = jointObjects.length;
    for (let i2 = 0; i2 < length; i2++) {
      jointObjects[i2].matrix.fromArray(buffer, i2 * 16);
    }
  };
}

// node_modules/@pmndrs/xr/dist/input.js
function isXRInputSourceState(val) {
  return val != null && typeof val === "object" && "inputSource" in val;
}
function setupEvents(session, events) {
  const listener = (e) => events.push(e);
  session.addEventListener("selectstart", listener);
  session.addEventListener("selectend", listener);
  session.addEventListener("select", listener);
  session.addEventListener("squeeze", listener);
  session.addEventListener("squeezestart", listener);
  session.addEventListener("squeezeend", listener);
  return () => {
    session.removeEventListener("selectstart", listener);
    session.removeEventListener("selectend", listener);
    session.removeEventListener("select", listener);
    session.removeEventListener("squeeze", listener);
    session.removeEventListener("squeezestart", listener);
    session.removeEventListener("squeezeend", listener);
  };
}
var idCounter = 0;
function createSyncXRInputSourceStates(addController, options) {
  const cleanupMap = /* @__PURE__ */ new Map();
  const controllerLayoutLoader = new XRControllerLayoutLoader(options);
  const idMap = /* @__PURE__ */ new Map();
  return (session, current, changes) => {
    var _a;
    if (changes === "remove-all") {
      for (const cleanup of cleanupMap.values()) {
        cleanup();
      }
      return current;
    }
    const target = [...current];
    for (const { added, isPrimary, removed } of changes) {
      if (removed != null) {
        for (const inputSource of removed) {
          const index = target.findIndex(({ inputSource: is, isPrimary: ip }) => ip === isPrimary && is === inputSource);
          if (index === -1) {
            continue;
          }
          target.splice(index, 1);
          (_a = cleanupMap.get(inputSource)) == null ? void 0 : _a();
          cleanupMap.delete(inputSource);
        }
      }
      if (added == null) {
        continue;
      }
      for (const inputSource of added) {
        const events = [];
        let cleanup = setupEvents(session, events);
        const key = `${inputSource.handedness}-${inputSource.hand ? "hand" : "nohand"}-${inputSource.targetRayMode}-${inputSource.profiles.join(",")}`;
        let id;
        if ((id = idMap.get(key)) == null) {
          idMap.set(key, id = `${idCounter++}`);
        }
        if (inputSource.hand != null) {
          target.push(createXRHandState(id, inputSource, options, events, isPrimary));
        } else {
          switch (inputSource.targetRayMode) {
            case "gaze":
              target.push({ id, isPrimary, type: "gaze", inputSource, events });
              break;
            case "screen":
              target.push({ id, isPrimary, type: "screenInput", inputSource, events });
              break;
            case "transient-pointer":
              target.push({ id, isPrimary, type: "transientPointer", inputSource, events });
              break;
            case "tracked-pointer":
              let aborted = false;
              const cleanupEvents = cleanup;
              cleanup = () => {
                cleanupEvents();
                aborted = true;
              };
              const stateResult = createXRControllerState(id, inputSource, controllerLayoutLoader, events, isPrimary);
              if (stateResult instanceof Promise) {
                stateResult.then((state) => !aborted && addController(state)).catch(console.error);
              } else {
                target.push(stateResult);
              }
              break;
          }
        }
        cleanupMap.set(inputSource, cleanup);
      }
    }
    return target;
  };
}

// node_modules/@pmndrs/xr/dist/visible.js
function setupSyncIsVisible(store, setIsVisible) {
  const update = (state, prevState) => {
    if (prevState != null && state.visibilityState === prevState.visibilityState) {
      return;
    }
    setIsVisible(state.visibilityState === "visible");
  };
  update(store.getState());
  return store.subscribe(update);
}

// node_modules/@pmndrs/xr/dist/pointer/cursor.js
var PointerCursorMaterial = class extends MeshBasicMaterial {
  constructor() {
    super({ transparent: true, toneMapped: false, depthWrite: false });
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    parameters.vertexShader = `varying vec2 vLocalPosition;
` + parameters.vertexShader;
    parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>
        vLocalPosition = position.xy * 2.0;`);
    parameters.fragmentShader = `varying vec2 vLocalPosition;
` + parameters.fragmentShader;
    parameters.fragmentShader = parameters.fragmentShader.replace("#include <color_fragment>", `#include <color_fragment>
          float value = max(0.0, 1.0 - sqrt(dot(vLocalPosition, vLocalPosition)));
          diffuseColor.a = diffuseColor.a * value * value;`);
  }
};
var ZAxis = new Vector3(0, 0, 1);
var quaternionHelper = new Quaternion();
var offsetHelper = new Vector3();
function updatePointerCursorModel(mesh, material, pointer, options) {
  const intersection = pointer.getIntersection();
  if (intersection == null || !pointer.getEnabled()) {
    mesh.visible = false;
    return;
  }
  mesh.visible = true;
  const color = typeof options.color === "function" ? options.color(pointer) : options.color;
  if (Array.isArray(color)) {
    material.color.set(...color);
  } else {
    material.color.set(color ?? "white");
  }
  material.opacity = typeof options.opacity === "function" ? options.opacity(pointer) : options.opacity ?? 0.4;
  mesh.position.copy(intersection.pointOnFace);
  mesh.scale.setScalar(options.size ?? 0.1);
  if (intersection.normal != null) {
    quaternionHelper.setFromUnitVectors(ZAxis, intersection.normal);
    intersection.object.getWorldQuaternion(mesh.quaternion);
    mesh.quaternion.multiply(quaternionHelper);
    offsetHelper.set(0, 0, options.cursorOffset ?? 0.01);
    offsetHelper.applyQuaternion(mesh.quaternion);
    mesh.position.add(offsetHelper);
  }
  mesh.updateMatrix();
}

// node_modules/@pmndrs/xr/dist/pointer/ray.js
var PointerRayMaterial = class extends MeshBasicMaterial {
  constructor() {
    super({ transparent: true, toneMapped: false });
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    parameters.vertexShader = `varying float vFade;
` + parameters.vertexShader;
    parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>
            vFade = position.z + 0.5;`);
    parameters.fragmentShader = `varying float vFade;
` + parameters.fragmentShader;
    parameters.fragmentShader = parameters.fragmentShader.replace("#include <color_fragment>", `#include <color_fragment>
              diffuseColor.a *= vFade;`);
  }
};
function updatePointerRayModel(mesh, material, pointer, options) {
  if (!pointer.getEnabled()) {
    mesh.visible = false;
    return;
  }
  mesh.visible = true;
  const intersection = pointer.getIntersection();
  const color = typeof options.color === "function" ? options.color(pointer) : options.color;
  if (Array.isArray(color)) {
    material.color.set(...color);
  } else {
    material.color.set(color ?? "white");
  }
  material.opacity = typeof options.opacity === "function" ? options.opacity(pointer) : options.opacity ?? 0.4;
  let length = options.maxLength ?? 1;
  if (intersection != null) {
    length = Math.min(length, intersection.distance);
  }
  mesh.position.z = -length / 2;
  const size = options.size ?? 5e-3;
  mesh.scale.set(size, size, length);
  mesh.updateMatrix();
}

// node_modules/@pmndrs/xr/dist/pointer/event.js
function bindXRInputSourceEvent(session, inputSource, event, fn) {
  const filterFn = (event2) => {
    if (inputSource != "all" && event2.inputSource != inputSource) {
      return;
    }
    fn(event2);
  };
  session.addEventListener(event, filterFn);
  return () => session.removeEventListener(event, filterFn);
}
function bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents, options = {}) {
  const downListener = (e) => {
    if (e.inputSource === inputSource) {
      pointer.down(Object.assign(e, { button: options.button ?? 0 }));
    }
  };
  const upListener = (e) => {
    if (e.inputSource === inputSource) {
      pointer.up(Object.assign(e, { button: options.button ?? 0 }));
    }
  };
  const downEventName = `${event}start`;
  const upEventName = `${event}end`;
  const length = missingEvents.length;
  for (let i2 = 0; i2 < length; i2++) {
    const event2 = missingEvents[i2];
    switch (event2.type) {
      case downEventName:
        downListener(event2);
        break;
      case upEventName:
        upListener(event2);
        break;
    }
  }
  session.addEventListener(downEventName, downListener);
  session.addEventListener(upEventName, upListener);
  return () => {
    session.removeEventListener(downEventName, downListener);
    session.removeEventListener(upEventName, upListener);
  };
}

// node_modules/@pmndrs/xr/dist/pointer/default.js
function defaultGrabPointerOpacity(pointer) {
  var _a;
  if (pointer.getButtonsDown().size > 0) {
    return 0.6;
  }
  return map(((_a = pointer.getIntersection()) == null ? void 0 : _a.distance) ?? Infinity, 0.07, 0, 0.2, 0.4);
}
function defaultRayPointerOpacity(pointer) {
  if (pointer.getButtonsDown().size > 0) {
    return 0.6;
  }
  return 0.4;
}
function defaultTouchPointerOpacity(pointer) {
  var _a;
  return map(((_a = pointer.getIntersection()) == null ? void 0 : _a.distance) ?? Infinity, 0.1, 0.03, 0.2, 0.6);
}
function map(value, fromMin, fromMax, toMin, toMax) {
  return toMin + Math.max(0, Math.min(1, (value - fromMin) / (fromMax - fromMin))) * (toMax - toMin);
}

// node_modules/@pmndrs/xr/dist/space.js
function createGetXRSpaceMatrix(space, referenceSpace) {
  return (target, frame) => {
    if (space === referenceSpace) {
      target.identity();
      return true;
    }
    const resolvedReferenceSpace = typeof referenceSpace === "function" ? referenceSpace() : referenceSpace;
    if (resolvedReferenceSpace == null) {
      return false;
    }
    const pose = frame == null ? void 0 : frame.getPose(space, resolvedReferenceSpace);
    if (pose == null) {
      return false;
    }
    target.fromArray(pose.transform.matrix);
    return true;
  };
}
function computeOriginReferenceSpaceOffset(object, origin, target) {
  if (origin == null) {
    target.copy(object.matrixWorld);
    return;
  }
  target.copy(origin.matrixWorld).invert().multiply(object.matrixWorld);
}
function getSpaceFromAncestors(object, origin, originReferenceSpace, targetOffsetMatrix) {
  targetOffsetMatrix == null ? void 0 : targetOffsetMatrix.copy(object.matrix);
  const result = getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);
  if (result != null) {
    return result;
  }
  if (targetOffsetMatrix != null) {
    computeOriginReferenceSpaceOffset(object, origin, targetOffsetMatrix);
  }
  return originReferenceSpace;
}
function getXRSpaceFromAncestorsRec(object, targetOffsetMatrix) {
  if (object == null) {
    return void 0;
  }
  if (object.xrSpace != null) {
    return object.xrSpace;
  }
  targetOffsetMatrix == null ? void 0 : targetOffsetMatrix.premultiply(object.matrix);
  return getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);
}

// node_modules/@pmndrs/xr/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/@pmndrs/xr/dist/init.js
function buildXRSessionInit(mode, domOverlayRoot, { anchors = true, handTracking = true, layers = true, meshDetection = true, planeDetection = true, customSessionInit, depthSensing = false, hitTest = true, domOverlay = true, bounded } = {}) {
  if (customSessionInit != null) {
    return customSessionInit;
  }
  const requiredFeatures = bounded == null ? ["local-floor"] : bounded ? ["bounded-floor"] : ["unbounded", "local-floor"];
  const optionalFeatures = [];
  if (domOverlay instanceof Element) {
    domOverlay = true;
  }
  addXRSessionFeature(anchors, "anchors", requiredFeatures, optionalFeatures);
  addXRSessionFeature(handTracking, "hand-tracking", requiredFeatures, optionalFeatures);
  addXRSessionFeature(layers, "layers", requiredFeatures, optionalFeatures);
  addXRSessionFeature(meshDetection, "mesh-detection", requiredFeatures, optionalFeatures);
  addXRSessionFeature(planeDetection, "plane-detection", requiredFeatures, optionalFeatures);
  addXRSessionFeature(depthSensing, "depth-sensing", requiredFeatures, optionalFeatures);
  addXRSessionFeature(domOverlay, "dom-overlay", requiredFeatures, optionalFeatures);
  addXRSessionFeature(hitTest, "hit-test", requiredFeatures, optionalFeatures);
  const init = {
    requiredFeatures,
    optionalFeatures,
    domOverlay: { root: domOverlayRoot }
  };
  if (depthSensing) {
    Object.assign(init, { depthSensing: { usagePreference: ["gpu-optimized"], dataFormatPreference: [] } });
  }
  return init;
}
function addXRSessionFeature(value, key, requiredFeatures, optionalFeatures) {
  if (value === false) {
    return;
  }
  if (value === true) {
    optionalFeatures.push(key);
    return;
  }
  requiredFeatures.push(key);
}

// node_modules/@pmndrs/xr/dist/store.js
function resolveInputSourceImplementation(implementation, handedness, defaultValue) {
  if (typeof implementation === "function") {
    return implementation;
  }
  if (typeof implementation === "object") {
    if (handedness != null && hasKey(implementation, handedness)) {
      implementation = implementation[handedness];
    } else if ("default" in implementation) {
      implementation = implementation.default;
    }
  }
  if (implementation === false) {
    return false;
  }
  if (implementation === true) {
    return defaultValue;
  }
  return implementation ?? defaultValue;
}
function hasKey(val, key) {
  return key in val;
}
var baseInitialState = {
  session: void 0,
  mediaBinding: void 0,
  originReferenceSpace: void 0,
  visibilityState: void 0,
  mode: null,
  frameRate: void 0,
  inputSourceStates: [],
  detectedMeshes: [],
  detectedPlanes: [],
  layerEntries: []
};
function startEmulate(emulate, alert) {
  var _a, _b;
  Promise.all([(_a = navigator.xr) == null ? void 0 : _a.isSessionSupported("immersive-vr"), (_b = navigator.xr) == null ? void 0 : _b.isSessionSupported("immersive-ar")]).then(([vr, ar]) => !ar && !vr ? import("./emulate-BIBF7HXL.js") : void 0).then((pkg) => {
    if (alert) {
      window.alert(`emulator started`);
    }
    pkg == null ? void 0 : pkg.emulate(emulate === true ? "metaQuest3" : emulate);
  });
}
function createXRStore(options) {
  const emulate = (options == null ? void 0 : options.emulate) ?? "metaQuest3";
  let cleanupEmulate;
  if (typeof window !== "undefined" && emulate != false) {
    if (window.location.hostname === "localhost") {
      startEmulate(emulate, false);
    }
    const keydownListener = (e) => {
      if (e.altKey && e.metaKey && e.code === "KeyE") {
        startEmulate(emulate, true);
      }
    };
    window.addEventListener("keydown", keydownListener);
    cleanupEmulate = () => window.removeEventListener("keydown", keydownListener);
  }
  const domOverlayRoot = (options == null ? void 0 : options.domOverlay) instanceof HTMLElement ? options.domOverlay : document.createElement("div");
  const store = createStore(() => ({
    ...baseInitialState,
    controller: options == null ? void 0 : options.controller,
    hand: options == null ? void 0 : options.hand,
    gaze: options == null ? void 0 : options.gaze,
    screenInput: options == null ? void 0 : options.screenInput,
    transientPointer: options == null ? void 0 : options.transientPointer,
    domOverlayRoot
  }));
  let cleanupDomOverlayRoot;
  if (domOverlayRoot.parentNode == null) {
    const setupDisplay = (state) => {
      domOverlayRoot.style.display = state.session != null ? "block" : "none";
    };
    const unsubscribe = store.subscribe(setupDisplay);
    setupDisplay(store.getState());
    document.body.appendChild(domOverlayRoot);
    cleanupDomOverlayRoot = () => {
      domOverlayRoot.remove();
      unsubscribe();
    };
  }
  document.body.append(domOverlayRoot);
  const syncXRInputSourceStates = createSyncXRInputSourceStates((state) => store.setState({ inputSourceStates: [...store.getState().inputSourceStates, state] }), options);
  const bindToSession = createBindToSession(store, syncXRInputSourceStates, (options == null ? void 0 : options.secondaryInputSources) ?? false);
  const cleanupSessionGrantedListener = setupSessionGrantedListener(options == null ? void 0 : options.enterGrantedSession, (mode) => enterXR(domOverlayRoot, mode, options, xrManager));
  let cleanupSessionStartListener;
  const frameRequests = [];
  let xrManager;
  return Object.assign(store, {
    addLayerEntry(layerEntry) {
      if (store.getState().session == null) {
        return;
      }
      store.setState({ layerEntries: [...store.getState().layerEntries, layerEntry] });
    },
    removeLayerEntry(layerEntry) {
      if (store.getState().session == null) {
        return;
      }
      store.setState({ layerEntries: store.getState().layerEntries.filter((entry) => entry != layerEntry) });
    },
    requestFrame() {
      return new Promise((resolve) => frameRequests.push(resolve));
    },
    setWebXRManager(newXrManager) {
      if (xrManager === newXrManager) {
        return;
      }
      xrManager = newXrManager;
      const { foveation, bounded } = options ?? {};
      newXrManager.setReferenceSpaceType(bounded ? "bounded-floor" : "local-floor");
      if (foveation != null) {
        newXrManager.setFoveation(foveation);
      }
    },
    setFrameRate(value) {
      const { session } = store.getState();
      if (session == null) {
        return;
      }
      setFrameRate(session, value);
    },
    setHand(implementation, handedness) {
      if (handedness == null) {
        store.setState({ hand: implementation });
        return;
      }
      const currentImplementation = store.getState().hand;
      const newControllerImplementation = {};
      if (typeof currentImplementation === "object") {
        Object.assign(newControllerImplementation, currentImplementation);
      }
      Object.assign(newControllerImplementation, {
        default: resolveInputSourceImplementation(currentImplementation, void 0, {}),
        [handedness]: implementation
      });
      store.setState({
        hand: newControllerImplementation
      });
    },
    setController(implementation, handedness) {
      if (handedness == null) {
        store.setState({ controller: implementation });
        return;
      }
      const currentImplementation = store.getState().controller;
      const newControllerImplementation = {};
      if (typeof currentImplementation === "object") {
        Object.assign(newControllerImplementation, currentImplementation);
      }
      Object.assign(newControllerImplementation, {
        default: resolveInputSourceImplementation(currentImplementation, void 0, {}),
        [handedness]: implementation
      });
      store.setState({
        controller: newControllerImplementation
      });
    },
    setTransientPointer(implementation, handedness) {
      if (handedness == null) {
        store.setState({ transientPointer: implementation });
        return;
      }
      const currentImplementation = store.getState().transientPointer;
      const newControllerImplementation = {};
      if (typeof currentImplementation === "object") {
        Object.assign(newControllerImplementation, currentImplementation);
      }
      Object.assign(newControllerImplementation, {
        default: resolveInputSourceImplementation(currentImplementation, void 0, {}),
        [handedness]: implementation
      });
      store.setState({
        transientPointer: newControllerImplementation
      });
    },
    setGaze(implementation) {
      store.setState({ gaze: implementation });
    },
    setScreenInput(implementation) {
      store.setState({ screenInput: implementation });
    },
    destroy() {
      cleanupEmulate == null ? void 0 : cleanupEmulate();
      cleanupDomOverlayRoot == null ? void 0 : cleanupDomOverlayRoot();
      cleanupSessionStartListener == null ? void 0 : cleanupSessionStartListener();
      cleanupSessionGrantedListener == null ? void 0 : cleanupSessionGrantedListener();
      bindToSession(void 0);
    },
    enterXR: (mode) => enterXR(domOverlayRoot, mode, options, xrManager),
    enterAR: () => enterXR(domOverlayRoot, "immersive-ar", options, xrManager),
    enterVR: () => enterXR(domOverlayRoot, "immersive-vr", options, xrManager),
    onBeforeFrame(scene, camera, frame) {
      let update;
      const referenceSpace = (xrManager == null ? void 0 : xrManager.getReferenceSpace()) ?? void 0;
      const state = store.getState();
      const origin = camera.parent ?? scene;
      if (state.origin != origin) {
        origin.xrSpace = referenceSpace;
        update ?? (update = {});
        update.origin = origin;
      }
      if (referenceSpace != state.originReferenceSpace) {
        origin.xrSpace = referenceSpace;
        update ?? (update = {});
        update.originReferenceSpace = referenceSpace;
      }
      if (frame != null) {
        if (xrManager != null) {
          updateSession(store, frame, xrManager);
        }
        if (state.session == null && referenceSpace != null && frame.session != null) {
          update ?? (update = {});
          Object.assign(update, bindToSession(frame.session));
        }
      }
      if (update != null) {
        store.setState(update);
      }
      if (frame != null) {
        const length = frameRequests.length;
        for (let i2 = 0; i2 < length; i2++) {
          frameRequests[i2](frame);
        }
        frameRequests.length = 0;
      }
    },
    onBeforeRender() {
      const { session, layerEntries } = store.getState();
      if (session == null || xrManager == null) {
        return;
      }
      const currentLayers = session == null ? void 0 : session.renderState.layers;
      if (currentLayers == null) {
        return;
      }
      ;
      layerEntries.sort((l1, l2) => l1.renderOrder - l2.renderOrder);
      let changed = false;
      const layers = layerEntries.map(({ layer }, i2) => {
        if (layer != currentLayers[i2]) {
          changed = true;
        }
        return layer;
      });
      if (!changed) {
        return;
      }
      layers.push(xrManager.getBaseLayer());
      session.updateRenderState({
        layers
      });
    }
  });
}
async function setFrameRate(session, frameRate) {
  if (frameRate === false) {
    return;
  }
  const { supportedFrameRates } = session;
  if (supportedFrameRates == null || supportedFrameRates.length === 0) {
    return;
  }
  if (typeof frameRate === "function") {
    const value = frameRate(supportedFrameRates);
    if (value === false) {
      return;
    }
    return session.updateTargetFrameRate(value);
  }
  const multiplier = frameRate === "high" ? 1 : frameRate === "mid" ? 0.5 : 0;
  return session.updateTargetFrameRate(supportedFrameRates[Math.ceil((supportedFrameRates.length - 1) * multiplier)]);
}
async function enterXR(domOverlayRoot, mode, options, xrManager) {
  if (navigator.xr == null) {
    return Promise.reject(new Error(`WebXR not supported`));
  }
  if (xrManager == null) {
    return Promise.reject(new Error(`not connected to three.js. Missing are <XR> component?`));
  }
  const session = await navigator.xr.requestSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));
  setFrameRate(session, (options == null ? void 0 : options.frameRate) ?? "high");
  setupXRManager(xrManager, session, options);
  return session;
}
function setupXRManager(xr, session, options) {
  if (xr == null) {
    return;
  }
  const maxFrameBufferScalingFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
  let frameBufferScaling = options == null ? void 0 : options.frameBufferScaling;
  if (typeof frameBufferScaling === "function") {
    frameBufferScaling = frameBufferScaling(maxFrameBufferScalingFactor);
  }
  if (typeof frameBufferScaling === "string") {
    frameBufferScaling = frameBufferScaling === "high" ? maxFrameBufferScalingFactor : frameBufferScaling === "mid" ? 1 : 0.5;
  }
  if (frameBufferScaling != null) {
    xr == null ? void 0 : xr.setFramebufferScaleFactor(frameBufferScaling);
  }
  xr == null ? void 0 : xr.setSession(session);
}
var allSessionModes = ["immersive-ar", "immersive-vr", "inline"];
function setupSessionGrantedListener(enterGrantedSession = allSessionModes, enterXR2) {
  var _a;
  if (enterGrantedSession === false) {
    return;
  }
  if (enterGrantedSession === true) {
    enterGrantedSession = allSessionModes;
  }
  const sessionGrantedListener = async () => {
    var _a2;
    for (const mode of enterGrantedSession) {
      if (!await ((_a2 = navigator.xr) == null ? void 0 : _a2.isSessionSupported(mode))) {
        continue;
      }
      enterXR2(mode);
    }
  };
  (_a = navigator.xr) == null ? void 0 : _a.addEventListener("sessiongranted", sessionGrantedListener);
  return () => {
    var _a2;
    return (_a2 = navigator.xr) == null ? void 0 : _a2.removeEventListener("sessiongranted", sessionGrantedListener);
  };
}
function createBindToSession(store, syncXRInputSourceStates, secondayInputSources) {
  let cleanupSession;
  return (session) => {
    cleanupSession == null ? void 0 : cleanupSession();
    if (session == null) {
      return {};
    }
    const inputSourceChangesList = [];
    let inputSourceChangesTimeout;
    const applySourcesChange = () => {
      inputSourceChangesTimeout = void 0;
      store.setState({
        inputSourceStates: syncXRInputSourceStates(session, store.getState().inputSourceStates, inputSourceChangesList)
      });
      inputSourceChangesList.length = 0;
    };
    const onSourcesChange = (isPrimary, e) => {
      inputSourceChangesList.push({ isPrimary, added: e.added, removed: e.removed });
      if (inputSourceChangesTimeout != null) {
        return;
      }
      if (secondayInputSources) {
        inputSourceChangesTimeout = setTimeout(applySourcesChange, 100);
      } else {
        applySourcesChange();
      }
    };
    const onInputSourcesChange = onSourcesChange.bind(null, true);
    session.addEventListener("inputsourceschange", onInputSourcesChange);
    let cleanupSecondaryInputSources;
    if (secondayInputSources) {
      const onTrackedSourcesChange = onSourcesChange.bind(null, false);
      session.addEventListener("trackedsourceschange", onTrackedSourcesChange);
      cleanupSecondaryInputSources = () => session.removeEventListener("trackedsourceschange", onTrackedSourcesChange);
    }
    const onChange = () => store.setState({ frameRate: session.frameRate, visibilityState: session.visibilityState });
    session.addEventListener("frameratechange", onChange);
    session.addEventListener("visibilitychange", onChange);
    const onEnd = () => {
      cleanupSession == null ? void 0 : cleanupSession();
      cleanupSession = void 0;
      store.setState(baseInitialState);
    };
    session.addEventListener("end", onEnd);
    const initialChanges = [
      { isPrimary: true, added: session.inputSources }
    ];
    if (secondayInputSources) {
      initialChanges.push({ isPrimary: false, added: session.trackedSources });
    }
    const inputSourceStates = syncXRInputSourceStates(session, [], initialChanges);
    cleanupSession = () => {
      cleanupSecondaryInputSources == null ? void 0 : cleanupSecondaryInputSources();
      clearTimeout(inputSourceChangesTimeout);
      syncXRInputSourceStates(session, store.getState().inputSourceStates, "remove-all");
      session.removeEventListener("end", onEnd);
      session.removeEventListener("frameratechange", onChange);
      session.removeEventListener("visibilitychange", onChange);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
    };
    return {
      inputSourceStates,
      frameRate: session.frameRate,
      visibilityState: session.visibilityState,
      detectedMeshes: [],
      detectedPlanes: [],
      mode: session.environmentBlendMode === "opaque" ? "immersive-vr" : "immersive-ar",
      session,
      mediaBinding: typeof XRMediaBinding == "undefined" ? void 0 : new XRMediaBinding(session)
    };
  };
}
function updateSession(store, frame, manager) {
  const referenceSpace = manager.getReferenceSpace();
  const { detectedMeshes: prevMeshes, detectedPlanes: prevPlanes, session, inputSourceStates } = store.getState();
  if (referenceSpace == null || session == null) {
    return;
  }
  const detectedPlanes = updateDetectedEntities(prevPlanes, frame.detectedPlanes);
  const detectedMeshes = updateDetectedEntities(prevMeshes, frame.detectedMeshes);
  if (prevPlanes != detectedPlanes || prevMeshes != detectedMeshes) {
    store.setState({ detectedPlanes, detectedMeshes });
  }
  const inputSourceStatesLength = inputSourceStates.length;
  for (let i2 = 0; i2 < inputSourceStatesLength; i2++) {
    const inputSourceState = inputSourceStates[i2];
    switch (inputSourceState.type) {
      case "controller":
        updateXRControllerState(inputSourceState);
        break;
      case "hand":
        updateXRHandState(inputSourceState, frame, manager);
        break;
    }
  }
}
var emptyArray = [];
function updateDetectedEntities(prevDetectedEntities, detectedEntities) {
  if (detectedEntities == null) {
    return emptyArray;
  }
  if (prevDetectedEntities != null && equalContent(detectedEntities, prevDetectedEntities)) {
    return prevDetectedEntities;
  }
  return Array.from(detectedEntities);
}
function equalContent(set, arr) {
  if (set.size != arr.length) {
    return false;
  }
  for (const entry of arr) {
    if (!set.has(entry)) {
      return false;
    }
  }
  return true;
}

// node_modules/@pmndrs/xr/dist/vanilla/pointer.js
var pointerRayGeometry = new BoxGeometry();
var pointerCursorGeometry = new PlaneGeometry();

// node_modules/@pmndrs/xr/dist/controller/model.js
async function loadXRControllerModel(layout, loader = DefaultGltfLoader) {
  const { scene } = await loader.loadAsync(layout.assetPath);
  return scene.clone(true);
}
function configureXRControllerModel(model, options) {
  model.renderOrder = (options == null ? void 0 : options.renderOrder) ?? 0;
  model.traverse((child) => {
    if (child instanceof Mesh && child.material instanceof Material) {
      child.material.colorWrite = (options == null ? void 0 : options.colorWrite) ?? true;
    }
  });
}

// node_modules/@pmndrs/xr/dist/controller/visual.js
function createUpdateXRControllerVisuals(model, layout, gamepadState) {
  const updateVisuals = [];
  for (const componentName in layout.components) {
    const component = layout.components[componentName];
    let state = gamepadState[componentName];
    if (state == null) {
      gamepadState[componentName] = state = {
        state: "default"
      };
    }
    updateVisuals.push(...Object.values(component.visualResponses).map((visualResponse) => createUpdateVisualResponse(model, state, visualResponse)));
  }
  return () => {
    const length = updateVisuals.length;
    for (let i2 = 0; i2 < length; i2++) {
      updateVisuals[i2]();
    }
  };
}
function createUpdateVisualResponse(model, componentState, visualResponse) {
  const valueNode = model.getObjectByName(visualResponse.valueNodeName);
  componentState.object = valueNode;
  if (valueNode == null) {
    return () => {
    };
  }
  if (visualResponse.valueNodeProperty === "visibility") {
    return () => valueNode.visible = visualResponse.states.includes(componentState.state);
  }
  const minNode = model.getObjectByName(visualResponse.minNodeName);
  const maxNode = model.getObjectByName(visualResponse.maxNodeName);
  if (minNode == null || maxNode == null) {
    return () => {
    };
  }
  return () => {
    const value = getVisualReponseValue(componentState, visualResponse);
    valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
    valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
    valueNode.updateMatrix();
  };
}
function getVisualReponseValue(componentState, { componentProperty, states }) {
  const stateIsActive = states.includes(componentState.state);
  switch (componentProperty) {
    case "xAxis":
      return stateIsActive ? getNormalizesAxis(componentState).x : 0.5;
    case "yAxis":
      return stateIsActive ? getNormalizesAxis(componentState).y : 0.5;
    case "button":
      return stateIsActive ? componentState.button ?? 0 : 0;
    case "state":
      return stateIsActive ? 1 : 0;
  }
}
var vector2Helper = new Vector2();
function getNormalizesAxis({ xAxis = 0, yAxis = 0 }) {
  const hypotenuse = vector2Helper.lengthSq();
  if (hypotenuse > 1) {
    const theta = Math.atan2(yAxis, xAxis);
    vector2Helper.set(Math.cos(theta), Math.sin(theta));
  } else {
    vector2Helper.set(xAxis, yAxis);
  }
  vector2Helper.multiplyScalar(0.5).addScalar(0.5);
  return vector2Helper;
}

// node_modules/@pmndrs/pointer-events/dist/utils.js
function hasObjectListeners({ _listeners, __r3f }) {
  if (_listeners != null && Object.keys(_listeners).length > 0) {
    return true;
  }
  if (__r3f != null && (__r3f == null ? void 0 : __r3f.eventCount) > 0) {
    return true;
  }
  return false;
}
function getObjectListeners({ _listeners, __r3f }, forEvent) {
  if (_listeners != null && forEvent in _listeners) {
    return _listeners[forEvent];
  }
  if (__r3f == null) {
    return void 0;
  }
  const handler = __r3f.handlers[r3fEventToHandlerMap[forEvent]];
  if (handler == null) {
    return;
  }
  return [handler];
}
var r3fEventToHandlerMap = {
  click: "onClick",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick",
  pointercancel: "onPointerCancel",
  pointerdown: "onPointerDown",
  pointerenter: "onPointerEnter",
  pointerleave: "onPointerLeave",
  pointermove: "onPointerMove",
  pointerout: "onPointerOut",
  pointerover: "onPointerOver",
  pointerup: "onPointerUp",
  wheel: "onWheel"
};

// node_modules/@pmndrs/pointer-events/dist/event.js
var PointerEvent = class _PointerEvent {
  constructor(type, bubbles, nativeEvent, pointer, intersection, currentObject = intersection.object, object = currentObject) {
    __publicField(this, "type");
    __publicField(this, "bubbles");
    __publicField(this, "nativeEvent");
    __publicField(this, "pointer");
    __publicField(this, "intersection");
    __publicField(this, "currentObject");
    __publicField(this, "object");
    //the stop propagation functions will be set while propagating
    __publicField(this, "stopPropagation");
    __publicField(this, "stopImmediatePropagation");
    this.type = type;
    this.bubbles = bubbles;
    this.nativeEvent = nativeEvent;
    this.pointer = pointer;
    this.intersection = intersection;
    this.currentObject = currentObject;
    this.object = object;
  }
  //--- pointer events data
  get pointerId() {
    return this.pointer.id;
  }
  get pointerType() {
    return this.pointer.type;
  }
  get pointerState() {
    return this.pointer.state;
  }
  get timeStamp() {
    return this.nativeEvent.timeStamp;
  }
  get button() {
    return this.nativeEvent.button;
  }
  get shiftKey() {
    return this.nativeEvent.shiftKey ?? false;
  }
  get metaKey() {
    return this.nativeEvent.metaKey ?? false;
  }
  get ctrlKey() {
    return this.nativeEvent.ctrlKey ?? false;
  }
  get altKey() {
    return this.nativeEvent.altKey ?? false;
  }
  //--- intersection data
  get distance() {
    return this.intersection.distance;
  }
  get distanceToRay() {
    return this.intersection.distanceToRay;
  }
  get point() {
    return this.intersection.point;
  }
  get index() {
    return this.intersection.index;
  }
  get face() {
    return this.intersection.face;
  }
  get faceIndex() {
    return this.intersection.faceIndex;
  }
  get uv() {
    return this.intersection.uv;
  }
  get uv1() {
    return this.intersection.uv1;
  }
  get normal() {
    return this.intersection.normal;
  }
  get instanceId() {
    return this.intersection.instanceId;
  }
  get pointOnLine() {
    return this.intersection.pointOnLine;
  }
  get batchId() {
    return this.intersection.batchId;
  }
  get pointerPosition() {
    return this.intersection.pointerPosition;
  }
  get pointerQuaternion() {
    return this.intersection.pointerQuaternion;
  }
  get pointOnFace() {
    return this.intersection.pointOnFace;
  }
  get localPoint() {
    return this.intersection.localPoint;
  }
  get details() {
    return this.intersection.details;
  }
  /** same as target */
  get target() {
    return this.object;
  }
  /** same as currentTarget */
  get currentTarget() {
    return this.currentObject;
  }
  /**
   * for internal use
   */
  retarget(currentObject) {
    const { type, bubbles, nativeEvent, pointer, intersection, target } = this;
    return new _PointerEvent(type, bubbles, nativeEvent, pointer, intersection, currentObject, target);
  }
};
var WheelEvent = class _WheelEvent extends PointerEvent {
  get deltaX() {
    return this.nativeEvent.deltaX;
  }
  get deltaY() {
    return this.nativeEvent.deltaY;
  }
  get deltaZ() {
    return this.nativeEvent.deltaZ;
  }
  constructor(nativeEvent, pointer, intersection, currentObject, object) {
    super("wheel", true, nativeEvent, pointer, intersection, currentObject, object);
  }
  /**
   * for internal use
   */
  retarget(currentObject) {
    const { type, bubbles, nativeEvent, pointer, intersection, target } = this;
    return new _WheelEvent(nativeEvent, pointer, intersection, currentObject, target);
  }
};
function emitPointerEvent(event) {
  emitPointerEventRec(event, event.currentObject);
}
function emitPointerEventRec(baseEvent, currentObject) {
  if (currentObject == null) {
    return;
  }
  const listeners = getObjectListeners(currentObject, baseEvent.type);
  let propagationStopped = !baseEvent.bubbles;
  if (listeners != null && listeners.length > 0) {
    const event = baseEvent.retarget(currentObject);
    const length = listeners.length;
    event.stopPropagation = () => propagationStopped = true;
    let loopStopped = false;
    event.stopImmediatePropagation = () => {
      propagationStopped = true;
      loopStopped = true;
    };
    for (let i2 = 0; i2 < length && !loopStopped; i2++) {
      listeners[i2](event);
    }
  }
  if (propagationStopped) {
    return;
  }
  emitPointerEventRec(baseEvent, currentObject.parent);
}

// node_modules/@pmndrs/pointer-events/dist/pointer.js
var buttonsDownTimeKey = Symbol("buttonsDownTime");
var buttonsClickTimeKey = Symbol("buttonsClickTime");
var pointerMap = /* @__PURE__ */ new Map();
Object3D.prototype.setPointerCapture = function(pointerId) {
  var _a;
  (_a = getPointerById(pointerId)) == null ? void 0 : _a.setCapture(this);
};
Object3D.prototype.releasePointerCapture = function(pointerId) {
  const pointer = getPointerById(pointerId);
  if (pointer == null || !pointer.hasCaptured(this)) {
    return;
  }
  pointer.setCapture(void 0);
};
Object3D.prototype.hasPointerCapture = function(pointerId) {
  var _a;
  return ((_a = getPointerById(pointerId)) == null ? void 0 : _a.hasCaptured(this)) ?? false;
};
function getPointerById(pointerId) {
  return pointerMap.get(pointerId);
}
var Pointer = class {
  constructor(id, type, state, computeIntersection, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {
    __publicField(this, "id");
    __publicField(this, "type");
    __publicField(this, "state");
    __publicField(this, "computeIntersection");
    __publicField(this, "onMoveCommited");
    __publicField(this, "parentSetPointerCapture");
    __publicField(this, "parentReleasePointerCapture");
    __publicField(this, "options");
    //state
    __publicField(this, "prevIntersection");
    __publicField(this, "intersection");
    __publicField(this, "prevEnabled", true);
    __publicField(this, "enabled", true);
    //derived state
    /**
     * ordered leaf -> root (bottom -> top)
     */
    __publicField(this, "pointerEntered", []);
    __publicField(this, "pointerEnteredHelper", []);
    __publicField(this, "pointerCapture");
    __publicField(this, "buttonsDownTime", /* @__PURE__ */ new Map());
    __publicField(this, "buttonsDown", /* @__PURE__ */ new Set());
    //to handle interaction before first move
    __publicField(this, "wasMoved", false);
    __publicField(this, "onFirstMove", []);
    this.id = id;
    this.type = type;
    this.state = state;
    this.computeIntersection = computeIntersection;
    this.onMoveCommited = onMoveCommited;
    this.parentSetPointerCapture = parentSetPointerCapture;
    this.parentReleasePointerCapture = parentReleasePointerCapture;
    this.options = options;
    pointerMap.set(id, this);
  }
  hasCaptured(object) {
    var _a;
    return ((_a = this.pointerCapture) == null ? void 0 : _a.object) === object;
  }
  setCapture(object) {
    var _a, _b, _c;
    if (((_a = this.pointerCapture) == null ? void 0 : _a.object) === object) {
      return;
    }
    if (this.pointerCapture != null) {
      (_b = this.parentReleasePointerCapture) == null ? void 0 : _b.call(this);
      this.pointerCapture = void 0;
    }
    if (object != null && this.intersection != null) {
      this.pointerCapture = { object, intersection: this.intersection };
      (_c = this.parentSetPointerCapture) == null ? void 0 : _c.call(this);
    }
  }
  getButtonsDown() {
    return this.buttonsDown;
  }
  getIntersection() {
    return this.intersection;
  }
  getEnabled() {
    return this.enabled;
  }
  setEnabled(enabled, nativeEvent, commit = true) {
    var _a;
    if (this.enabled === enabled) {
      return;
    }
    if (!enabled && this.pointerCapture != null) {
      (_a = this.parentReleasePointerCapture) == null ? void 0 : _a.call(this);
      this.pointerCapture = void 0;
    }
    this.enabled = enabled;
    if (commit) {
      this.commit(nativeEvent);
    }
  }
  /**
   * allows to separately compute and afterwards commit a move
   * => do not forget to call commitMove after computeMove
   * can be used to compute the current intersection and disable or enable the pointer before commiting the move
   */
  computeMove(scene, nativeEvent) {
    this.intersection = this.computeIntersection(scene, nativeEvent, this.pointerCapture);
  }
  commit(nativeEvent) {
    var _a;
    const prevIntersection = this.prevEnabled ? this.prevIntersection : void 0;
    const intersection = this.enabled ? this.intersection : void 0;
    if (prevIntersection != null && prevIntersection.object != (intersection == null ? void 0 : intersection.object)) {
      emitPointerEvent(new PointerEvent("pointerout", true, nativeEvent, this, prevIntersection));
    }
    const pointerLeft = this.pointerEntered;
    this.pointerEntered = [];
    this.pointerEnteredHelper.length = 0;
    computeEnterLeave(intersection == null ? void 0 : intersection.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);
    const length = pointerLeft.length;
    for (let i2 = 0; i2 < length; i2++) {
      const object = pointerLeft[i2];
      emitPointerEvent(new PointerEvent("pointerleave", false, nativeEvent, this, prevIntersection, object));
    }
    if (intersection != null && (prevIntersection == null ? void 0 : prevIntersection.object) != intersection.object) {
      emitPointerEvent(new PointerEvent("pointerover", true, nativeEvent, this, intersection));
    }
    for (let i2 = this.pointerEnteredHelper.length - 1; i2 >= 0; i2--) {
      const object = this.pointerEnteredHelper[i2];
      emitPointerEvent(new PointerEvent("pointerenter", false, nativeEvent, this, intersection, object));
    }
    if (intersection != null) {
      emitPointerEvent(new PointerEvent("pointermove", true, nativeEvent, this, intersection));
    }
    this.prevIntersection = this.intersection;
    this.prevEnabled = this.enabled;
    if (!this.wasMoved) {
      this.wasMoved = true;
      const length2 = this.onFirstMove.length;
      for (let i2 = 0; i2 < length2; i2++) {
        this.onFirstMove[i2]();
      }
      this.onFirstMove.length = 0;
    }
    (_a = this.onMoveCommited) == null ? void 0 : _a.call(this, this);
  }
  /**
   * computes and commits a move
   */
  move(scene, nativeEvent) {
    this.computeMove(scene, nativeEvent);
    this.commit(nativeEvent);
  }
  down(nativeEvent) {
    this.buttonsDown.add(nativeEvent.button);
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.down.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointerdown", true, nativeEvent, this, this.intersection));
    const { object } = this.intersection;
    object[buttonsDownTimeKey] ?? (object[buttonsDownTimeKey] = /* @__PURE__ */ new Map());
    object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);
    this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);
  }
  up(nativeEvent) {
    this.buttonsDown.delete(nativeEvent.button);
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.up.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    const { contextMenuButton = 2, dblClickThresholdMs = 500, clickThesholdMs = 300 } = this.options;
    this.pointerCapture = void 0;
    const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThesholdMs);
    if (isClicked && nativeEvent.button === contextMenuButton) {
      emitPointerEvent(new PointerEvent("contextmenu", true, nativeEvent, this, this.intersection));
    }
    emitPointerEvent(new PointerEvent("pointerup", true, nativeEvent, this, this.intersection));
    if (!isClicked || nativeEvent.button === contextMenuButton) {
      return;
    }
    emitPointerEvent(new PointerEvent("click", true, nativeEvent, this, this.intersection));
    const { object } = this.intersection;
    const buttonsClickTime = object[buttonsClickTimeKey] ?? (object[buttonsClickTimeKey] = /* @__PURE__ */ new Map());
    const buttonClickTime = buttonsClickTime.get(nativeEvent.button);
    if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {
      buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);
      return;
    }
    emitPointerEvent(new PointerEvent("dblclick", true, nativeEvent, this, this.intersection));
    buttonsClickTime.delete(nativeEvent.button);
  }
  cancel(nativeEvent) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.cancel.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointercancel", true, nativeEvent, this, this.intersection));
  }
  wheel(scene, nativeEvent, useCurrentIntersection) {
    if (!this.enabled) {
      return;
    }
    let intersection = this.intersection;
    if (!useCurrentIntersection) {
      intersection = this.computeIntersection(scene, nativeEvent, this.pointerCapture);
    }
    if (!this.wasMoved && useCurrentIntersection) {
      this.onFirstMove.push(this.cancel.bind(this, nativeEvent));
      return;
    }
    if (intersection == null) {
      return;
    }
    emitPointerEvent(new WheelEvent(nativeEvent, this, intersection));
  }
  exit(nativeEvent) {
    var _a;
    if (!this.wasMoved) {
      this.onFirstMove.push(this.exit.bind(this, nativeEvent));
      return;
    }
    if (this.pointerCapture != null) {
      (_a = this.parentReleasePointerCapture) == null ? void 0 : _a.call(this);
      this.pointerCapture = void 0;
    }
    this.intersection = void 0;
    this.commit(nativeEvent);
  }
};
function computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {
  if (currentObject == null) {
    return;
  }
  const index = targeDiffRemovedAncestors.indexOf(currentObject);
  if (index != -1) {
    targeDiffRemovedAncestors.splice(index, 1);
  } else {
    targetDiffAddedAncestors.push(currentObject);
  }
  targetAllAncestors.push(currentObject);
  computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);
}
function getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThesholdMs) {
  if (objectButtonsDownTime == null) {
    return false;
  }
  const objectButtonPressTime = objectButtonsDownTime.get(button);
  if (objectButtonPressTime == null) {
    return false;
  }
  if (buttonUpTime - objectButtonPressTime > clickThesholdMs) {
    return false;
  }
  if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {
    return false;
  }
  return true;
}

// node_modules/@pmndrs/pointer-events/dist/intersections/utils.js
function computeIntersectionWorldPlane(target, intersection, object) {
  if (intersection.face == null) {
    return false;
  }
  target.setFromNormalAndCoplanarPoint(intersection.face.normal, intersection.localPoint);
  target.applyMatrix4(object.matrixWorld);
  return true;
}
function isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType, pointerId, pointerType, pointerState) {
  if (pointerEvents === "none") {
    return false;
  }
  if (pointerEvents === "listener" && !hasListener) {
    return false;
  }
  if (pointerEventsType === "all") {
    return true;
  }
  if (typeof pointerEventsType === "function") {
    return pointerEventsType(pointerId, pointerType, pointerState);
  }
  let value;
  let invert;
  if ("deny" in pointerEventsType) {
    invert = true;
    value = pointerEventsType.deny;
  } else {
    invert = false;
    value = pointerEventsType.allow;
  }
  let result;
  if (Array.isArray(value)) {
    result = value.includes(pointerType);
  } else {
    result = value === pointerType;
  }
  return invert ? !result : result;
}
function traversePointerEventTargets(object, pointerId, pointerType, pointerState, callback, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {
  const hasListener = parentHasListener || hasObjectListeners(object);
  const pointerEvents = object.pointerEvents ?? parentPointerEvents;
  const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType;
  const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder;
  const isAllowed = isPointerEventsAllowed(hasListener, pointerEvents ?? "listener", pointerEventsType ?? "all", pointerId, pointerType, pointerState);
  if (isAllowed) {
    callback(object, pointerEventsOrder);
  }
  const length = object.children.length;
  for (let i2 = 0; i2 < length; i2++) {
    traversePointerEventTargets(object.children[i2], pointerId, pointerType, pointerState, callback, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);
  }
}
function getDominantIntersectionIndex(i1, pointerEventsOrder1, i2, pointerEventsOrder2, { customFilter, customSort: compare = defaultSort } = {}) {
  let index = void 0;
  const length = i2.length;
  for (let i3 = 0; i3 < length; i3++) {
    const intersection = i2[i3];
    if (!((customFilter == null ? void 0 : customFilter(intersection)) ?? true)) {
      continue;
    }
    if (i1 == null || compare(i1, pointerEventsOrder1, intersection, pointerEventsOrder2) > 0) {
      i1 = intersection;
      index = i3;
    }
  }
  return index;
}
function defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {
  if (pointerEventsOrder1 != pointerEventsOrder2) {
    return pointerEventsOrder2 - pointerEventsOrder1;
  }
  return i1.distance - i2.distance;
}

// node_modules/@pmndrs/pointer-events/dist/intersections/lines.js
var raycaster = new Raycaster();
var invertedMatrixHelper = new Matrix4();
var intersectsHelper = [];
function intersectLines(fromMatrixWorld, linePoints, scene, pointerId, pointerType, pointerState, pointerCapture, options) {
  if (pointerCapture != null) {
    return intersectLinesPointerCapture(fromMatrixWorld, linePoints, pointerCapture);
  }
  let intersection;
  let pointerEventsOrder;
  traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {
    let prevAccLineLength = 0;
    const length = ((intersection == null ? void 0 : intersection.details.lineIndex) ?? linePoints.length - 2) + 2;
    for (let i2 = 1; i2 < length; i2++) {
      const start = linePoints[i2 - 1];
      const end = linePoints[i2];
      raycaster.ray.origin.copy(start).applyMatrix4(fromMatrixWorld);
      raycaster.ray.direction.copy(end).applyMatrix4(fromMatrixWorld);
      raycaster.ray.direction.sub(raycaster.ray.origin);
      const lineLength = raycaster.ray.direction.length();
      raycaster.ray.direction.divideScalar(lineLength);
      raycaster.far = lineLength;
      object.raycast(raycaster, intersectsHelper);
      const length2 = intersectsHelper.length;
      for (let intersectionIndex = 0; intersectionIndex < length2; intersectionIndex++) {
        const int = intersectsHelper[intersectionIndex];
        const distanceOnLine = int.distance;
        int.distance += prevAccLineLength;
        Object.assign(int, {
          details: {
            lineIndex: i2 - 1,
            distanceOnLine
          }
        });
      }
      const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, options);
      if (index != null) {
        intersection = intersectsHelper[index];
        pointerEventsOrder = objectPointerEventsOrder;
      }
      intersectsHelper.length = 0;
      prevAccLineLength += lineLength;
    }
  });
  if (intersection == null) {
    return void 0;
  }
  return Object.assign(intersection, {
    details: {
      ...intersection.details,
      type: "lines"
    },
    pointerPosition: new Vector3().setFromMatrixPosition(fromMatrixWorld),
    pointerQuaternion: new Quaternion().setFromRotationMatrix(fromMatrixWorld),
    pointOnFace: intersection.point,
    localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert())
  });
}
var lineHelper = new Line3();
var planeHelper = new Plane();
function intersectLinesPointerCapture(fromMatrixWorld, linePoints, { intersection, object }) {
  const details = intersection.details;
  if (details.type != "lines") {
    return void 0;
  }
  lineHelper.set(linePoints[details.lineIndex], linePoints[details.lineIndex + 1]).applyMatrix4(fromMatrixWorld);
  const point = lineHelper.at(details.distanceOnLine / lineHelper.distance(), new Vector3());
  computeIntersectionWorldPlane(planeHelper, intersection, object);
  const pointOnFace = backwardsIntersectionLinesWithPlane(fromMatrixWorld, linePoints, planeHelper) ?? point;
  return {
    ...intersection,
    pointOnFace,
    point,
    pointerPosition: new Vector3().setFromMatrixPosition(fromMatrixWorld),
    pointerQuaternion: new Quaternion().setFromRotationMatrix(fromMatrixWorld)
  };
}
var vectorHelper = new Vector3();
var rayHelper = new Ray();
function backwardsIntersectionLinesWithPlane(fromMatrixWorld, linePoints, plane) {
  for (let i2 = linePoints.length - 1; i2 > 0; i2--) {
    const start = linePoints[i2 - 1];
    const end = linePoints[i2];
    rayHelper.origin.copy(start).applyMatrix4(fromMatrixWorld);
    rayHelper.direction.copy(end).applyMatrix4(fromMatrixWorld).sub(raycaster.ray.origin).normalize();
    const point = rayHelper.intersectPlane(plane, vectorHelper);
    if (point != null) {
      return vectorHelper.clone();
    }
  }
  return void 0;
}

// node_modules/@pmndrs/pointer-events/dist/intersections/ray.js
var raycaster2 = new Raycaster();
var directionHelper = new Vector3();
var planeHelper2 = new Plane();
var invertedMatrixHelper2 = new Matrix4();
var intersectsHelper2 = [];
function intersectRay(fromPosition, fromQuaternion, direction, scene, pointerId, pointerType, pointerState, pointerCapture, options) {
  if (pointerCapture != null) {
    return intersectRayPointerCapture(fromPosition, fromQuaternion, direction, pointerCapture);
  }
  let intersection;
  let pointerEventsOrder;
  raycaster2.ray.origin.copy(fromPosition);
  raycaster2.ray.direction.copy(direction).applyQuaternion(fromQuaternion);
  traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {
    object.raycast(raycaster2, intersectsHelper2);
    const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper2, objectPointerEventsOrder, options);
    if (index != null) {
      intersection = intersectsHelper2[index];
      pointerEventsOrder = objectPointerEventsOrder;
    }
    intersectsHelper2.length = 0;
  });
  if (intersection == null) {
    return void 0;
  }
  return Object.assign(intersection, {
    details: {
      type: "ray"
    },
    pointerPosition: fromPosition.clone(),
    pointerQuaternion: fromQuaternion.clone(),
    pointOnFace: intersection.point,
    localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper2.copy(intersection.object.matrixWorld).invert())
  });
}
var rayHelper2 = new Ray();
function intersectRayPointerCapture(fromPosition, fromQuaternion, direction, { intersection, object }) {
  if (intersection.details.type != "ray") {
    return void 0;
  }
  directionHelper.copy(direction).applyQuaternion(fromQuaternion);
  rayHelper2.set(fromPosition, directionHelper);
  computeIntersectionWorldPlane(planeHelper2, intersection, object);
  const pointOnFace = rayHelper2.intersectPlane(planeHelper2, new Vector3()) ?? intersection.point;
  return {
    ...intersection,
    object,
    pointOnFace,
    point: directionHelper.clone().multiplyScalar(intersection.distance).add(fromPosition),
    pointerPosition: fromPosition.clone(),
    pointerQuaternion: fromQuaternion.clone()
  };
}
function intersectRayFromCamera(from, coords, fromPosition, fromQuaternion, scene, pointerId, pointerType, pointerState, pointerCapture, options) {
  if (pointerCapture != null) {
    return intersectRayFromCameraPointerCapture(from, coords, fromPosition, fromQuaternion, pointerCapture);
  }
  let intersection;
  let pointerEventsOrder;
  raycaster2.setFromCamera(coords, from);
  planeHelper2.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), raycaster2.ray.origin);
  traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {
    object.raycast(raycaster2, intersectsHelper2);
    const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper2, objectPointerEventsOrder, options);
    if (index != null) {
      intersection = intersectsHelper2[index];
      pointerEventsOrder = objectPointerEventsOrder;
    }
    intersectsHelper2.length = 0;
  });
  if (intersection == null) {
    return void 0;
  }
  invertedMatrixHelper2.copy(intersection.object.matrixWorld).invert();
  return Object.assign(intersection, {
    details: {
      type: "camera-ray",
      distanceViewPlane: planeHelper2.distanceToPoint(intersection.point)
    },
    pointOnFace: intersection.point,
    pointerPosition: fromPosition.clone(),
    pointerQuaternion: fromQuaternion.clone(),
    localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper2)
  });
}
function intersectRayFromCameraPointerCapture(from, coords, fromPosition, fromQuaternion, { intersection, object }) {
  const details = intersection.details;
  if (details.type != "camera-ray") {
    return void 0;
  }
  raycaster2.setFromCamera(coords, from);
  from.getWorldDirection(directionHelper);
  planeHelper2.setFromNormalAndCoplanarPoint(directionHelper, raycaster2.ray.origin);
  planeHelper2.constant -= details.distanceViewPlane;
  const point = raycaster2.ray.intersectPlane(planeHelper2, new Vector3());
  if (point == null) {
    return void 0;
  }
  computeIntersectionWorldPlane(planeHelper2, intersection, object);
  const pointOnFace = raycaster2.ray.intersectPlane(planeHelper2, new Vector3()) ?? point;
  return {
    ...intersection,
    object,
    point,
    pointOnFace,
    pointerPosition: fromPosition.clone(),
    pointerQuaternion: fromQuaternion.clone()
  };
}

// node_modules/@pmndrs/pointer-events/dist/intersections/sphere.js
var collisionSphere = new Sphere();
var intersectsHelper3 = [];
function intersectSphere(fromPosition, fromQuaternion, radius, scene, pointerId, pointerType, pointerState, pointerCapture, options) {
  if (pointerCapture != null) {
    return intersectSpherePointerCapture(fromPosition, fromQuaternion, pointerCapture);
  }
  let intersection;
  let pointerEventsOrder;
  collisionSphere.center.copy(fromPosition);
  collisionSphere.radius = radius;
  traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {
    intersectSphereWithObject(collisionSphere, object, intersectsHelper3);
    const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper3, objectPointerEventsOrder, options);
    if (index != null) {
      intersection = intersectsHelper3[index];
      pointerEventsOrder = objectPointerEventsOrder;
    }
    intersectsHelper3.length = 0;
  });
  if (intersection == null) {
    return void 0;
  }
  return Object.assign(intersection, {
    details: {
      type: "sphere"
    },
    pointOnFace: intersection.point,
    pointerPosition: fromPosition.clone(),
    pointerQuaternion: fromQuaternion.clone(),
    localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper3.copy(intersection.object.matrixWorld).invert())
  });
}
var matrixHelper2 = new Matrix4();
function isSpherecastable(obj) {
  return "spherecast" in obj;
}
function intersectSphereWithObject(pointerSphere, object, target) {
  object.updateWorldMatrix(true, false);
  if (isSpherecastable(object)) {
    object.spherecast(pointerSphere, target);
    return;
  }
  if (object instanceof InstancedMesh) {
    if (object.geometry.boundingSphere == null) {
      object.geometry.computeBoundingSphere();
    }
    if (object.geometry.boundingBox == null) {
      object.geometry.computeBoundingBox();
    }
    for (let i2 = 0; i2 < object.count; i2++) {
      object.getMatrixAt(i2, matrixHelper2);
      matrixHelper2.premultiply(object.matrixWorld);
      if (!isSphereIntersectingMesh(pointerSphere, object, matrixHelper2)) {
        continue;
      }
      const intersection2 = intersectSphereMesh(pointerSphere, object, matrixHelper2, i2);
      if (intersection2 == null) {
        continue;
      }
      target.push(intersection2);
    }
  }
  if (!(object instanceof Mesh)) {
    return;
  }
  if (!isSphereIntersectingMesh(pointerSphere, object, object.matrixWorld)) {
    return;
  }
  invertedMatrixHelper3.copy(object.matrixWorld).invert();
  const intersection = intersectSphereMesh(pointerSphere, object, object.matrixWorld);
  if (intersection == null) {
    return;
  }
  target.push(intersection);
}
var oldInputDevicePointOffset = new Vector3();
var inputDeviceQuaternionOffset = new Quaternion();
var planeHelper3 = new Plane();
function intersectSpherePointerCapture(fromPosition, fromQuaterion, { intersection, object }) {
  if (intersection.details.type != "sphere") {
    return void 0;
  }
  oldInputDevicePointOffset.copy(intersection.point).sub(intersection.pointerPosition);
  inputDeviceQuaternionOffset.copy(intersection.pointerQuaternion).invert().multiply(fromQuaterion);
  const point = oldInputDevicePointOffset.clone().applyQuaternion(inputDeviceQuaternionOffset).add(fromPosition);
  computeIntersectionWorldPlane(planeHelper3, intersection, object);
  const pointOnFace = planeHelper3.projectPoint(fromPosition, new Vector3());
  return {
    details: {
      type: "sphere"
    },
    distance: intersection.distance,
    pointerPosition: fromPosition.clone(),
    pointerQuaternion: fromQuaterion.clone(),
    object,
    point,
    pointOnFace,
    face: intersection.face,
    localPoint: intersection.localPoint
  };
}
var helperSphere = new Sphere();
function isSphereIntersectingMesh(pointerSphere, { geometry }, meshMatrixWorld) {
  if (geometry.boundingSphere == null) {
    geometry.computeBoundingSphere();
  }
  helperSphere.copy(geometry.boundingSphere).applyMatrix4(meshMatrixWorld);
  return helperSphere.center.distanceToSquared(pointerSphere.center) < (pointerSphere.radius + helperSphere.radius) ** 2;
}
var vectorHelper2 = new Vector3();
var boxSizeHelper = new Vector3();
var boxCenterHelper = new Vector3();
var vec0_0001 = new Vector3(1e-4, 1e-4, 1e-4);
var invertedMatrixHelper3 = new Matrix4();
function intersectSphereMesh(pointerSphere, mesh, meshMatrixWorld, instanceId) {
  invertedMatrixHelper3.copy(meshMatrixWorld).invert();
  helperSphere.copy(pointerSphere).applyMatrix4(invertedMatrixHelper3);
  const { geometry } = mesh;
  if (geometry.boundingBox == null) {
    geometry.computeBoundingBox();
  }
  geometry.boundingBox.getSize(boxSizeHelper);
  geometry.boundingBox.getCenter(boxCenterHelper);
  geometry.boundingBox.clampPoint(helperSphere.center, vectorHelper2);
  vectorHelper2.applyMatrix4(meshMatrixWorld);
  const distanceToSphereCenterSquared = vectorHelper2.distanceToSquared(pointerSphere.center);
  if (distanceToSphereCenterSquared > pointerSphere.radius * pointerSphere.radius) {
    return void 0;
  }
  boxSizeHelper.max(vec0_0001);
  const normal = helperSphere.center.clone().sub(boxCenterHelper);
  normal.divide(boxSizeHelper);
  maximizeAxisVector(normal);
  const point = vectorHelper2.clone();
  return {
    distance: Math.sqrt(distanceToSphereCenterSquared),
    face: {
      a: 0,
      b: 0,
      c: 0,
      materialIndex: 0,
      normal
    },
    normal,
    point,
    instanceId,
    object: mesh
  };
}
function maximizeAxisVector(vec) {
  const absX = Math.abs(vec.x);
  const absY = Math.abs(vec.y);
  const absZ = Math.abs(vec.z);
  if (absX >= absY && absX >= absZ) {
    vec.set(vec.x < 0 ? -1 : 1, 0, 0);
    return;
  }
  if (absY >= absX && absY >= absZ) {
    vec.set(0, vec.y < 0 ? -1 : 1, 0);
    return;
  }
  vec.set(0, 0, vec.z < 0 ? -1 : 1);
}

// node_modules/@pmndrs/pointer-events/dist/pointer/grab.js
var defaultGrabPointerOptions = {
  radius: 0.07
};
function createGrabPointer(space, pointerState, options = defaultGrabPointerOptions, pointerType = "grab") {
  const fromPosition = new Vector3();
  const fromQuaternion = new Quaternion();
  const poinerId = generateUniquePointerId();
  return new Pointer(poinerId, pointerType, pointerState, (scene, _, pointerCapture) => {
    const spaceObject = space.current;
    if (spaceObject == null) {
      return void 0;
    }
    spaceObject.updateWorldMatrix(true, false);
    fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);
    fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);
    return intersectSphere(fromPosition, fromQuaternion, options.radius ?? defaultGrabPointerOptions.radius, scene, poinerId, pointerType, pointerState, pointerCapture, options);
  }, void 0, void 0, void 0, options);
}

// node_modules/@pmndrs/pointer-events/dist/pointer/ray.js
var NegZAxis = new Vector3(0, 0, -1);
var vectorHelper3 = new Vector3();
var defaultRayPointerOptions = {
  direction: NegZAxis,
  minDistance: 0,
  linePoints: null
};
function createRayPointer(space, pointerState, options = defaultRayPointerOptions, pointerType = "ray") {
  const fromPosition = new Vector3();
  const fromQuaternion = new Quaternion();
  const pointerId = generateUniquePointerId();
  return new Pointer(pointerId, pointerType, pointerState, (scene, _, pointerCapture) => {
    const spaceObject = space.current;
    if (spaceObject == null) {
      return void 0;
    }
    spaceObject.updateWorldMatrix(true, false);
    let intersection;
    const linePoints = options.linePoints ?? defaultRayPointerOptions.linePoints;
    if (linePoints == null) {
      fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);
      fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);
      intersection = intersectRay(fromPosition, fromQuaternion, options.direction ?? defaultRayPointerOptions.direction, scene, pointerId, pointerType, pointerState, pointerCapture, options);
    } else {
      intersection = intersectLines(spaceObject.matrixWorld, linePoints, scene, pointerId, pointerType, pointerState, pointerCapture, options);
    }
    if (intersection == null) {
      return void 0;
    }
    const localDistance = intersection.distance * spaceObject.getWorldScale(vectorHelper3).x;
    if (localDistance < (options.minDistance ?? defaultRayPointerOptions.minDistance)) {
      return void 0;
    }
    return intersection;
  }, void 0, void 0, void 0, options);
}

// node_modules/@pmndrs/pointer-events/dist/pointer/touch.js
var defaultTouchPointerOptions = {
  button: 0,
  downRadius: 0.03,
  hoverRadius: 0.1
};
function createTouchPointer(space, pointerState, options = defaultTouchPointerOptions, pointerType = "touch") {
  const fromPosition = new Vector3();
  const fromQuaternion = new Quaternion();
  const pointerId = generateUniquePointerId();
  return new Pointer(pointerId, pointerType, pointerState, (scene, _, pointerCapture) => {
    const spaceObject = space.current;
    if (spaceObject == null) {
      return void 0;
    }
    spaceObject.updateWorldMatrix(true, false);
    fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);
    fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);
    return intersectSphere(fromPosition, fromQuaternion, options.hoverRadius ?? defaultTouchPointerOptions.hoverRadius, scene, pointerId, pointerType, pointerState, pointerCapture, options);
  }, createUpdateTouchPointer(options), void 0, void 0, options);
}
function createUpdateTouchPointer(options = defaultTouchPointerOptions) {
  let wasPointerDown = false;
  return (pointer) => {
    if (!pointer.getEnabled()) {
      return;
    }
    const intersection = pointer.getIntersection();
    const isPointerDown = computeIsPointerDown(intersection, options.downRadius ?? defaultTouchPointerOptions.downRadius);
    if (isPointerDown === wasPointerDown) {
      return;
    }
    const nativeEvent = { timeStamp: performance.now(), button: options.button ?? defaultTouchPointerOptions.button };
    if (isPointerDown) {
      pointer.down(nativeEvent);
    } else {
      pointer.up(nativeEvent);
    }
    wasPointerDown = isPointerDown;
  };
}
function computeIsPointerDown(intersection, downRadius) {
  if (intersection == null) {
    return false;
  }
  return intersection.distance <= downRadius;
}

// node_modules/@pmndrs/pointer-events/dist/pointer/index.js
var pointerIdCounter = 23412;
function generateUniquePointerId() {
  return pointerIdCounter++;
}

// node_modules/@pmndrs/pointer-events/dist/forward.js
var vectorHelper4 = new Vector3();
var vector2Helper2 = new Vector2();
var quaternionHelper2 = new Quaternion();
function portalEventToCoords(e, target) {
  if (!(e instanceof PointerEvent)) {
    return target.set(0, 0);
  }
  if (e.uv == null) {
    return target.set(0, 0);
  }
  target.copy(e.uv).multiplyScalar(2).addScalar(-1);
  return target;
}
function forwardObjectEvents(fromPortal, toCamera, toScene, options) {
  return forwardEvents(fromPortal, toCamera, toScene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);
}
function forwardEvents(from, toCamera, toScene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {
  const forwardPointerCapture = (options == null ? void 0 : options.forwardPointerCapture) ?? true;
  const pointerMap2 = /* @__PURE__ */ new Map();
  const pointerTypePrefix = options.pointerTypePrefix ?? "forward-";
  const getInnerPointer = ({ pointerId = -1, pointerType = "mouse", pointerState }) => {
    let innerPointer = pointerMap2.get(pointerId);
    if (innerPointer != null) {
      return innerPointer;
    }
    pointerType = `${pointerTypePrefix}${pointerType}`;
    const computeIntersection = (scene, nativeEvent, pointerCapture) => intersectRayFromCamera(toCamera, toCoords(nativeEvent, vector2Helper2), toCamera.getWorldPosition(vectorHelper4), toCamera.getWorldQuaternion(quaternionHelper2), scene, pointerId, pointerType, pointerState, pointerCapture, options);
    pointerMap2.set(pointerId, innerPointer = new Pointer(generateUniquePointerId(), pointerType, pointerState, computeIntersection, void 0, forwardPointerCapture ? setPointerCapture.bind(null, pointerId) : void 0, forwardPointerCapture ? releasePointerCapture.bind(null, pointerId) : void 0, options));
    return innerPointer;
  };
  const pointerMoveListener = (e) => getInnerPointer(e).move(toScene, e);
  const pointerCancelListener = (e) => getInnerPointer(e).cancel(e);
  const pointerDownListener = (e) => void (hasButton(e) && getInnerPointer(e).down(e));
  const pointerUpListener = (e) => void (hasButton(e) && getInnerPointer(e).up(e));
  const pointerLeaveListener = (e) => getInnerPointer(e).exit(e);
  const wheelListener = (e) => getInnerPointer(e).wheel(toScene, e, false);
  from.addEventListener("pointermove", pointerMoveListener);
  from.addEventListener("pointercancel", pointerCancelListener);
  from.addEventListener("pointerdown", pointerDownListener);
  from.addEventListener("pointerup", pointerUpListener);
  from.addEventListener("pointerleave", pointerLeaveListener);
  from.addEventListener("wheel", wheelListener);
  return () => {
    from.removeEventListener("pointermove", pointerMoveListener);
    from.removeEventListener("pointercancel", pointerCancelListener);
    from.removeEventListener("pointerdown", pointerDownListener);
    from.removeEventListener("pointerup", pointerUpListener);
    from.removeEventListener("pointerleave", pointerLeaveListener);
    from.removeEventListener("wheel", wheelListener);
  };
}
function hasButton(val) {
  return val.button != null;
}

// node_modules/@pmndrs/pointer-events/dist/combine.js
var CombinedPointer = class {
  constructor() {
    __publicField(this, "pointers", []);
    __publicField(this, "isDefaults", []);
    __publicField(this, "enabled", true);
  }
  register(pointer, isDefault) {
    this.pointers.push(pointer);
    this.isDefaults.push(isDefault);
    return this.unregister.bind(this, pointer);
  }
  unregister(pointer) {
    const index = this.pointers.indexOf(pointer);
    if (index === -1) {
      return;
    }
    this.isDefaults.splice(index, 1);
    this.pointers.splice(index, 1);
  }
  move(scene, nativeEvent) {
    var _a, _b;
    if (!this.enabled) {
      return;
    }
    const length = this.pointers.length;
    if (length === 0) {
      return;
    }
    for (let i2 = 0; i2 < length; i2++) {
      this.pointers[i2].computeMove(scene, nativeEvent);
    }
    let smallestIndex = 0;
    let smallestDistance = ((_a = this.pointers[0].getIntersection()) == null ? void 0 : _a.distance) ?? Infinity;
    for (let i2 = 1; i2 < length; i2++) {
      const distance = ((_b = this.pointers[i2].getIntersection()) == null ? void 0 : _b.distance) ?? Infinity;
      const isDefault = this.isDefaults[i2];
      if (isDefault && distance === smallestDistance || distance < smallestDistance) {
        smallestIndex = i2;
        smallestDistance = distance;
      }
    }
    for (let i2 = 0; i2 < length; i2++) {
      const pointer = this.pointers[i2];
      pointer.setEnabled(i2 === smallestIndex, nativeEvent, false);
      pointer.commit(nativeEvent);
    }
  }
  setEnabled(enabled, nativeEvent) {
    this.enabled = enabled;
    const length = this.pointers.length;
    for (let i2 = 0; i2 < length; i2++) {
      this.pointers[i2].setEnabled(enabled, nativeEvent);
    }
  }
};

// node_modules/@pmndrs/xr/dist/mesh.js
function updateXRMeshGeometry(mesh, geometry) {
  if (geometry != null && geometry.createdAt != null && geometry.createdAt >= mesh.lastChangedTime) {
    return geometry;
  }
  const newGeometry = new BufferGeometry();
  newGeometry.setIndex(new BufferAttribute(mesh.indices, 1));
  newGeometry.setAttribute("position", new BufferAttribute(mesh.vertices, 3));
  return Object.assign(newGeometry, { creationTime: mesh.lastChangedTime });
}

// node_modules/@pmndrs/xr/dist/plane.js
function updateXRPlaneGeometry(plane, geometry) {
  if (geometry != null && geometry.createdAt != null && geometry.createdAt >= plane.lastChangedTime) {
    return geometry;
  }
  return Object.assign(createGeometryFromPolygon(plane.polygon), { createdAt: plane.lastChangedTime });
}
var boxHelper = new Box2();
var sizeHelper = new Vector2();
function createGeometryFromPolygon(polygon) {
  if (polygon.length === 0) {
    return new BufferGeometry();
  }
  const shape = new Shape();
  const points = polygon.map(({ x, z }) => new Vector2(x, z));
  boxHelper.setFromPoints(points);
  boxHelper.getSize(sizeHelper);
  for (const point of points) {
    point.sub(boxHelper.min);
    point.divide(sizeHelper);
  }
  shape.setFromPoints(points);
  const geometry = new ShapeGeometry(shape);
  geometry.scale(sizeHelper.x, sizeHelper.y, 1);
  geometry.translate(boxHelper.min.x, boxHelper.min.y, 0);
  geometry.rotateX(Math.PI / 2);
  return geometry;
}

// node_modules/@pmndrs/xr/dist/layer.js
var DefaultCentralAngle = 60 / 180 * Math.PI;
var DefaultCentralHorizontalAngle = 60 / 180 * Math.PI;
var DefaultLowerVerticalAngle = -30 / 180 * Math.PI;
var DefaultUpperVerticalAngle = 30 / 180 * Math.PI;
function createXRLayer(src, state, xrManager, relativeTo, options, properties) {
  return src instanceof HTMLVideoElement ? createXRVideoLayer(src, state, relativeTo, options, properties) : createXRNormalLayer(src, state, xrManager, relativeTo, options, properties);
}
function createXRVideoLayer(src, state, relativeTo, { invertStereo, layout, shape = "quad" }, properties = {}) {
  var _a;
  const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper3);
  if (space == null) {
    return void 0;
  }
  const transform = matrixToRigidTransform(matrixHelper3, scaleHelper);
  const init = {
    invertStereo,
    layout,
    space,
    transform
  };
  applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);
  const fnName = `create${capitalize(shape)}Layer`;
  const layer = (_a = state.mediaBinding) == null ? void 0 : _a[fnName](src, init);
  if (layer == null) {
    return;
  }
  updateXRLayerProperties(layer, properties);
  return layer;
}
function createXRNormalLayer(src, state, xrManager, relativeTo, { shape = "quad", ...options }, properties = {}) {
  var _a;
  const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper3);
  if (space == null) {
    return void 0;
  }
  const transform = matrixToRigidTransform(matrixHelper3, scaleHelper);
  const init = {
    ...options,
    isStatic: !(src instanceof WebGLRenderTarget),
    textureType: "texture",
    viewPixelWidth: options.layout === "stereo-left-right" ? src.width / 2 : src.width,
    viewPixelHeight: options.layout === "stereo-top-bottom" ? src.height / 2 : src.height,
    space,
    transform
  };
  applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);
  const fnName = `create${capitalize(shape)}Layer`;
  const layer = (_a = xrManager.getBinding()) == null ? void 0 : _a[fnName](init);
  if (layer == null) {
    return;
  }
  updateXRLayerProperties(layer, properties);
  return layer;
}
var matrixHelper3 = new Matrix4();
var vectorHelper5 = new Vector3();
var quaternionHelper3 = new Quaternion();
var scaleHelper = new Vector3();
function matrixToRigidTransform(matrix, scaleTarget = scaleHelper) {
  matrix.decompose(vectorHelper5, quaternionHelper3, scaleTarget);
  return new XRRigidTransform({ ...vectorHelper5, w: 1 }, { ...quaternionHelper3 });
}
function setXRLayerRenderTarget(renderer, renderTarget, layerEntry, frame) {
  if (layerEntry != null && frame != null) {
    const subImage = renderer.xr.getBinding().getSubImage(layerEntry.layer, frame);
    renderer.setRenderTargetTextures(renderTarget, subImage.colorTexture);
  }
  renderer.setRenderTarget(renderTarget);
}
function createXRLayerGeometry(shape, properties) {
  switch (shape) {
    case "cylinder":
      const centralAngle = properties.centralAngle ?? DefaultCentralAngle;
      return new CylinderGeometry(1, 1, 1, 32, 1, true, Math.PI - centralAngle / 2, centralAngle).scale(-1, 1, 1);
    case "equirect": {
      const centralHorizontalAngle = properties.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;
      const upperVerticalAngle = properties.upperVerticalAngle ?? DefaultUpperVerticalAngle;
      return new SphereGeometry(1, 32, 16, -Math.PI / 2 - centralHorizontalAngle / 2, centralHorizontalAngle, Math.PI / 2 - upperVerticalAngle, upperVerticalAngle - (properties.lowerVerticalAngle ?? DefaultLowerVerticalAngle)).scale(-1, 1, 1);
    }
    case "quad":
      return new PlaneGeometry();
  }
}
function capitalize(text) {
  return `${text[0].toUpperCase()}${text.slice(1)}`;
}
function updateXRLayerProperties(target, properties = {}) {
  target.chromaticAberrationCorrection = properties.chromaticAberrationCorrection;
  target.quality = properties.quality ?? "default";
  target.blendTextureSourceAlpha = properties.blendTextureSourceAlpha ?? false;
  if (target instanceof XRCylinderLayer) {
    target.centralAngle = (properties == null ? void 0 : properties.centralAngle) ?? DefaultCentralAngle;
    return;
  }
  if (target instanceof XREquirectLayer) {
    target.centralHorizontalAngle = (properties == null ? void 0 : properties.centralHorizontalAngle) ?? DefaultCentralHorizontalAngle;
    target.lowerVerticalAngle = (properties == null ? void 0 : properties.lowerVerticalAngle) ?? DefaultLowerVerticalAngle;
    target.upperVerticalAngle = (properties == null ? void 0 : properties.upperVerticalAngle) ?? DefaultUpperVerticalAngle;
  }
}
function setupXRImageLayer(renderer, store, layer, src) {
  let stop = false;
  const draw = async () => {
    const frame = await store.requestFrame();
    if (stop) {
      return;
    }
    writeContentToXRLayer(renderer, layer, frame, src);
  };
  layer.addEventListener("redraw", draw);
  draw();
  return () => {
    stop = true;
    layer.removeEventListener("redraw", draw);
  };
}
async function waitForXRLayerSrcSize(src) {
  if (src instanceof HTMLImageElement && !src.complete) {
    await new Promise((resolve) => {
      const onResolve = () => {
        resolve();
        src.removeEventListener("load", onResolve);
      };
      src.addEventListener("load", onResolve);
    });
  }
  if (src instanceof HTMLVideoElement && src.readyState < 1) {
    return new Promise((resolve) => {
      const onResolve = () => {
        resolve();
        src.removeEventListener("loadedmetadata", onResolve);
      };
      src.addEventListener("loadedmetadata", onResolve);
    });
  }
}
function getXRLayerSrcTexture(src) {
  if (src instanceof WebGLRenderTarget) {
    return src.texture;
  }
  const texture = src instanceof HTMLVideoElement ? new VideoTexture(src) : new Texture(src);
  texture.colorSpace = SRGBColorSpace;
  texture.needsUpdate = true;
  return texture;
}
function writeContentToXRLayer(renderer, layer, frame, content) {
  const context2 = renderer.getContext();
  const subImage = renderer.xr.getBinding().getSubImage(layer, frame);
  renderer.state.bindTexture(context2.TEXTURE_2D, subImage.colorTexture);
  context2.pixelStorei(context2.UNPACK_FLIP_Y_WEBGL, true);
  context2.texSubImage2D(context2.TEXTURE_2D, 0, 0, 0, content.width, content.height, context2.RGBA, context2.UNSIGNED_BYTE, content);
}
function updateXRLayerTransform(state, target, centralAngle, relativeTo) {
  target.space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper3);
  target.transform = matrixToRigidTransform(matrixHelper3, scaleHelper);
  applyXRLayerScale(getLayerShape(target), target, centralAngle, scaleHelper);
}
function applyXRLayerScale(shape, target, centralAngle, scale) {
  if (shape === "cylinder") {
    const scaleXZ = (scale.x + scale.z) / 2;
    const radius = scaleXZ;
    const layerWidth = radius * (centralAngle ?? DefaultCentralAngle);
    target.radius = radius;
    target.aspectRatio = layerWidth / scale.y;
  } else if (shape === "quad") {
    target.width = scale.x / 2;
    target.height = scale.y / 2;
  } else {
    target.radius = (scale.x + scale.y + scale.z) / 3;
  }
}
function getLayerShape(layer) {
  if (layer instanceof XRCylinderLayer) {
    return "cylinder";
  }
  if (layer instanceof XREquirectLayer) {
    return "equirect";
  }
  return "quad";
}

// node_modules/@pmndrs/xr/dist/misc.js
var vectorHelper6 = new Vector3();
var directionHelper2 = new Vector3();
var positionHelper = new Vector3();
var quaternionHelper4 = new Quaternion();
function isFacingCamera(camera, object, direction, angle) {
  object.getWorldQuaternion(quaternionHelper4);
  directionHelper2.copy(direction).applyQuaternion(quaternionHelper4);
  object.getWorldPosition(positionHelper);
  camera.getWorldPosition(vectorHelper6);
  vectorHelper6.sub(positionHelper);
  return vectorHelper6.angleTo(directionHelper2) < angle / 2;
}

// node_modules/@pmndrs/xr/dist/teleport.js
function makeTeleportTarget(root, camera, onTeleport) {
  root.traverse((object) => object.userData.teleportTarget = true);
  const listener = (e) => {
    if ("point" in e && e.point instanceof Vector3) {
      const c = typeof camera === "function" ? camera() : camera;
      const point = new Vector3().setFromMatrixPosition(c.matrix).negate().setComponent(1, 0).add(e.point);
      onTeleport(point, e);
    }
  };
  root.addEventListener("pointerup", listener);
  return () => {
    root.traverse((object) => object.userData.teleportTarget = false);
    root.removeEventListener("pointerup", listener);
  };
}
var eulerHelper = new Euler(0, 0, 0, "YXZ");
var quaternionHelper5 = new Quaternion();
function syncTeleportPointerRayGroup(space, rayGroup, deltaTimeMs) {
  space.matrixWorld.decompose(rayGroup.position, quaternionHelper5, rayGroup.scale);
  eulerHelper.setFromQuaternion(quaternionHelper5);
  eulerHelper.z = 0;
  eulerHelper.x = clamp(eulerHelper.x - 10 * Math.PI / 180, -Math.PI / 2, 1.1 * Math.PI / 4);
  quaternionHelper5.setFromEuler(eulerHelper);
  rayGroup.quaternion.slerp(quaternionHelper5, deltaTimeMs / 100);
}
function isTeleportTarget(object) {
  return object.userData.teleportTarget === true;
}
function buildTeleportTargetFilter(options = {}) {
  return (interaction) => {
    if (!isTeleportTarget(interaction.object)) {
      return false;
    }
    if (options.customFilter != null && !options.customFilter(interaction)) {
      return false;
    }
    return true;
  };
}
function createTeleportRayLine() {
  const curve = new QuadraticBezierCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, -8), new Vector3(0, -20, -15));
  return curve.getPoints(20);
}
var TeleportPointerRayModel = class extends Mesh {
  constructor(points) {
    const geometry = new MeshLineGeometry();
    const float32Array = new Float32Array(points.length * 3);
    for (let i2 = 0; i2 < points.length; i2++) {
      points[i2].toArray(float32Array, i2 * 3);
    }
    geometry.setPoints(float32Array);
    const multiplier = (points.length * 3 - 3) / (points.length * 3 - 1);
    const material = new MeshLineMaterial({
      lineWidth: 0.1,
      resolution: void 0,
      visibility: multiplier
    });
    super(geometry, material);
    __publicField(this, "multiplier");
    __publicField(this, "lineLengths");
    __publicField(this, "options", {});
    this.material.transparent = true;
    this.multiplier = multiplier;
    this.material = material;
    this.lineLengths = points.slice(0, -1).map((p, i2) => p.distanceTo(points[i2 + 1]));
  }
  update(pointer) {
    const enabled = pointer.getEnabled();
    if (!enabled || pointer.getButtonsDown().size === 0) {
      this.visible = false;
      return;
    }
    this.visible = true;
    const intersection = pointer.getIntersection();
    if ((intersection == null ? void 0 : intersection.details.type) != "lines") {
      this.material.visibility = this.multiplier;
      return;
    }
    const { distanceOnLine, lineIndex } = intersection.details;
    const lineLength = this.lineLengths[lineIndex];
    this.material.visibility = this.multiplier * (lineIndex + distanceOnLine / lineLength) / this.lineLengths.length;
    const { color = "white", opacity = 0.4, size = 0.01 } = this.options;
    this.material.lineWidth = size;
    this.material.opacity = typeof opacity === "function" ? opacity(pointer) : opacity;
    const resolvedColor = typeof color === "function" ? color(pointer) : color;
    if (Array.isArray(resolvedColor)) {
      this.material.color.set(...resolvedColor);
    } else {
      this.material.color.set(resolvedColor);
    }
  }
};

// node_modules/@pmndrs/xr/dist/hit-test.js
var matrixHelper4 = new Matrix4();
var vectorHelper7 = new Vector3();
var quaternionHelper6 = new Quaternion();
async function createXRHitTestSource(store, relativeTo, trackableType = ["point", "plane", "mesh"]) {
  var _a, _b;
  let offsetRay;
  let space;
  let object;
  const state = store.getState();
  if (typeof relativeTo === "string") {
    const { session } = store.getState();
    if (session == null) {
      return void 0;
    }
    relativeTo = await session.requestReferenceSpace(relativeTo);
  }
  if (relativeTo instanceof XRSpace) {
    space = relativeTo;
    object = state.origin;
  } else {
    if (state.originReferenceSpace == null) {
      return void 0;
    }
    object = relativeTo;
    space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper4) ?? state.originReferenceSpace;
    vectorHelper7.setFromMatrixPosition(matrixHelper4);
    const point = { ...vectorHelper7 };
    quaternionHelper6.setFromRotationMatrix(matrixHelper4);
    vectorHelper7.set(0, 0, -1).applyQuaternion(quaternionHelper6);
    const direction = { ...vectorHelper7 };
    offsetRay = new XRRay(point, direction);
  }
  const source = await ((_b = (_a = store.getState().session) == null ? void 0 : _a.requestHitTestSource) == null ? void 0 : _b.call(_a, {
    space,
    entityTypes: Array.isArray(trackableType) ? trackableType : [trackableType],
    offsetRay
  }));
  if (source == null) {
    return void 0;
  }
  return {
    source,
    getWorldMatrix: computeWorldMatrixFromXRHitTestResult.bind(null, space, object)
  };
}
async function requestXRHitTest(store, relativeTo, trackableType) {
  var _a;
  const sourceData = await createXRHitTestSource(store, relativeTo, trackableType);
  if (sourceData == null) {
    return void 0;
  }
  const { source, getWorldMatrix } = sourceData;
  const frame = await store.requestFrame();
  const results = ((_a = frame.getHitTestResults) == null ? void 0 : _a.call(frame, source)) ?? [];
  source.cancel();
  if (results == null) {
    return void 0;
  }
  return { results, getWorldMatrix };
}
function computeWorldMatrixFromXRHitTestResult(space, object, target, result) {
  const pose = result.getPose(space);
  if (pose == null) {
    return false;
  }
  target.fromArray(pose.transform.matrix);
  if (object != null) {
    target.premultiply(object.matrixWorld);
  }
  return true;
}

// node_modules/@pmndrs/xr/dist/anchor.js
var OneVector = new Vector3(1, 1, 1);
var ZeroVector = new Vector3(0, 0, 0);
var NeutralQuaternion = new Quaternion();
var matrixHelper1 = new Matrix4();
var matrixHelper22 = new Matrix4();
var quaternionHelper7 = new Quaternion();
var positionHelper2 = new Vector3();
var vectorHelper8 = new Vector3();
async function requestXRAnchor(store, options) {
  var _a, _b, _c;
  if (options.relativeTo === "hit-test-result") {
    return (_b = (_a = options.hitTestResult).createAnchor) == null ? void 0 : _b.call(_a, new XRRigidTransform(options.offsetPosition == null ? void 0 : { ...options.offsetPosition, w: 1 }, options.offsetQuaternion == null ? void 0 : { ...options.offsetQuaternion }));
  }
  let frame;
  let space;
  if (options.relativeTo === "world") {
    frame = options.frame ?? await store.requestFrame();
    const { origin, originReferenceSpace } = store.getState();
    if (originReferenceSpace == null) {
      return void 0;
    }
    space = originReferenceSpace;
    const { worldPosition, worldQuaternion } = options;
    if (origin != null) {
      matrixHelper1.copy(origin.matrixWorld).invert();
      matrixHelper22.compose(worldPosition, worldQuaternion, OneVector).multiply(matrixHelper1);
      matrixHelper22.decompose(positionHelper2, quaternionHelper7, vectorHelper8);
      quaternionHelper7.setFromRotationMatrix(matrixHelper22);
    } else {
      positionHelper2.copy(worldPosition);
      quaternionHelper7.copy(worldQuaternion);
    }
  } else {
    frame = options.frame ?? await store.requestFrame();
    space = options.space;
    const { offsetPosition, offsetQuaternion } = options;
    positionHelper2.copy(offsetPosition ?? ZeroVector);
    quaternionHelper7.copy(offsetQuaternion ?? NeutralQuaternion);
  }
  return (_c = frame.createAnchor) == null ? void 0 : _c.call(frame, new XRRigidTransform({ ...positionHelper2, w: 1 }, { ...quaternionHelper7 }), space);
}

// node_modules/@pmndrs/xr/dist/index.js
var DefaultGltfLoader = new GLTFLoader();
var DefaultAssetBasePath = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/";

// node_modules/@pmndrs/xr/dist/controller/utils.js
function syncAsync(fn, ...fns) {
  let value = fn();
  for (const fnEntry of fns) {
    if (value instanceof Promise) {
      value = value.then(fnEntry);
    } else {
      value = fnEntry(value);
    }
  }
  return value;
}

// node_modules/@pmndrs/xr/dist/controller/layout.js
var DefaultDefaultControllerProfileId = "generic-trigger";
var XRControllerLayoutLoader = class {
  constructor(options) {
    __publicField(this, "baseAssetPath");
    __publicField(this, "defaultProfileId");
    //cache
    __publicField(this, "profilesListCache");
    __publicField(this, "profileCacheMap", /* @__PURE__ */ new Map());
    //alias for Loader compatibility
    __publicField(this, "loadAsync", this.load);
    this.baseAssetPath = (options == null ? void 0 : options.baseAssetPath) ?? DefaultAssetBasePath;
    this.defaultProfileId = (options == null ? void 0 : options.defaultControllerProfileId) ?? DefaultDefaultControllerProfileId;
  }
  load(inputSourceProfileIds, handedness) {
    return syncAsync(
      //load profile
      () => this.loadProfile(inputSourceProfileIds),
      //get controller layout from profile
      (profile) => {
        for (const key in profile.layouts) {
          if (!key.includes(handedness)) {
            continue;
          }
          return profile.layouts[key];
        }
        throw new Error(`No matching layout for "${handedness}", in profile ${profile.profileId} with layouts ${Object.keys(profile.layouts).join(", ")}.`);
      }
    );
  }
  loadProfile(inputSourceProfileIds) {
    return syncAsync(
      //load profiles list
      () => this.profilesListCache ?? fetchJson(new URL("profilesList.json", this.baseAssetPath).href).then((profilesList) => this.profilesListCache = profilesList),
      //load profile
      (profilesList) => {
        const length = inputSourceProfileIds.length;
        let profileInfo;
        for (let i2 = 0; i2 < length; i2++) {
          profileInfo = profilesList[inputSourceProfileIds[i2]];
          if (profileInfo != null) {
            break;
          }
        }
        profileInfo ?? (profileInfo = profilesList[this.defaultProfileId]);
        if (profileInfo == null) {
          throw new Error(`no matching profile found for profiles "${inputSourceProfileIds.join(", ")}" in profile list ${JSON.stringify(profilesList)}`);
        }
        return this.loadProfileFromPath(profileInfo.path);
      }
    );
  }
  loadProfileFromPath(relativeProfilePath) {
    const result = this.profileCacheMap.get(relativeProfilePath);
    if (result != null) {
      return result;
    }
    const absoluteProfilePath = new URL(relativeProfilePath, this.baseAssetPath).href;
    return fetchJson(absoluteProfilePath).then((profile) => {
      for (const key in profile.layouts) {
        const layout = profile.layouts[key];
        if (layout == null) {
          continue;
        }
        layout.assetPath = new URL(layout.assetPath, absoluteProfilePath).href;
      }
      this.profileCacheMap.set(relativeProfilePath, profile);
      return profile;
    });
  }
};
async function fetchJson(url) {
  let response = await fetch(url);
  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }
  return response.json();
}

// node_modules/@pmndrs/xr/dist/controller/state.js
function createXRControllerState(id, inputSource, layoutLoader, events, isPrimary) {
  return syncAsync(() => layoutLoader.load(inputSource.profiles, inputSource.handedness), (layout) => {
    const gamepad = {};
    updateXRControllerGamepadState(gamepad, inputSource, layout);
    return {
      id,
      isPrimary,
      events,
      type: "controller",
      inputSource,
      gamepad,
      layout
    };
  });
}
function updateXRControllerState({ gamepad, inputSource, layout }) {
  updateXRControllerGamepadState(gamepad, inputSource, layout);
}

// node_modules/@react-three/xr/dist/space.js
var import_react12 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/contexts.js
var import_react = __toESM(require_react(), 1);
var xrContext = (0, import_react.createContext)(void 0);
var xrInputSourceStateContext = (0, import_react.createContext)(void 0);
var xrSpaceContext = (0, import_react.createContext)(void 0);
var combinedPointerContext = (0, import_react.createContext)(void 0);

// node_modules/@react-three/xr/dist/xr.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl2 = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore2 = (createState) => createState ? createStoreImpl2(createState) : createStoreImpl2;

// node_modules/@react-three/xr/node_modules/zustand/esm/index.mjs
var import_react2 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var { useDebugValue } = import_react2.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore2(api, selector = identity, equalityFn) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore2(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore2(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/@react-three/xr/dist/elements.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/utils.js
var i = 0;
var map2 = /* @__PURE__ */ new Map();
function objectToKey(object) {
  let key = map2.get(object);
  if (key == null) {
    map2.set(object, key = i++);
  }
  return key;
}

// node_modules/@react-three/xr/dist/hooks.js
var import_react3 = __toESM(require_react(), 1);
function useHover(ref, onChange) {
  let setHover;
  let hover;
  if (onChange == null) {
    const [_hover, _setHover] = (0, import_react3.useState)(false);
    setHover = _setHover;
    hover = _hover;
  } else {
    setHover = onChange;
  }
  (0, import_react3.useEffect)(() => {
    const { current } = ref;
    if (current == null) {
      return;
    }
    const set = /* @__PURE__ */ new Set();
    const enter = (e) => {
      if (set.size === 0) {
        setHover(true);
      }
      set.add(e.pointerId);
    };
    const leave = (e) => {
      set.delete(e.pointerId);
      if (set.size === 0) {
        setHover(false);
      }
    };
    current.addEventListener("pointerenter", enter);
    current.addEventListener("pointerleave", leave);
    return () => {
      current.removeEventListener("pointerenter", enter);
      current.removeEventListener("pointerleave", leave);
    };
  }, [ref, setHover]);
  return hover;
}
function useXRSessionVisibilityState() {
  return useXR((xr) => xr.visibilityState);
}
function useInitRoomCapture() {
  return useXR((xr) => {
    var _a, _b;
    return (_b = (_a = xr.session) == null ? void 0 : _a.initiateRoomCapture) == null ? void 0 : _b.bind(xr.session);
  });
}
function useSessionModeSupported(mode, onError) {
  const onErrorRef = (0, import_react3.useRef)(onError);
  onErrorRef.current = onError;
  const [subscribe, getSnapshot] = (0, import_react3.useMemo)(() => {
    let sessionSupported = void 0;
    return [
      (onChange) => {
        let canceled = false;
        if (navigator.xr == null) {
          sessionSupported = false;
          return () => {
          };
        }
        navigator.xr.isSessionSupported(mode).then((isSupported) => {
          sessionSupported = isSupported;
          if (canceled) {
            return;
          }
          onChange();
        }).catch((e) => {
          var _a;
          if (canceled) {
            return;
          }
          (_a = onErrorRef.current) == null ? void 0 : _a.call(onErrorRef, e);
        });
        return () => canceled = true;
      },
      () => sessionSupported
    ];
  }, [mode]);
  return (0, import_react3.useSyncExternalStore)(subscribe, getSnapshot);
}
function useSessionFeatureEnabled(feature) {
  return useXR(({ session }) => {
    var _a;
    return ((_a = session == null ? void 0 : session.enabledFeatures) == null ? void 0 : _a.includes(feature)) ?? false;
  });
}

// node_modules/@react-three/xr/dist/default.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/controller.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/input.js
var import_react4 = __toESM(require_react(), 1);
function useXRInputSourceStates() {
  return useXR((xr) => xr.inputSourceStates);
}
function useXRInputSourceState(type, handedness) {
  return useXR((s) => s.inputSourceStates.find((state) => state.type === type && (handedness == null || state.inputSource.handedness === handedness)));
}
function useXRInputSourceStateContext(type) {
  const state = (0, import_react4.useContext)(xrInputSourceStateContext);
  if (state == null || type != null && state.type != type) {
    throw new Error(`useXRInputSourceStateContext() can only be used inside a the xr store config`);
  }
  return state;
}
function useXRInputSourceEvent(inputSource, event, fn, deps) {
  const session = useXR((xr) => xr.session);
  (0, import_react4.useEffect)(() => {
    if (session == null || inputSource == null) {
      return;
    }
    return bindXRInputSourceEvent(session, inputSource, event, fn);
  }, [event, inputSource, session, ...deps]);
}

// node_modules/@react-three/xr/dist/controller.js
var XRControllerComponent = (0, import_react5.forwardRef)(({ id, children, onPress, onRelease }, ref) => {
  const state = useXRInputSourceStateContext("controller");
  const [object, setObject] = (0, import_react5.useState)(void 0);
  (0, import_react5.useImperativeHandle)(ref, () => object, [object]);
  useXRControllerButtonEvent(state, id, (state2) => state2 === "pressed" ? onPress == null ? void 0 : onPress() : onRelease == null ? void 0 : onRelease());
  useFrame(() => {
    var _a;
    return setObject((_a = state.gamepad[id]) == null ? void 0 : _a.object);
  });
  if (object == null) {
    return;
  }
  return createPortal(children, object);
});
function useXRControllerButtonEvent(controller, id, onChange) {
  const state = (0, import_react5.useRef)();
  useFrame(() => {
    var _a;
    const currentState = (_a = controller == null ? void 0 : controller.gamepad[id]) == null ? void 0 : _a.state;
    if (currentState != null && currentState != state.current) {
      onChange(currentState);
    }
    state.current = currentState;
  });
}
var LoadXRControllerModelSymbol = Symbol("loadXRControllerModel");
var XRControllerModel2 = (0, import_react5.forwardRef)((options, ref) => {
  const state = useXRInputSourceStateContext("controller");
  const model = suspend(loadXRControllerModel, [state.layout, void 0, LoadXRControllerModelSymbol]);
  configureXRControllerModel(model, options);
  state.object = model;
  (0, import_react5.useImperativeHandle)(ref, () => model, [model]);
  const update = (0, import_react5.useMemo)(() => createUpdateXRControllerVisuals(model, state.layout, state.gamepad), [model, state.layout, state.gamepad]);
  useFrame(update);
  return (0, import_jsx_runtime.jsx)("primitive", { object: model });
});

// node_modules/@react-three/xr/dist/hand.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var XRHandModel2 = (0, import_react6.forwardRef)((options, ref) => {
  const state = useXRInputSourceStateContext("hand");
  const gltf = useLoader(GLTFLoader, state.assetPath);
  const model = (0, import_react6.useMemo)(() => cloneXRHandGltf(gltf), [gltf]);
  configureXRHandModel(model, options);
  (0, import_react6.useImperativeHandle)(ref, () => model, [model]);
  const referenceSpace = useXRSpace();
  const update = (0, import_react6.useMemo)(() => createUpdateXRHandVisuals(state.inputSource.hand, model, referenceSpace), [state.inputSource, model, referenceSpace]);
  useFrame((_state, _delta, frame) => update(frame));
  return (0, import_jsx_runtime2.jsx)("primitive", { object: model });
});
var XRHandJoint = (0, import_react6.forwardRef)(({ joint, children }, ref) => {
  const state = useXRInputSourceStateContext("hand");
  return (0, import_jsx_runtime2.jsx)(XRSpace3, { ref, space: state.inputSource.hand.get(joint), children });
});

// node_modules/@react-three/xr/dist/pointer.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
function CombinedPointer2({ children }) {
  const pointer = (0, import_react7.useMemo)(() => new CombinedPointer(), []);
  usePointerXRSessionVisibility(pointer);
  useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);
  return (0, import_jsx_runtime3.jsx)(combinedPointerContext.Provider, { value: pointer, children });
}
function useGrabPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react7.useMemo)(() => ({}), []);
  Object.assign(options, defaultGrabPointerOptions, currentOptions);
  const pointer = (0, import_react7.useMemo)(() => createGrabPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions == null ? void 0 : currentOptions.makeDefault);
  return pointer;
}
function useRayPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react7.useMemo)(() => ({}), []);
  Object.assign(options, defaultRayPointerOptions, currentOptions);
  const pointer = (0, import_react7.useMemo)(() => createRayPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions == null ? void 0 : currentOptions.makeDefault);
  return pointer;
}
function useTouchPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react7.useMemo)(() => ({}), []);
  Object.assign(options, defaultTouchPointerOptions, currentOptions);
  const pointer = (0, import_react7.useMemo)(() => createTouchPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions == null ? void 0 : currentOptions.makeDefault);
  return pointer;
}
var PointerRayModel2 = (0, import_react7.forwardRef)((props, ref) => {
  const material = (0, import_react7.useMemo)(() => new PointerRayMaterial(), []);
  const internalRef = (0, import_react7.useRef)(null);
  (0, import_react7.useImperativeHandle)(ref, () => internalRef.current, []);
  useFrame(() => internalRef.current != null && updatePointerRayModel(internalRef.current, material, props.pointer, props));
  return (0, import_jsx_runtime3.jsx)("mesh", { matrixAutoUpdate: false, renderOrder: props.renderOrder ?? 2, ref: internalRef, material, children: (0, import_jsx_runtime3.jsx)("boxGeometry", {}) });
});
var PointerCursorModel2 = (0, import_react7.forwardRef)((props, ref) => {
  const material = (0, import_react7.useMemo)(() => new PointerCursorMaterial(), []);
  const internalRef = (0, import_react7.useRef)(null);
  (0, import_react7.useImperativeHandle)(ref, () => internalRef.current, []);
  useFrame(() => internalRef.current != null && updatePointerCursorModel(internalRef.current, material, props.pointer, props));
  const scene = useThree((s) => s.scene);
  return createPortal((0, import_jsx_runtime3.jsx)("mesh", { renderOrder: props.renderOrder ?? 1, ref: internalRef, matrixAutoUpdate: false, material, children: (0, import_jsx_runtime3.jsx)("planeGeometry", {}) }), scene);
});
function usePointerXRInputSourceEvents(pointer, inputSource, event, missingEvents) {
  const session = useXR((xr) => xr.session);
  (0, import_react7.useEffect)(() => {
    if (session == null) {
      return;
    }
    return bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents);
  }, [event, inputSource, pointer, session, missingEvents]);
}
function useSetupPointer(pointer, makeDefault = false) {
  const combinedPointer = (0, import_react7.useContext)(combinedPointerContext);
  if (combinedPointer == null) {
    usePointerXRSessionVisibility(pointer);
    useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);
  } else {
    (0, import_react7.useEffect)(() => combinedPointer.register(pointer, makeDefault), [combinedPointer, pointer, makeDefault]);
  }
  (0, import_react7.useEffect)(() => () => pointer.exit({ timeStamp: performance.now() }), [pointer]);
}
function usePointerXRSessionVisibility(pointer) {
  const store = useXRStore();
  (0, import_react7.useEffect)(() => setupSyncIsVisible(store, (visible) => pointer.setEnabled(visible, { timeStamp: performance.now() })), [store, pointer]);
}

// node_modules/@react-three/xr/dist/teleport.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
function TeleportTarget({ children, onTeleport }) {
  const ref = (0, import_react8.useRef)(null);
  const teleportRef = (0, import_react8.useRef)(onTeleport);
  teleportRef.current = onTeleport;
  const store = useStore();
  (0, import_react8.useEffect)(() => {
    if (ref.current == null) {
      return;
    }
    return makeTeleportTarget(ref.current, () => store.getState().camera, (point, event) => {
      var _a;
      return (_a = teleportRef.current) == null ? void 0 : _a.call(teleportRef, point, event);
    });
  }, [store]);
  return (0, import_jsx_runtime4.jsx)("group", { pointerEventsType: { allow: "teleport" }, ref, children });
}
var TeleportPointerRayModel2 = (0, import_react8.forwardRef)(({ pointer, linePoints, ...options }, ref) => {
  const mesh = (0, import_react8.useMemo)(() => new TeleportPointerRayModel(linePoints), [linePoints]);
  (0, import_react8.useImperativeHandle)(ref, () => mesh, [mesh]);
  mesh.options = options;
  useFrame(() => mesh.update(pointer));
  return (0, import_jsx_runtime4.jsx)("primitive", { object: mesh });
});

// node_modules/@react-three/xr/dist/default.js
function DefaultXRInputSourceGrabPointer(event, getSpace, options) {
  const state = (0, import_react9.useContext)(xrInputSourceStateContext);
  if (state == null) {
    throw new Error(`DefaultXRInputSourceGrabPointer can only be used inside a XRInputSource`);
  }
  const ref = (0, import_react9.useRef)(null);
  const pointer = useGrabPointer(ref, state, options);
  usePointerXRInputSourceEvents(pointer, state.inputSource, event, state.events);
  const cursorModelOptions = options.cursorModel;
  return (0, import_jsx_runtime5.jsx)(XRSpace3, { ref, space: getSpace(state.inputSource), children: cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { pointer, opacity: defaultGrabPointerOpacity, ...spreadable(cursorModelOptions) }) });
}
var DefaultXRHandGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, "select", (inputSource) => inputSource.hand.get("index-finger-tip"));
var DefaultXRControllerGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, "squeeze", (inputSource) => inputSource.gripSpace);
function DefaultXRInputSourceRayPointer(options) {
  const state = useXRInputSourceStateContext();
  const ref = (0, import_react9.useRef)(null);
  const pointer = useRayPointer(ref, state, options);
  usePointerXRInputSourceEvents(pointer, state.inputSource, "select", state.events);
  const rayModelOptions = options.rayModel;
  const cursorModelOptions = options.cursorModel;
  return (0, import_jsx_runtime5.jsxs)(XRSpace3, { ref, space: state.inputSource.targetRaySpace, children: [rayModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerRayModel2, { pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) }), cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) })] });
}
function DefaultXRHandTouchPointer(options) {
  const state = useXRInputSourceStateContext("hand");
  const ref = (0, import_react9.useRef)(null);
  const pointer = useTouchPointer(ref, state, options);
  const cursorModelOptions = options.cursorModel;
  return (0, import_jsx_runtime5.jsx)(XRSpace3, { ref, space: state.inputSource.hand.get("index-finger-tip"), children: cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { pointer, opacity: defaultTouchPointerOpacity, ...spreadable(cursorModelOptions) }) });
}
function DefaultXRController(options) {
  const modelOptions = options.model;
  const grabPointerOptions = options.grabPointer;
  const rayPointerOptions = options.rayPointer;
  const teleportPointerOptions = options.teleportPointer ?? false;
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [modelOptions !== false && (0, import_jsx_runtime5.jsx)(import_react9.Suspense, { children: (0, import_jsx_runtime5.jsx)(XRControllerModel2, { ...spreadable(modelOptions) }) }), (0, import_jsx_runtime5.jsxs)(CombinedPointer2, { children: [grabPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRControllerGrabPointer, { ...spreadable(grabPointerOptions) }), rayPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions) }), teleportPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) })] })] });
}
function DefaultXRHand(options) {
  var _a;
  const modelOptions = options.model;
  const grabPointerOptions = options.grabPointer;
  const rayPointerOptions = options.rayPointer;
  const touchPointerOptions = options.touchPointer;
  const teleportPointerOptions = options.teleportPointer ?? false;
  const rayPointerRayModelOptions = rayPointerOptions === false ? false : (_a = spreadable(rayPointerOptions)) == null ? void 0 : _a.rayModel;
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [modelOptions !== false && (0, import_jsx_runtime5.jsx)(import_react9.Suspense, { children: (0, import_jsx_runtime5.jsx)(XRHandModel2, { ...spreadable(modelOptions) }) }), (0, import_jsx_runtime5.jsxs)(CombinedPointer2, { children: [grabPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRHandGrabPointer, { ...spreadable(grabPointerOptions) }), touchPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRHandTouchPointer, { ...spreadable(touchPointerOptions) }), rayPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions), rayModel: rayPointerRayModelOptions === false ? false : { maxLength: 0.2, ...spreadable(rayPointerRayModelOptions) } }), teleportPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) })] })] });
}
function DefaultXRTransientPointer(options) {
  return (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });
}
function DefaultXRGaze(options) {
  return (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });
}
function DefaultXRScreenInput(options) {
  return (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { ...options, cursorModel: false, rayModel: false });
}
function DefaultXRInputSourceTeleportPointer(options) {
  const state = (0, import_react9.useContext)(xrInputSourceStateContext);
  if (state == null) {
    throw new Error(`DefaultXRInputSourceRayPointer can only be used inside a XRInputSource`);
  }
  const ref = (0, import_react9.useRef)(null);
  const groupRef = (0, import_react9.useRef)(null);
  const linePoints = (0, import_react9.useMemo)(() => createTeleportRayLine(), []);
  const pointer = useRayPointer(groupRef, state, {
    ...options,
    linePoints,
    customFilter: buildTeleportTargetFilter(options)
  }, "teleport");
  usePointerXRInputSourceEvents(pointer, state.inputSource, "select", state.events);
  const rayModelOptions = options.rayModel;
  const cursorModelOptions = options.cursorModel;
  const scene = useThree((state2) => state2.scene);
  const cursorRef = (0, import_react9.useRef)(null);
  useFrame((_, delta) => {
    if (cursorRef.current != null) {
      cursorRef.current.visible = pointer.getEnabled() && pointer.getButtonsDown().size > 0;
    }
    const target = groupRef.current;
    const source = ref.current;
    if (target == null || source == null) {
      return;
    }
    syncTeleportPointerRayGroup(source, target, delta * 1e3);
  });
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [(0, import_jsx_runtime5.jsx)(XRSpace3, { ref, space: state.inputSource.targetRaySpace }), createPortal((0, import_jsx_runtime5.jsxs)("group", { ref: groupRef, children: [rayModelOptions !== false && (0, import_jsx_runtime5.jsx)(TeleportPointerRayModel2, { linePoints, pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) }), cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { ref: cursorRef, pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) })] }), scene)] });
}
function spreadable(value) {
  if (value === true) {
    return void 0;
  }
  return value;
}

// node_modules/@react-three/xr/node_modules/zustand/esm/shallow.mjs
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}

// node_modules/@react-three/xr/dist/elements.js
function XRElements({ children }) {
  const referenceSpace = useXR((xr) => xr.originReferenceSpace);
  const origin = useXR((xr) => xr.origin);
  const visible = useXRSessionVisibilityState() === "visible";
  const store = useStore();
  const storeWithOriginAsScene = (0, import_react10.useMemo)(() => Object.assign({}, store, {
    getState() {
      return { ...store.getState(), scene: origin };
    }
  }), [origin, store]);
  if (origin == null || referenceSpace == null) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: reconciler.createPortal((0, import_jsx_runtime6.jsx)(context.Provider, { value: store, children: (0, import_jsx_runtime6.jsxs)(xrSpaceContext.Provider, { value: referenceSpace, children: [(0, import_jsx_runtime6.jsxs)("group", { matrixAutoUpdate: false, visible, children: [(0, import_jsx_runtime6.jsx)(XRControllers, {}), (0, import_jsx_runtime6.jsx)(XRHands, {}), (0, import_jsx_runtime6.jsx)(XRTransientPointers, {}), (0, import_jsx_runtime6.jsx)(XRGazes, {}), (0, import_jsx_runtime6.jsx)(XRScreenInputs, {})] }), children] }) }), storeWithOriginAsScene, null) });
}
function XRControllers() {
  const controllerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "controller"), shallow$1);
  let Implementation = useXR((xr) => xr.controller);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: controllerStates.map((state) => {
    const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});
    if (ResolvedImpl === false) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(XRSpace3, { space: state.inputSource.gripSpace, children: (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(import_react10.Suspense, { children: typeof ResolvedImpl === "function" ? (0, import_jsx_runtime6.jsx)(ResolvedImpl, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRController, { ...ResolvedImpl }) }) }) }, state.id);
  }) });
}
function XRHands() {
  const handStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "hand"), shallow$1);
  const Implementation = useXR((xr) => xr.hand);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: handStates.map((state) => {
    const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});
    if (ResolvedImpl === false) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(XRSpace3, { space: state.inputSource.hand.get("wrist"), children: (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(import_react10.Suspense, { children: typeof ResolvedImpl === "function" ? (0, import_jsx_runtime6.jsx)(ResolvedImpl, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRHand, { ...ResolvedImpl }) }) }) }, objectToKey(state));
  }) });
}
function XRTransientPointers() {
  const transientPointerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "transientPointer"), shallow$1);
  const Implementation = useXR((xr) => xr.transientPointer);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: transientPointerStates.map((state) => {
    const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});
    if (ResolvedImpl === false) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(XRSpace3, { space: state.inputSource.targetRaySpace, children: (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(import_react10.Suspense, { children: typeof ResolvedImpl === "function" ? (0, import_jsx_runtime6.jsx)(ResolvedImpl, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRTransientPointer, { ...ResolvedImpl }) }) }) }, objectToKey(state));
  }) });
}
function XRGazes() {
  const gazeStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "gaze"), shallow$1);
  const Implementation = useXR((xr) => xr.gaze);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: gazeStates.map((state) => {
    return (0, import_jsx_runtime6.jsx)(XRSpace3, { space: state.inputSource.targetRaySpace, children: (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(import_react10.Suspense, { children: typeof Implementation === "function" ? (0, import_jsx_runtime6.jsx)(Implementation, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRGaze, { ...spreadable2(Implementation) }) }) }) }, objectToKey(state));
  }) });
}
function XRScreenInputs() {
  const screenInputStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "screenInput"), shallow$1);
  const Implementation = useXR((xr) => xr.screenInput);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: screenInputStates.map((state) => {
    return (0, import_jsx_runtime6.jsx)(XRSpace3, { space: state.inputSource.targetRaySpace, children: (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(import_react10.Suspense, { children: typeof Implementation === "function" ? (0, import_jsx_runtime6.jsx)(Implementation, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRScreenInput, { ...spreadable2(Implementation) }) }) }) }, objectToKey(state));
  }) });
}
function spreadable2(value) {
  if (value === true) {
    return void 0;
  }
  return value;
}

// node_modules/@react-three/xr/dist/xr.js
function createXRStore2(options) {
  return createXRStore(options);
}
function XR({ children, store }) {
  store.setWebXRManager(useThree((s) => s.gl.xr));
  const rootStore = useStore();
  (0, import_react11.useEffect)(() => {
    let initialCamera;
    return store.subscribe((state, prevState) => {
      if (state.session === prevState.session) {
        return;
      }
      if (state.session != null) {
        const { camera, gl } = rootStore.getState();
        initialCamera = camera;
        rootStore.setState({ camera: gl.xr.getCamera() });
        return;
      }
      if (initialCamera == null) {
        return;
      }
      rootStore.setState({ camera: initialCamera });
    });
  }, [rootStore, store]);
  useFrame((state, _delta, frame) => store.onBeforeFrame(state.scene, state.camera, frame), -1e3);
  useFrame(() => store.onBeforeRender());
  return (0, import_jsx_runtime7.jsxs)(xrContext.Provider, { value: store, children: [(0, import_jsx_runtime7.jsx)(XRElements, {}), children] });
}
function useXRStore() {
  const store = (0, import_react11.useContext)(xrContext);
  if (store == null) {
    throw new Error(`XR features can only be used inside the <XR> component`);
  }
  return store;
}
function useXR(selector = (state) => state, equalityFn) {
  return useStore2(useXRStore(), selector, equalityFn);
}

// node_modules/@react-three/xr/dist/space.js
var XRSpace3 = (0, import_react12.forwardRef)(({ space, children }, ref) => {
  const internalRef = (0, import_react12.useRef)(null);
  const resolvedSpace = typeof space === "string" ? useXRSpace(space) : space;
  (0, import_react12.useImperativeHandle)(ref, () => internalRef.current, []);
  useApplyXRSpaceMatrix(internalRef, resolvedSpace, (_state, _delta, frame) => {
    if (internalRef.current == null) {
      return;
    }
    internalRef.current.visible = frame != null;
  });
  if (resolvedSpace == null) {
    return null;
  }
  return (0, import_jsx_runtime8.jsx)("group", { xrSpace: resolvedSpace, visible: false, matrixAutoUpdate: false, ref: internalRef, children: (0, import_jsx_runtime8.jsx)(xrSpaceContext.Provider, { value: resolvedSpace, children }) });
});
function useXRSpace(type) {
  if (type == null) {
    const context2 = (0, import_react12.useContext)(xrSpaceContext);
    if (context2 == null) {
      throw new Error(`XR objects must be placed inside the XROrigin`);
    }
    return context2;
  }
  const [referenceSpace, setReferenceSpace] = (0, import_react12.useState)(void 0);
  const session = useXR((xr) => xr.session);
  (0, import_react12.useEffect)(() => {
    if (session == null) {
      return;
    }
    let aborted = false;
    session.requestReferenceSpace(type).then((space) => {
      if (aborted) {
        return;
      }
      setReferenceSpace(space);
    });
    return () => void (aborted = true);
  }, [session, type]);
  return referenceSpace;
}
function useGetXRSpaceMatrix(space) {
  const localReferenceSpace = (0, import_react12.useContext)(xrSpaceContext);
  const referenceSpace = useXR((xr) => localReferenceSpace ?? xr.originReferenceSpace);
  return (0, import_react12.useMemo)(() => space == null || referenceSpace == null ? void 0 : createGetXRSpaceMatrix(space, referenceSpace), [space, referenceSpace]);
}
function useApplyXRSpaceMatrix(ref, space, onFrame) {
  const getXRSpaceMatrix = useGetXRSpaceMatrix(space);
  useFrame((state, delta, frame) => {
    if (ref.current == null || getXRSpaceMatrix == null) {
      return;
    }
    getXRSpaceMatrix(ref.current.matrix, frame);
    onFrame == null ? void 0 : onFrame(state, delta, frame);
  }, -100);
}

// node_modules/@react-three/xr/dist/mesh.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var XRMeshModel = (0, import_react13.forwardRef)(({ mesh, ...rest }, ref) => {
  const geometry = useXRMeshGeometry(mesh);
  return (0, import_jsx_runtime9.jsx)("mesh", { ref, geometry, ...rest });
});
function useXRMeshes(semanticLabel) {
  const meshes = useXR((xr) => xr.detectedMeshes);
  return (0, import_react13.useMemo)(() => semanticLabel == null ? meshes : meshes.filter((mesh) => mesh.semanticLabel === semanticLabel), [meshes, semanticLabel]);
}
function useXRMeshGeometry(mesh, disposeBuffer = true) {
  const [geometry, setGeometry] = (0, import_react13.useState)(updateXRMeshGeometry(mesh, void 0));
  useFrame(() => setGeometry((geometry2) => updateXRMeshGeometry(mesh, geometry2)));
  (0, import_react13.useEffect)(() => {
    if (!disposeBuffer) {
      return;
    }
    return () => geometry.dispose();
  }, [geometry]);
  return geometry;
}

// node_modules/@react-three/xr/dist/plane.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var XRPlaneModel = (0, import_react14.forwardRef)(({ plane, ...rest }, ref) => {
  const geometry = useXRPlaneGeometry(plane);
  return (0, import_jsx_runtime10.jsx)("mesh", { ref, geometry, ...rest });
});
function useXRPlanes(semanticLabel) {
  const planes = useXR((xr) => xr.detectedPlanes);
  return (0, import_react14.useMemo)(() => semanticLabel == null ? planes : planes.filter((plane) => plane.semanticLabel === semanticLabel), [planes, semanticLabel]);
}
function useXRPlaneGeometry(plane, disposeBuffer = true) {
  const [geometry, setGeometry] = (0, import_react14.useState)(updateXRPlaneGeometry(plane, void 0));
  useFrame(() => setGeometry((geometry2) => updateXRPlaneGeometry(plane, geometry2)));
  (0, import_react14.useEffect)(() => {
    if (!disposeBuffer) {
      return;
    }
    return () => geometry.dispose();
  }, [geometry]);
  return geometry;
}

// node_modules/@react-three/xr/dist/guard/facing-camera.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
function useIsFacingCamera(ref, set, direction, angle) {
  const camera = useThree((state) => state.camera);
  useFrame(() => {
    if (ref.current == null) {
      return;
    }
    set(isFacingCamera(camera, ref.current, direction, angle));
  });
}
function ShowIfFacingCamera({ children, direction, angle = Math.PI / 2 }) {
  const ref = (0, import_react15.useRef)(null);
  useIsFacingCamera(ref, (visible) => {
    if (ref.current == null) {
      return;
    }
    ref.current.visible = visible;
  }, direction, angle);
  return (0, import_jsx_runtime11.jsx)("group", { ref, children });
}
function IfFacingCamera({ children, direction, angle = Math.PI / 2 }) {
  const ref = (0, import_react15.useRef)(null);
  const [show, setShow] = (0, import_react15.useState)(false);
  useIsFacingCamera(ref, setShow, direction, angle);
  return show ? (0, import_jsx_runtime11.jsx)(import_jsx_runtime11.Fragment, { children }) : null;
}

// node_modules/@react-three/xr/dist/guard/session-mode.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function useIsInSessionMode(allow, deny) {
  const mode = useXR((state) => state.mode);
  if (deny != null) {
    return Array.isArray(deny) ? !deny.includes(mode) : deny != mode;
  }
  if (allow != null) {
    return Array.isArray(allow) ? allow.includes(mode) : allow === mode;
  }
  return true;
}
function ShowIfInSessionMode({ children, allow, deny }) {
  const visible = useIsInSessionMode(allow, deny);
  return (0, import_jsx_runtime12.jsx)("group", { visible, children });
}
function IfInSessionMode({ children, allow, deny }) {
  const visible = useIsInSessionMode(allow, deny);
  return visible ? (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children }) : null;
}

// node_modules/@react-three/xr/dist/guard/session-supported.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function ShowIfSessionModeSupported({ children, mode }) {
  const supported = useSessionModeSupported(mode);
  return (0, import_jsx_runtime13.jsx)("group", { visible: supported, children });
}
function IfSessionModeSupported({ children, mode }) {
  const supported = useSessionModeSupported(mode);
  if (!supported) {
    return null;
  }
  return (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children });
}

// node_modules/@react-three/xr/dist/guard/focus.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function ShowIfSessionVisible({ children }) {
  const state = useXRSessionVisibilityState();
  return (0, import_jsx_runtime14.jsx)("group", { visible: state == null || state === "visible", children });
}
function IfSessionVisible({ children }) {
  const state = useXRSessionVisibilityState();
  if (state != "visible" && state != null) {
    return null;
  }
  return (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children });
}

// node_modules/@react-three/xr/dist/origin.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var XROrigin = (0, import_react16.forwardRef)(({ children, ...props }, ref) => {
  const xrCamera = useThree((s) => s.gl.xr.getCamera());
  const referenceSpace = useXR((xr) => xr.originReferenceSpace);
  if (referenceSpace == null) {
    return null;
  }
  return (0, import_jsx_runtime15.jsxs)("group", { ref, ...props, children: [(0, import_jsx_runtime15.jsx)("primitive", { object: xrCamera }), (0, import_jsx_runtime15.jsx)(xrSpaceContext.Provider, { value: referenceSpace, children })] });
});

// node_modules/@react-three/xr/dist/hit-test.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
function useXRHitTestSource(relativeTo, trackableType) {
  const [source, setState] = (0, import_react17.useState)();
  useCreateXRHitTestSource(relativeTo, trackableType, setState);
  return source;
}
function useXRHitTest(fn, relativeTo, trackableType) {
  const sourceRef = (0, import_react17.useRef)(void 0);
  useCreateXRHitTestSource(relativeTo, trackableType, (0, import_react17.useCallback)((source) => sourceRef.current = source, []));
  useFrame((_s, _d, frame) => {
    if (fn == null || frame == null || sourceRef.current == null) {
      return;
    }
    fn(frame.getHitTestResults(sourceRef.current.source), sourceRef.current.getWorldMatrix);
  });
}
function useCreateXRHitTestSource(relativeTo, trackableType, onLoad) {
  const store = useXRStore();
  (0, import_react17.useEffect)(() => {
    let storedResult;
    let cancelled = false;
    const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === "string" ? relativeTo : relativeTo == null ? void 0 : relativeTo.current;
    if (relativeToResolved == null) {
      return;
    }
    createXRHitTestSource(store, relativeToResolved, trackableType).then((result) => {
      if (cancelled) {
        return;
      }
      storedResult = result;
      onLoad(result);
    });
    return () => {
      onLoad(void 0);
      cancelled = true;
      storedResult == null ? void 0 : storedResult.source.cancel();
    };
  }, [store, relativeTo, trackableType, onLoad]);
}
function useXRRequestHitTest() {
  const store = useXRStore();
  return (0, import_react17.useCallback)((relativeTo, trackableType) => {
    const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === "string" ? relativeTo : relativeTo.current;
    if (relativeToResolved == null) {
      return;
    }
    return requestXRHitTest(store, relativeToResolved, trackableType);
  }, [store]);
}
var XRHitTest = (0, import_react17.forwardRef)(({ trackableType, onResults, space, ...rest }, ref) => {
  const internalRef = (0, import_react17.useRef)(null);
  (0, import_react17.useImperativeHandle)(ref, () => internalRef.current);
  useXRHitTest(onResults, space ?? internalRef, trackableType);
  return (0, import_jsx_runtime16.jsx)("group", { ...rest, ref: internalRef });
});

// node_modules/@react-three/xr/dist/anchor.js
var import_react18 = __toESM(require_react(), 1);
function useRequestXRAnchor() {
  const store = useXRStore();
  return (0, import_react18.useMemo)(() => requestXRAnchor.bind(null, store), [store]);
}
function useXRAnchor() {
  const [anchor, setAnchor] = (0, import_react18.useState)(void 0);
  const cleanup = (0, import_react18.useRef)(() => {
  });
  const store = useXRStore();
  const create2 = (0, import_react18.useCallback)(async (options) => {
    var _a;
    (_a = cleanup.current) == null ? void 0 : _a.call(cleanup);
    cleanup.current = void 0;
    let cancelled = false;
    cleanup.current = () => cancelled = true;
    const anchor2 = await requestXRAnchor(store, options);
    if (cancelled) {
      anchor2 == null ? void 0 : anchor2.delete();
      return void 0;
    }
    cleanup.current = () => anchor2 == null ? void 0 : anchor2.delete();
    setAnchor(anchor2);
    return anchor2;
  }, [store]);
  (0, import_react18.useEffect)(() => () => {
    var _a;
    return void ((_a = cleanup.current) == null ? void 0 : _a.call(cleanup));
  }, []);
  return [anchor, create2];
}

// node_modules/@react-three/xr/dist/dom-overlay.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);
var XRDomOverlay = (0, import_react19.forwardRef)((props, ref) => {
  const domOverlayRoot = useXR((xr) => xr.domOverlayRoot);
  const { In, Out } = (0, import_react19.useMemo)(tunnel, []);
  (0, import_react19.useEffect)(() => {
    const root = (0, import_client.createRoot)(domOverlayRoot);
    root.render((0, import_jsx_runtime17.jsx)(Out, {}));
    return () => root.unmount();
  }, [domOverlayRoot, Out]);
  return (0, import_jsx_runtime17.jsx)(In, { children: (0, import_jsx_runtime17.jsx)("div", { ...props, ref }) });
});

// node_modules/@react-three/xr/dist/layer.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
function XRLayer({ src, pixelWidth = 1024, pixelHeight = 1024, renderPriority = 0, children, ...props }) {
  const [hasSize, setHasSize] = (0, import_react20.useState)(false);
  const ref = (0, import_react20.useRef)(null);
  const renderTargetRef = (0, import_react20.useRef)(void 0);
  const layerEntryRef = (0, import_react20.useRef)(void 0);
  (0, import_react20.useEffect)(() => {
    setHasSize(false);
    let aborted = false;
    waitForXRLayerSrcSize(src).then(() => !aborted && setHasSize(true));
    return () => void (aborted = true);
  }, [src]);
  const layersEnabled = useSessionFeatureEnabled("layers");
  const geometry = (0, import_react20.useMemo)(() => createXRLayerGeometry(props.shape ?? "quad", {
    centralAngle: props.centralAngle,
    centralHorizontalAngle: props.centralHorizontalAngle,
    lowerVerticalAngle: props.lowerVerticalAngle,
    upperVerticalAngle: props.upperVerticalAngle
  }), [props.centralAngle, props.centralHorizontalAngle, props.lowerVerticalAngle, props.shape, props.upperVerticalAngle]);
  const store = useLayerStore(pixelWidth, pixelHeight);
  useForwardEvents(store, ref, [hasSize, layersEnabled]);
  if (!hasSize) {
    return null;
  }
  return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [src == null && (0, import_jsx_runtime18.jsx)(ChildrenToRenderTarget, { store, renderPriority, renderTargetRef, layerEntryRef: layersEnabled ? layerEntryRef : void 0, children }), layersEnabled ? (0, import_jsx_runtime18.jsx)(XRLayerImplementation, { renderTargetRef, layerEntryRef, pixelWidth, pixelHeight, ref, ...props, src, geometry }) : (0, import_jsx_runtime18.jsx)(FallbackXRLayerImplementation, { renderTargetRef, ref, ...props, src, pixelWidth, pixelHeight, geometry })] });
}
var XRLayerImplementation = (0, import_react20.forwardRef)(({ src, shape, colorFormat, depthFormat, layout, mipLevels, renderOrder = 0, blendTextureSourceAlpha, centralAngle, centralHorizontalAngle, chromaticAberrationCorrection, lowerVerticalAngle, quality, upperVerticalAngle, invertStereo, pixelWidth, pixelHeight, renderTargetRef, layerEntryRef, ...props }, ref) => {
  const internalRef = (0, import_react20.useRef)(null);
  const renderer = useThree((state) => state.gl);
  const store = useXRStore();
  const layerProperties = {
    blendTextureSourceAlpha,
    centralAngle,
    centralHorizontalAngle,
    chromaticAberrationCorrection,
    lowerVerticalAngle,
    quality,
    upperVerticalAngle
  };
  const layerPropertiesRef = (0, import_react20.useRef)(layerProperties);
  layerPropertiesRef.current = layerProperties;
  const renderOrderRef = (0, import_react20.useRef)(renderOrder);
  renderOrderRef.current = renderOrder;
  (0, import_react20.useEffect)(() => {
    if (internalRef.current == null) {
      return;
    }
    const resolvedSrc = src ?? createXRLayerRenderTarget(pixelWidth, pixelHeight, renderTargetRef);
    const layer = createXRLayer(resolvedSrc, store.getState(), renderer.xr, internalRef.current, {
      colorFormat,
      depthFormat,
      invertStereo,
      layout,
      mipLevels,
      shape
    }, layerPropertiesRef.current);
    if (layer == null) {
      return;
    }
    const layerEntry = layerEntryRef.current = { layer, renderOrder: renderOrderRef.current };
    store.addLayerEntry(layerEntry);
    if (resolvedSrc instanceof HTMLVideoElement || resolvedSrc instanceof WebGLRenderTarget) {
      return () => {
        store.removeLayerEntry(layerEntry);
        layer.destroy();
      };
    }
    const cleanupXRImageLayer = setupXRImageLayer(renderer, store, layer, resolvedSrc);
    return () => {
      store.removeLayerEntry(layerEntry);
      cleanupXRImageLayer();
      layer.destroy();
    };
  }, [
    colorFormat,
    depthFormat,
    invertStereo,
    layerEntryRef,
    layout,
    mipLevels,
    pixelHeight,
    pixelWidth,
    renderTargetRef,
    renderer,
    shape,
    src,
    store
  ]);
  if (layerEntryRef.current != null) {
    layerEntryRef.current.renderOrder = renderOrder;
  }
  if (layerEntryRef.current != null) {
    updateXRLayerProperties(layerEntryRef.current.layer, layerPropertiesRef.current);
  }
  useFrame(() => {
    if (layerEntryRef.current == null || internalRef.current == null) {
      return;
    }
    updateXRLayerTransform(store.getState(), layerEntryRef.current.layer, layerPropertiesRef.current.centralAngle, internalRef.current);
  });
  (0, import_react20.useImperativeHandle)(ref, () => internalRef.current, []);
  return (0, import_jsx_runtime18.jsx)("mesh", { ...props, renderOrder: -Infinity, ref: internalRef, children: (0, import_jsx_runtime18.jsx)("meshBasicMaterial", { colorWrite: false }) });
});
var FallbackXRLayerImplementation = (0, import_react20.forwardRef)(({ src, renderTargetRef, renderOrder, pixelWidth, pixelHeight, ...props }, ref) => {
  const materialRef = (0, import_react20.useRef)(null);
  (0, import_react20.useEffect)(() => {
    if (materialRef.current == null) {
      return;
    }
    const resolvedSrc = src ?? createXRLayerRenderTarget(pixelWidth, pixelHeight, renderTargetRef);
    const texture = getXRLayerSrcTexture(resolvedSrc);
    materialRef.current.map = texture;
    materialRef.current.needsUpdate = true;
    return () => {
      if (resolvedSrc instanceof WebGLRenderTarget) {
        resolvedSrc.dispose();
        return;
      }
      texture.dispose();
    };
  }, [src, pixelWidth, pixelHeight, renderTargetRef]);
  return (0, import_jsx_runtime18.jsx)("mesh", { ref, ...props, children: (0, import_jsx_runtime18.jsx)("meshBasicMaterial", { ref: materialRef, toneMapped: false }) });
});
function createXRLayerRenderTarget(pixelWidth, pixelHeight, renderTargetRef) {
  return renderTargetRef.current = new WebGLRenderTarget(pixelWidth, pixelHeight, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    type: HalfFloatType,
    depthTexture: new DepthTexture(pixelWidth, pixelHeight)
  });
}
function useForwardEvents(store, ref, deps) {
  (0, import_react20.useEffect)(() => {
    const { current } = ref;
    if (current == null) {
      return;
    }
    let cleanup;
    const update = (state, prevState) => {
      if (state.camera === (prevState == null ? void 0 : prevState.camera) && state.scene === prevState.scene) {
        return;
      }
      cleanup == null ? void 0 : cleanup();
      cleanup = forwardObjectEvents(current, state.camera, state.scene);
    };
    update(store.getState());
    const unsubscribe = store.subscribe(update);
    return () => {
      unsubscribe();
      cleanup == null ? void 0 : cleanup();
    };
  }, [store, ref, ...deps]);
}
var privateKeys = [
  "set",
  "get",
  "setSize",
  "setFrameloop",
  "setDpr",
  "events",
  "invalidate",
  "advance",
  "size",
  "viewport"
];
function useLayerStore(width, height) {
  const previousRoot = useStore();
  const layerStore = (0, import_react20.useMemo)(() => {
    let previousState = previousRoot.getState();
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    camera.position.set(0, 0, 5);
    const pointer = new Vector2();
    let ownState = {
      events: { enabled: false, priority: 0 },
      size: { width: 1, height: 1, left: 0, top: 0 },
      camera,
      scene: new Scene(),
      raycaster: new Raycaster(),
      pointer,
      mouse: pointer,
      previousRoot
    };
    const store = create((innerSet, get) => {
      const merge = () => {
        const result = {};
        for (const key in previousState) {
          if (privateKeys.includes(key)) {
            continue;
          }
          result[key] = previousState[key];
        }
        return Object.assign(result, ownState, {
          events: { ...previousState.events, ...ownState.events },
          viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector3(), ownState.size))
        });
      };
      const update = () => innerSet(merge());
      return {
        ...previousState,
        // Set and get refer to this root-state
        set(newOwnState) {
          if (typeof newOwnState === "function") {
            newOwnState = newOwnState(get());
          }
          Object.assign(ownState, newOwnState);
          update();
        },
        setPreviousState(prevState) {
          previousState = prevState;
          update();
        },
        get,
        setEvents() {
        },
        ...merge()
      };
    });
    return Object.assign(store, {
      setState(state) {
        store.getState().set(state);
      }
    });
  }, [previousRoot]);
  (0, import_react20.useEffect)(() => previousRoot.subscribe(layerStore.getState().setPreviousState), [previousRoot, layerStore]);
  (0, import_react20.useEffect)(() => layerStore.setState({
    size: { width, height, top: 0, left: 0 },
    viewport: { ...previousRoot.getState().viewport, width, height, aspect: width / height }
  }), [width, height, layerStore, previousRoot]);
  return layerStore;
}
function ChildrenToRenderTarget({ renderPriority, children, layerEntryRef, renderTargetRef, store }) {
  (0, import_react20.useEffect)(() => {
    const update = (state, prevState) => {
      const { size, camera } = state;
      if (camera instanceof OrthographicCamera) {
        camera.left = size.width / -2;
        camera.right = size.width / 2;
        camera.top = size.height / 2;
        camera.bottom = size.height / -2;
      } else {
        camera.aspect = size.width / size.height;
      }
      if (size !== (prevState == null ? void 0 : prevState.size) || camera !== prevState.camera) {
        camera.updateProjectionMatrix();
        camera.updateMatrixWorld();
      }
    };
    update(store.getState());
    return store.subscribe(update);
  }, [store]);
  let oldAutoClear;
  let oldXrEnabled;
  let oldIsPresenting;
  let oldRenderTarget;
  useFrame((_state, _delta, frame) => {
    if (renderTargetRef.current == null || layerEntryRef != null && (layerEntryRef.current == null || frame == null)) {
      return;
    }
    const { gl, scene, camera } = store.getState();
    oldAutoClear = gl.autoClear;
    oldXrEnabled = gl.xr.enabled;
    oldIsPresenting = gl.xr.isPresenting;
    oldRenderTarget = gl.getRenderTarget();
    gl.autoClear = true;
    gl.xr.enabled = false;
    gl.xr.isPresenting = false;
    const renderTarget = renderTargetRef.current;
    setXRLayerRenderTarget(gl, renderTarget, layerEntryRef == null ? void 0 : layerEntryRef.current, frame);
    gl.render(scene, camera);
    gl.setRenderTarget(oldRenderTarget);
    gl.autoClear = oldAutoClear;
    gl.xr.enabled = oldXrEnabled;
    gl.xr.isPresenting = oldIsPresenting;
  }, renderPriority);
  return (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, { children: reconciler.createPortal((0, import_jsx_runtime18.jsx)(context.Provider, { value: store, children }), store, null) });
}

// node_modules/@react-three/xr/dist/deprecated/button.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);
var XRButton = (0, import_react21.forwardRef)(({ store, mode, onError, children, ...props }, ref) => {
  const session = useStore2(store, (xr) => xr.session);
  const supported = useSessionModeSupported(mode, onError);
  return (0, import_jsx_runtime19.jsx)("button", { ref, ...props, onClick: () => session != null ? session.end() : store.enterXR(mode).catch(onError), children: typeof children === "function" ? children(supported ? session != null ? "entered" : "exited" : "unsupported") : children });
});
var ARButton = (0, import_react21.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime19.jsx)(XRButton, { ref, mode: "immersive-ar", ...props });
});
var VRButton = (0, import_react21.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime19.jsx)(XRButton, { ref, mode: "immersive-vr", ...props });
});

// node_modules/@react-three/xr/dist/deprecated/hooks.js
var import_react22 = __toESM(require_react(), 1);
var eventTranslations = {
  onBlur: "pointerleave",
  onHover: "pointerenter",
  onMove: "pointermove",
  onSelect: {
    type: "click",
    filter: (e) => e.pointerType === "ray"
  },
  onSelectEnd: {
    type: "pointerup",
    filter: (e) => e.pointerType === "ray"
  },
  onSelectStart: {
    type: "pointerdown",
    filter: (e) => e.pointerType === "ray"
  },
  onSqueeze: {
    type: "click",
    filter: (e) => e.pointerType === "grab"
  },
  onSqueezeEnd: {
    type: "pointerup",
    filter: (e) => e.pointerType === "grab"
  },
  onSqueezeStart: {
    type: "pointerdown",
    filter: (e) => e.pointerType === "grab"
  }
};
function useInteraction(ref, type, handler) {
  const handlerRef = (0, import_react22.useRef)(handler);
  handlerRef.current = handler;
  (0, import_react22.useEffect)(() => {
    const { current } = ref;
    if (current == null) {
      return;
    }
    const translation = eventTranslations[type];
    const fn = typeof translation === "string" ? (event) => {
      var _a;
      return (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, { intersection: event, intersections: [event], target: event.pointerState });
    } : (event) => {
      var _a;
      if (event instanceof PointerEvent && !translation.filter(event)) {
        return;
      }
      (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, { intersection: event, intersections: [event], target: event.pointerState });
    };
    const eventName = typeof translation === "string" ? translation : translation.type;
    current.addEventListener(eventName, fn);
    return () => current.removeEventListener(eventName, fn);
  }, [ref, type]);
}
function useXREvent(type, handler, { handedness } = {}) {
  const session = useXR((xr) => xr.session);
  const handlerRef = (0, import_react22.useRef)(handler);
  handlerRef.current = handler;
  (0, import_react22.useEffect)(() => {
    if (session == null) {
      return;
    }
    const fn = (e) => {
      var _a;
      (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, {
        type: e.type,
        data: e.inputSource
      });
    };
    session.addEventListener(type, fn);
    return session.removeEventListener(type, fn);
  }, [session, handedness, type]);
}
function useXRTransientPointerState(handedness) {
  return handedness == null ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceStateContext("transientPointer")
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceState("transientPointer", handedness)
  );
}
function useXRGazeState() {
  return useXRInputSourceStateContext("gaze");
}
function useXRScreenInputState() {
  return useXRInputSourceStateContext("screenInput");
}
function useXRHandState(handedness) {
  return handedness == null ? useXRInputSourceStateContext("hand") : useXRInputSourceState("hand", handedness);
}
function useXRControllerState(handedness) {
  return handedness == null ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceStateContext("controller")
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceState("controller", handedness)
  );
}
var useXRReferenceSpace = useXRSpace;

// node_modules/@react-three/xr/dist/deprecated/interactive.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var Interactive = (0, import_react23.forwardRef)(({ onHover, onBlur, onSelectStart, onSelectEnd, onSelect, onSqueezeStart, onSqueezeEnd, onSqueeze, onMove, children }, passedRef) => {
  const ref = (0, import_react23.useRef)(null);
  (0, import_react23.useImperativeHandle)(passedRef, () => ref.current);
  useInteraction(ref, "onHover", onHover);
  useInteraction(ref, "onBlur", onBlur);
  useInteraction(ref, "onSelectStart", onSelectStart);
  useInteraction(ref, "onSelectEnd", onSelectEnd);
  useInteraction(ref, "onSelect", onSelect);
  useInteraction(ref, "onSqueezeStart", onSqueezeStart);
  useInteraction(ref, "onSqueezeEnd", onSqueezeEnd);
  useInteraction(ref, "onSqueeze", onSqueeze);
  useInteraction(ref, "onMove", onMove);
  return (0, import_jsx_runtime20.jsx)("group", { ref, children });
});

// node_modules/@react-three/xr/dist/deprecated/ray-grab.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react24 = __toESM(require_react(), 1);
var RayGrab = (0, import_react24.forwardRef)(function RayGrab2({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {
  const grabbingController = (0, import_react24.useRef)();
  const groupRef = (0, import_react24.useRef)(null);
  const previousTransform = (0, import_react24.useMemo)(() => new Matrix4(), []);
  (0, import_react24.useImperativeHandle)(forwardedRef, () => groupRef.current);
  useFrame(() => {
    const controller = grabbingController.current;
    const group = groupRef.current;
    if (!group || !controller)
      return;
    group.applyMatrix4(previousTransform);
    group.applyMatrix4(controller.matrixWorld);
    group.updateMatrixWorld();
    previousTransform.copy(controller.matrixWorld).invert();
  });
  return (0, import_jsx_runtime21.jsx)(Interactive, { ref: groupRef, onSelectStart: (e) => {
    if (isXRInputSourceState(e.target) && (e.target.type === "controller" || e.target.type === "hand") && e.target.object != null) {
      grabbingController.current = e.target.object;
      previousTransform.copy(e.target.object.matrixWorld).invert();
      onSelectStart == null ? void 0 : onSelectStart(e);
    }
  }, onSelectEnd: (e) => {
    if (e.target.controller === grabbingController.current) {
      grabbingController.current = void 0;
    }
    onSelectEnd == null ? void 0 : onSelectEnd(e);
  }, ...rest, children });
});
export {
  ARButton,
  CombinedPointer2 as CombinedPointer,
  DefaultXRController,
  DefaultXRControllerGrabPointer,
  DefaultXRGaze,
  DefaultXRHand,
  DefaultXRHandGrabPointer,
  DefaultXRHandTouchPointer,
  DefaultXRInputSourceRayPointer,
  DefaultXRInputSourceTeleportPointer,
  DefaultXRScreenInput,
  DefaultXRTransientPointer,
  FallbackXRLayerImplementation,
  IfFacingCamera,
  IfInSessionMode,
  IfSessionModeSupported,
  IfSessionVisible,
  Interactive,
  PointerCursorModel2 as PointerCursorModel,
  PointerRayModel2 as PointerRayModel,
  RayGrab,
  ShowIfFacingCamera,
  ShowIfInSessionMode,
  ShowIfSessionModeSupported,
  ShowIfSessionVisible,
  TeleportPointerRayModel2 as TeleportPointerRayModel,
  TeleportTarget,
  VRButton,
  XR,
  XRButton,
  XRControllerComponent,
  XRControllerModel2 as XRControllerModel,
  XRDomOverlay,
  XRHandJoint,
  XRHandModel2 as XRHandModel,
  XRHitTest,
  XRLayer,
  XRLayerImplementation,
  XRMeshModel,
  XROrigin,
  XRPlaneModel,
  XRSpace3 as XRSpace,
  createXRHitTestSource,
  createXRStore2 as createXRStore,
  defaultGrabPointerOpacity,
  defaultRayPointerOpacity,
  defaultTouchPointerOpacity,
  isXRInputSourceState,
  privateKeys,
  requestXRAnchor,
  requestXRHitTest,
  useApplyXRSpaceMatrix,
  useGetXRSpaceMatrix,
  useGrabPointer,
  useHover,
  useInitRoomCapture,
  useInteraction,
  useLayerStore,
  usePointerXRInputSourceEvents,
  useRayPointer,
  useRequestXRAnchor,
  useSessionFeatureEnabled,
  useSessionModeSupported,
  useTouchPointer,
  useXR,
  useXRAnchor,
  useXRControllerButtonEvent,
  useXRControllerState,
  useXREvent,
  useXRGazeState,
  useXRHandState,
  useXRHitTest,
  useXRHitTestSource,
  useXRInputSourceEvent,
  useXRInputSourceState,
  useXRInputSourceStateContext,
  useXRInputSourceStates,
  useXRMeshGeometry,
  useXRMeshes,
  useXRPlaneGeometry,
  useXRPlanes,
  useXRReferenceSpace,
  useXRRequestHitTest,
  useXRScreenInputState,
  useXRSessionVisibilityState,
  useXRSpace,
  useXRStore,
  useXRTransientPointerState
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@react-three_xr.js.map
