{
  "version": 3,
  "sources": ["../../@react-three/xr/dist/space.js", "../../three/src/math/MathUtils.js", "../../@pmndrs/xr/dist/controller/gamepad.js", "../../@pmndrs/xr/dist/hand/pose.js", "../../three/examples/jsm/utils/SkeletonUtils.js", "../../@pmndrs/xr/dist/hand/model.js", "../../@pmndrs/xr/dist/hand/state.js", "../../@pmndrs/xr/dist/hand/visual.js", "../../@pmndrs/xr/dist/input.js", "../../@pmndrs/xr/dist/visible.js", "../../@pmndrs/xr/dist/pointer/cursor.js", "../../@pmndrs/xr/dist/pointer/ray.js", "../../@pmndrs/xr/dist/pointer/event.js", "../../@pmndrs/xr/dist/pointer/default.js", "../../@pmndrs/xr/dist/space.js", "../../@pmndrs/xr/dist/init.js", "../../@pmndrs/xr/dist/store.js", "../../@pmndrs/xr/dist/vanilla/pointer.js", "../../@pmndrs/xr/dist/controller/model.js", "../../@pmndrs/xr/dist/controller/visual.js", "../../@pmndrs/pointer-events/dist/utils.js", "../../@pmndrs/pointer-events/dist/event.js", "../../@pmndrs/pointer-events/dist/pointer.js", "../../@pmndrs/pointer-events/dist/intersections/utils.js", "../../@pmndrs/pointer-events/dist/intersections/lines.js", "../../@pmndrs/pointer-events/dist/intersections/ray.js", "../../@pmndrs/pointer-events/dist/intersections/sphere.js", "../../@pmndrs/pointer-events/dist/pointer/grab.js", "../../@pmndrs/pointer-events/dist/pointer/ray.js", "../../@pmndrs/pointer-events/dist/pointer/touch.js", "../../@pmndrs/pointer-events/dist/pointer/index.js", "../../@pmndrs/pointer-events/dist/forward.js", "../../@pmndrs/pointer-events/dist/combine.js", "../../@pmndrs/xr/dist/mesh.js", "../../@pmndrs/xr/dist/plane.js", "../../@pmndrs/xr/dist/layer.js", "../../@pmndrs/xr/dist/misc.js", "../../@pmndrs/xr/dist/teleport.js", "../../@pmndrs/xr/dist/hit-test.js", "../../@pmndrs/xr/dist/anchor.js", "../../@pmndrs/xr/dist/index.js", "../../@pmndrs/xr/dist/controller/utils.js", "../../@pmndrs/xr/dist/controller/layout.js", "../../@pmndrs/xr/dist/controller/state.js", "../../@react-three/xr/dist/contexts.js", "../../@react-three/xr/dist/xr.js", "../../@react-three/xr/dist/elements.js", "../../@react-three/xr/dist/utils.js", "../../@react-three/xr/dist/hooks.js", "../../@react-three/xr/dist/default.js", "../../@react-three/xr/dist/controller.js", "../../@react-three/xr/dist/input.js", "../../@react-three/xr/dist/hand.js", "../../@react-three/xr/dist/pointer.js", "../../@react-three/xr/dist/teleport.js", "../../zustand/esm/shallow.mjs", "../../@react-three/xr/dist/mesh.js", "../../@react-three/xr/dist/plane.js", "../../@react-three/xr/dist/guard/facing-camera.js", "../../@react-three/xr/dist/guard/session-mode.js", "../../@react-three/xr/dist/guard/session-supported.js", "../../@react-three/xr/dist/guard/focus.js", "../../@react-three/xr/dist/origin.js", "../../@react-three/xr/dist/hit-test.js", "../../@react-three/xr/dist/anchor.js", "../../@react-three/xr/dist/dom-overlay.js", "../../@react-three/xr/dist/layer.js", "../../@react-three/xr/dist/deprecated/button.js", "../../@react-three/xr/dist/deprecated/hooks.js", "../../@react-three/xr/dist/deprecated/interactive.js", "../../@react-three/xr/dist/deprecated/ray-grab.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createGetXRSpaceMatrix } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef, useState, } from 'react';\nimport { xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\n/**\n * component that puts its children at the provided space (or reference space type)\n */\nexport const XRSpace = forwardRef(({ space, children }, ref) => {\n    const internalRef = useRef(null);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const resolvedSpace = typeof space === 'string' ? useXRSpace(space) : space;\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useApplyXRSpaceMatrix(internalRef, resolvedSpace, (_state, _delta, frame) => {\n        if (internalRef.current == null) {\n            return;\n        }\n        internalRef.current.visible = frame != null;\n    });\n    if (resolvedSpace == null) {\n        return null;\n    }\n    return (_jsx(\"group\", { xrSpace: resolvedSpace, visible: false, matrixAutoUpdate: false, ref: internalRef, children: _jsx(xrSpaceContext.Provider, { value: resolvedSpace, children: children }) }));\n});\nexport function useXRSpace(type) {\n    if (type == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const context = useContext(xrSpaceContext);\n        if (context == null) {\n            throw new Error(`XR objects must be placed inside the XROrigin`);\n        }\n        return context;\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const [referenceSpace, setReferenceSpace] = useState(undefined);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const session = useXR((xr) => xr.session);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        let aborted = false;\n        session.requestReferenceSpace(type).then((space) => {\n            if (aborted) {\n                return;\n            }\n            setReferenceSpace(space);\n        });\n        return () => void (aborted = true);\n    }, [session, type]);\n    return referenceSpace;\n}\n/**\n * hook that returns a function to compute a matrix that contains the transformation of the provided xr space\n */\nexport function useGetXRSpaceMatrix(space) {\n    const localReferenceSpace = useContext(xrSpaceContext);\n    const referenceSpace = useXR((xr) => localReferenceSpace ?? xr.originReferenceSpace);\n    return useMemo(() => (space == null || referenceSpace == null ? undefined : createGetXRSpaceMatrix(space, referenceSpace)), [space, referenceSpace]);\n}\n/**\n * hook that applies the transformation of the provided xr space to the provided object reference\n * @param onFrame optional callback that gets executed after the matrix of the reference object was updated\n * @requires that matrixAutoUpdate is disabled for the referenced object\n */\nexport function useApplyXRSpaceMatrix(ref, space, onFrame) {\n    const getXRSpaceMatrix = useGetXRSpaceMatrix(space);\n    useFrame((state, delta, frame) => {\n        if (ref.current == null || getXRSpaceMatrix == null) {\n            return;\n        }\n        getXRSpaceMatrix(ref.current.matrix, frame);\n        onFrame?.(state, delta, frame);\n        //makes sure we update the frame before using the space transformation anywhere\n    }, -100);\n}\n", "const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n", "import { clamp } from 'three/src/math/MathUtils.js';\nconst ButtonTouchThreshold = 0.05;\nconst AxisTouchThreshold = 0.1;\nexport function updateXRControllerGamepadState(target, inputSource, layout) {\n    const gamepad = inputSource.gamepad;\n    if (gamepad == null) {\n        return;\n    }\n    const layoutComponents = layout.components;\n    for (const key in layoutComponents) {\n        let component = target[key];\n        if (component == null) {\n            target[key] = component = {};\n        }\n        const { gamepadIndices } = layoutComponents[key];\n        let pressed = false;\n        let touched = false;\n        if (gamepadIndices.button != null && gamepadIndices.button < gamepad.buttons.length) {\n            const gamepadButton = gamepad.buttons[gamepadIndices.button];\n            component.button = clamp(gamepadButton.value, 0, 1);\n            pressed ||= gamepadButton.pressed || component.button === 1;\n            touched ||= gamepadButton.touched || component.button > ButtonTouchThreshold;\n        }\n        if (gamepadIndices.xAxis != null && gamepadIndices.xAxis < gamepad.axes.length) {\n            component.xAxis = clamp(gamepad.axes[gamepadIndices.xAxis], -1, 1);\n            touched ||= Math.abs(component.xAxis) > AxisTouchThreshold;\n        }\n        if (gamepadIndices.yAxis != null && gamepadIndices.yAxis < gamepad.axes.length) {\n            component.yAxis = clamp(gamepad.axes[gamepadIndices.yAxis], -1, 1);\n            touched ||= Math.abs(component.yAxis) > AxisTouchThreshold;\n        }\n        component.state = pressed ? 'pressed' : touched ? 'touched' : 'default';\n    }\n}\n", "import { Matrix4, Quaternion } from 'three';\nexport function createHandPoseState(hand) {\n    return {\n        //distances: {},\n        //name: undefined,\n        data: new Float32Array(hand.size * 16),\n    };\n}\nexport function updateXRHandPoseState(state, frame, hand, manager, handedness) {\n    const referenceSpace = manager.getReferenceSpace();\n    /*for (const key in poseUrls) {\n      state.distances[key] = Infinity\n    }*/\n    if (referenceSpace == null ||\n        frame == null ||\n        frame.session.visibilityState === 'visible-blurred' ||\n        frame.session.visibilityState === 'hidden') {\n        //state.name = undefined\n        return;\n    }\n    const validPose = updateXRHandPoseData(frame, referenceSpace, hand, state.data);\n    if (!validPose) {\n        //state.name = undefined\n        return;\n    }\n    let closestPoseName;\n    let closestPoseDistance;\n    /*for (const key in poseUrls) {\n      const pose = loadXRHandPose(poseUrls[key])\n      if (pose == null) {\n        continue\n      }\n      const distance = getXRHandPoseDistance(state.data, pose, handedness === 'left')\n  \n      if (closestPoseDistance != null && distance >= closestPoseDistance) {\n        continue\n      }\n  \n      state.distances[key] = distance\n      closestPoseDistance = distance\n      closestPoseName = key\n    }\n  \n    state.name = closestPoseName*/\n}\nconst invertedWirstHelper = new Matrix4();\nconst matrixHelper = new Matrix4();\nfunction updateXRHandPoseData(frame, referenceSpace, hand, handPoseData) {\n    const validPose = frame.fillPoses(hand.values(), referenceSpace, handPoseData);\n    if (!validPose) {\n        return false;\n    }\n    //calculate bone poses in relation to the wrist\n    // The first item in hand pose information is the wrist\n    invertedWirstHelper.fromArray(handPoseData, 0);\n    invertedWirstHelper.invert();\n    for (let i = 0; i < handPoseData.length; i += 16) {\n        matrixHelper.fromArray(handPoseData, i);\n        matrixHelper.premultiply(invertedWirstHelper);\n        matrixHelper.toArray(handPoseData, i);\n    }\n    return true;\n}\nconst tempMat2 = new Matrix4();\nconst tempMat1 = new Matrix4();\nconst tempQuat2 = new Quaternion();\nconst tempQuat1 = new Quaternion();\nfunction getXRHandPoseDistance(hpData1, phData2, mirrorHP2) {\n    const length = Math.min(hpData1.length, phData2.length);\n    if (length === 0) {\n        return Infinity;\n    }\n    let dist = 0;\n    for (let i = 0; i < length; i += 16) {\n        tempQuat1.setFromRotationMatrix(tempMat1.fromArray(hpData1, i));\n        tempQuat2.setFromRotationMatrix(tempMat2.fromArray(phData2, i));\n        if (mirrorHP2) {\n            mirrorQuaterionOnXAxis(tempQuat2);\n        }\n        dist += tempQuat2.angleTo(tempQuat1);\n    }\n    return dist / (length * 16);\n}\nexport function downloadHandPoseData(handed, handPoseData) {\n    if (handed === 'left') {\n        const length = handPoseData.length;\n        const mirroredHandPoseData = new Float32Array(length);\n        for (let i = 0; i < length; i += 16) {\n            tempMat2.fromArray(handPoseData, i);\n            tempQuat2.setFromRotationMatrix(tempMat2);\n            mirrorQuaterionOnXAxis(tempQuat2);\n            // Copies the rotation component of the supplied matrix m into this matrix rotation component.\n            tempMat2.makeRotationFromQuaternion(tempQuat2);\n            tempMat2.toArray(mirroredHandPoseData, i);\n        }\n        handPoseData = mirroredHandPoseData;\n    }\n    const a = window.document.createElement('a');\n    a.href = window.URL.createObjectURL(new Blob([handPoseData], { type: 'application/octet-stream' }));\n    a.download = 'untitled.handpose';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n}\n//null means that we are currently loading the pose\nconst poseStorage = new Map();\nfunction loadXRHandPose(path) {\n    const href = new URL(path, window.location.href).href;\n    const pose = poseStorage.get(href);\n    if (pose != null) {\n        return pose;\n    }\n    if (pose === undefined) {\n        //loading process was never started\n        poseStorage.set(href, null);\n        //start loading process and save to poseStorage\n        fetch(href)\n            .then((response) => response.arrayBuffer())\n            .then((buffer) => poseStorage.set(href, new Float32Array(buffer)))\n            .catch(console.error);\n    }\n    return undefined;\n}\nfunction mirrorQuaterionOnXAxis(quaternion) {\n    quaternion.x = -quaternion.x;\n    quaternion.w = -quaternion.w;\n}\n", "import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( i === numFrames - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n", "import { Material, Mesh } from 'three';\nimport { DefaultAssetBasePath, DefaultGltfLoader } from '../index.js';\nimport { clone as cloneSkeleton } from 'three/examples/jsm/utils/SkeletonUtils.js';\n//from https://github.com/pmndrs/three-stdlib/blob/main/src/webxr/XRHandMeshModel.ts\nconst DefaultDefaultXRHandProfileId = 'generic-hand';\nexport function getXRHandAssetPath(handedness, options) {\n    const baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;\n    const defaultProfileId = options?.defaultXRHandProfileId ?? DefaultDefaultXRHandProfileId;\n    return new URL(`${defaultProfileId}/${handedness}.glb`, baseAssetPath).href;\n}\nexport async function loadXRHandModel(assetPath, loader = DefaultGltfLoader) {\n    const gltf = await loader.loadAsync(assetPath);\n    return cloneXRHandGltf(gltf);\n}\nexport function cloneXRHandGltf({ scene }) {\n    const result = cloneSkeleton(scene);\n    const mesh = result.getObjectByProperty('type', 'SkinnedMesh');\n    if (mesh == null) {\n        throw new Error(`missing SkinnedMesh in loaded XRHand model`);\n    }\n    mesh.frustumCulled = false;\n    return result;\n}\nexport function configureXRHandModel(model, options) {\n    model.renderOrder = options?.renderOrder ?? 0;\n    model.traverse((child) => {\n        if (child instanceof Mesh && child.material instanceof Material) {\n            child.material.colorWrite = options?.colorWrite ?? true;\n        }\n    });\n}\n", "import { createHandPoseState, updateXRHandPoseState } from './pose.js';\nimport { getXRHandAssetPath } from './model.js';\nexport function isXRHandInputSource(inputSource) {\n    return inputSource.hand != null;\n}\nexport function createXRHandState(id, inputSource, options, events, isPrimary) {\n    return {\n        id,\n        isPrimary,\n        type: 'hand',\n        inputSource: inputSource,\n        pose: createHandPoseState(inputSource.hand),\n        assetPath: getXRHandAssetPath(inputSource.handedness, options),\n        events,\n    };\n}\nexport function updateXRHandState({ inputSource, pose }, frame, manager) {\n    updateXRHandPoseState(pose, frame, inputSource.hand, manager, inputSource.handedness);\n}\n", "const joints = [\n    'wrist',\n    'thumb-metacarpal',\n    'thumb-phalanx-proximal',\n    'thumb-phalanx-distal',\n    'thumb-tip',\n    'index-finger-metacarpal',\n    'index-finger-phalanx-proximal',\n    'index-finger-phalanx-intermediate',\n    'index-finger-phalanx-distal',\n    'index-finger-tip',\n    'middle-finger-metacarpal',\n    'middle-finger-phalanx-proximal',\n    'middle-finger-phalanx-intermediate',\n    'middle-finger-phalanx-distal',\n    'middle-finger-tip',\n    'ring-finger-metacarpal',\n    'ring-finger-phalanx-proximal',\n    'ring-finger-phalanx-intermediate',\n    'ring-finger-phalanx-distal',\n    'ring-finger-tip',\n    'pinky-finger-metacarpal',\n    'pinky-finger-phalanx-proximal',\n    'pinky-finger-phalanx-intermediate',\n    'pinky-finger-phalanx-distal',\n    'pinky-finger-tip',\n];\nexport function createUpdateXRHandVisuals(hand, handModel, referenceSpace) {\n    const buffer = new Float32Array(hand.size * 16);\n    const jointObjects = joints.map((joint) => {\n        const jointObject = handModel.getObjectByName(joint);\n        if (jointObject == null) {\n            throw new Error(`missing joint \"${joint}\" in hand model`);\n        }\n        jointObject.matrixAutoUpdate = false;\n        return jointObject;\n    });\n    return (frame) => {\n        const resolvedReferenceSpace = typeof referenceSpace === 'function' ? referenceSpace() : referenceSpace;\n        if (frame == null || resolvedReferenceSpace == null) {\n            return;\n        }\n        frame.fillPoses(hand.values(), resolvedReferenceSpace, buffer);\n        const length = jointObjects.length;\n        for (let i = 0; i < length; i++) {\n            jointObjects[i].matrix.fromArray(buffer, i * 16);\n        }\n    };\n}\n", "import { XRControllerLayoutLoader, createXRControllerState, } from './controller/index.js';\nimport { createXRHandState, } from './hand/index.js';\nexport function isXRInputSourceState(val) {\n    return val != null && typeof val === 'object' && 'inputSource' in val;\n}\nfunction setupEvents(session, events) {\n    const listener = (e) => events.push(e);\n    session.addEventListener('selectstart', listener);\n    session.addEventListener('selectend', listener);\n    session.addEventListener('select', listener);\n    session.addEventListener('squeeze', listener);\n    session.addEventListener('squeezestart', listener);\n    session.addEventListener('squeezeend', listener);\n    return () => {\n        session.removeEventListener('selectstart', listener);\n        session.removeEventListener('selectend', listener);\n        session.removeEventListener('select', listener);\n        session.removeEventListener('squeeze', listener);\n        session.removeEventListener('squeezestart', listener);\n        session.removeEventListener('squeezeend', listener);\n    };\n}\nlet idCounter = 0;\nexport function createSyncXRInputSourceStates(addController, options) {\n    const cleanupMap = new Map();\n    const controllerLayoutLoader = new XRControllerLayoutLoader(options);\n    const idMap = new Map();\n    return (session, current, changes) => {\n        if (changes === 'remove-all') {\n            for (const cleanup of cleanupMap.values()) {\n                cleanup();\n            }\n            return current;\n        }\n        const target = [...current];\n        for (const { added, isPrimary, removed } of changes) {\n            if (removed != null) {\n                for (const inputSource of removed) {\n                    const index = target.findIndex(({ inputSource: is, isPrimary: ip }) => ip === isPrimary && is === inputSource);\n                    if (index === -1) {\n                        continue;\n                    }\n                    target.splice(index, 1);\n                    cleanupMap.get(inputSource)?.();\n                    cleanupMap.delete(inputSource);\n                }\n            }\n            if (added == null) {\n                continue;\n            }\n            for (const inputSource of added) {\n                const events = [];\n                let cleanup = setupEvents(session, events);\n                const key = `${inputSource.handedness}-${inputSource.hand ? 'hand' : 'nohand'}-${inputSource.targetRayMode}-${inputSource.profiles.join(',')}`;\n                let id;\n                if ((id = idMap.get(key)) == null) {\n                    idMap.set(key, (id = `${idCounter++}`));\n                }\n                if (inputSource.hand != null) {\n                    target.push(createXRHandState(id, inputSource, options, events, isPrimary));\n                }\n                else {\n                    switch (inputSource.targetRayMode) {\n                        case 'gaze':\n                            target.push({ id, isPrimary, type: 'gaze', inputSource, events });\n                            break;\n                        case 'screen':\n                            target.push({ id, isPrimary, type: 'screenInput', inputSource, events });\n                            break;\n                        case 'transient-pointer':\n                            target.push({ id, isPrimary, type: 'transientPointer', inputSource, events });\n                            break;\n                        case 'tracked-pointer':\n                            let aborted = false;\n                            const cleanupEvents = cleanup;\n                            cleanup = () => {\n                                cleanupEvents();\n                                aborted = true;\n                            };\n                            const stateResult = createXRControllerState(id, inputSource, controllerLayoutLoader, events, isPrimary);\n                            if (stateResult instanceof Promise) {\n                                stateResult.then((state) => !aborted && addController(state)).catch(console.error);\n                            }\n                            else {\n                                target.push(stateResult);\n                            }\n                            break;\n                    }\n                }\n                cleanupMap.set(inputSource, cleanup);\n            }\n        }\n        return target;\n    };\n}\n", "export function setupSyncIsVisible(store, setIsVisible) {\n    const update = (state, prevState) => {\n        if (prevState != null && state.visibilityState === prevState.visibilityState) {\n            return;\n        }\n        setIsVisible(state.visibilityState === 'visible');\n    };\n    update(store.getState());\n    return store.subscribe(update);\n}\n", "import { MeshBasicMaterial, Quaternion, Vector3, } from 'three';\nexport class PointerCursorMaterial extends MeshBasicMaterial {\n    constructor() {\n        super({ transparent: true, toneMapped: false, depthWrite: false });\n    }\n    onBeforeCompile(parameters, renderer) {\n        super.onBeforeCompile(parameters, renderer);\n        parameters.vertexShader = `varying vec2 vLocalPosition;\\n` + parameters.vertexShader;\n        parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>\n        vLocalPosition = position.xy * 2.0;`);\n        parameters.fragmentShader = `varying vec2 vLocalPosition;\\n` + parameters.fragmentShader;\n        parameters.fragmentShader = parameters.fragmentShader.replace('#include <color_fragment>', `#include <color_fragment>\n          float value = max(0.0, 1.0 - sqrt(dot(vLocalPosition, vLocalPosition)));\n          diffuseColor.a = diffuseColor.a * value * value;`);\n    }\n}\nconst ZAxis = new Vector3(0, 0, 1);\nconst quaternionHelper = new Quaternion();\nconst offsetHelper = new Vector3();\nexport function updatePointerCursorModel(mesh, material, pointer, options) {\n    const intersection = pointer.getIntersection();\n    if (intersection == null || !pointer.getEnabled()) {\n        mesh.visible = false;\n        return;\n    }\n    mesh.visible = true;\n    const color = typeof options.color === 'function' ? options.color(pointer) : options.color;\n    if (Array.isArray(color)) {\n        material.color.set(...color);\n    }\n    else {\n        material.color.set(color ?? 'white');\n    }\n    material.opacity = typeof options.opacity === 'function' ? options.opacity(pointer) : (options.opacity ?? 0.4);\n    mesh.position.copy(intersection.pointOnFace);\n    mesh.scale.setScalar(options.size ?? 0.1);\n    if (intersection.normal != null) {\n        quaternionHelper.setFromUnitVectors(ZAxis, intersection.normal);\n        intersection.object.getWorldQuaternion(mesh.quaternion);\n        mesh.quaternion.multiply(quaternionHelper);\n        offsetHelper.set(0, 0, options.cursorOffset ?? 0.01);\n        offsetHelper.applyQuaternion(mesh.quaternion);\n        mesh.position.add(offsetHelper);\n    }\n    mesh.updateMatrix();\n}\n", "import { MeshBasicMaterial, } from 'three';\nexport class PointerRayMaterial extends MeshBasicMaterial {\n    constructor() {\n        super({ transparent: true, toneMapped: false });\n    }\n    onBeforeCompile(parameters, renderer) {\n        super.onBeforeCompile(parameters, renderer);\n        parameters.vertexShader = `varying float vFade;\\n` + parameters.vertexShader;\n        parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>\n            vFade = position.z + 0.5;`);\n        parameters.fragmentShader = `varying float vFade;\\n` + parameters.fragmentShader;\n        parameters.fragmentShader = parameters.fragmentShader.replace('#include <color_fragment>', `#include <color_fragment>\n              diffuseColor.a *= vFade;`);\n    }\n}\nexport function updatePointerRayModel(mesh, material, pointer, options) {\n    if (!pointer.getEnabled()) {\n        mesh.visible = false;\n        return;\n    }\n    mesh.visible = true;\n    const intersection = pointer.getIntersection();\n    const color = typeof options.color === 'function' ? options.color(pointer) : options.color;\n    if (Array.isArray(color)) {\n        material.color.set(...color);\n    }\n    else {\n        material.color.set(color ?? 'white');\n    }\n    material.opacity = typeof options.opacity === 'function' ? options.opacity(pointer) : (options.opacity ?? 0.4);\n    let length = options.maxLength ?? 1;\n    if (intersection != null) {\n        length = Math.min(length, intersection.distance);\n    }\n    mesh.position.z = -length / 2;\n    const size = options.size ?? 0.005;\n    mesh.scale.set(size, size, length);\n    mesh.updateMatrix();\n}\n", "export function bindXRInputSourceEvent(session, inputSource, event, fn) {\n    const filterFn = (event) => {\n        if (inputSource != 'all' && event.inputSource != inputSource) {\n            return;\n        }\n        fn(event);\n    };\n    session.addEventListener(event, filterFn);\n    return () => session.removeEventListener(event, filterFn);\n}\nexport function bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents, options = {}) {\n    const downListener = (e) => {\n        if (e.inputSource === inputSource) {\n            pointer.down(Object.assign(e, { button: options.button ?? 0 }));\n        }\n    };\n    const upListener = (e) => {\n        if (e.inputSource === inputSource) {\n            pointer.up(Object.assign(e, { button: options.button ?? 0 }));\n        }\n    };\n    const downEventName = `${event}start`;\n    const upEventName = `${event}end`;\n    //missing events are required for transient pointers when the input source is registered asynchrounously\n    //so that events directly emitted on initialization are still processed once the input source is created\n    const length = missingEvents.length;\n    for (let i = 0; i < length; i++) {\n        const event = missingEvents[i];\n        switch (event.type) {\n            case downEventName:\n                downListener(event);\n                break;\n            case upEventName:\n                upListener(event);\n                break;\n        }\n    }\n    session.addEventListener(downEventName, downListener);\n    session.addEventListener(upEventName, upListener);\n    return () => {\n        session.removeEventListener(downEventName, downListener);\n        session.removeEventListener(upEventName, upListener);\n    };\n}\n", "export function defaultGrabPointerOpacity(pointer) {\n    if (pointer.getButtonsDown().size > 0) {\n        return 0.6;\n    }\n    return map(pointer.getIntersection()?.distance ?? Infinity, 0.07, 0, 0.2, 0.4);\n}\nexport function defaultRayPointerOpacity(pointer) {\n    if (pointer.getButtonsDown().size > 0) {\n        return 0.6;\n    }\n    return 0.4;\n}\nexport function defaultTouchPointerOpacity(pointer) {\n    return map(pointer.getIntersection()?.distance ?? Infinity, 0.1, 0.03, 0.2, 0.6);\n}\nfunction map(value, fromMin, fromMax, toMin, toMax) {\n    return toMin + Math.max(0, Math.min(1, (value - fromMin) / (fromMax - fromMin))) * (toMax - toMin);\n}\n", "export function createGetXRSpaceMatrix(space, referenceSpace) {\n    return (target, frame) => {\n        if (space === referenceSpace) {\n            target.identity();\n            return true;\n        }\n        const resolvedReferenceSpace = typeof referenceSpace === 'function' ? referenceSpace() : referenceSpace;\n        if (resolvedReferenceSpace == null) {\n            return false;\n        }\n        const pose = frame?.getPose(space, resolvedReferenceSpace);\n        if (pose == null) {\n            return false;\n        }\n        target.fromArray(pose.transform.matrix);\n        return true;\n    };\n}\nexport function computeOriginReferenceSpaceOffset(object, origin, target) {\n    if (origin == null) {\n        target.copy(object.matrixWorld);\n        return;\n    }\n    target.copy(origin.matrixWorld).invert().multiply(object.matrixWorld);\n}\nexport function getSpaceFromAncestors(object, origin, originReferenceSpace, targetOffsetMatrix) {\n    targetOffsetMatrix?.copy(object.matrix);\n    const result = getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);\n    if (result != null) {\n        return result;\n    }\n    if (targetOffsetMatrix != null) {\n        computeOriginReferenceSpaceOffset(object, origin, targetOffsetMatrix);\n    }\n    return originReferenceSpace;\n}\nfunction getXRSpaceFromAncestorsRec(object, targetOffsetMatrix) {\n    if (object == null) {\n        return undefined;\n    }\n    if (object.xrSpace != null) {\n        return object.xrSpace;\n    }\n    targetOffsetMatrix?.premultiply(object.matrix);\n    return getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);\n}\n", "export function buildXRSessionInit(mode, domOverlayRoot, { anchors = true, handTracking = true, layers = true, meshDetection = true, planeDetection = true, customSessionInit, depthSensing = false, hitTest = true, domOverlay = true, bounded, } = {}) {\n    if (customSessionInit != null) {\n        return customSessionInit;\n    }\n    const requiredFeatures = bounded == null ? ['local-floor'] : bounded ? ['bounded-floor'] : ['unbounded', 'local-floor'];\n    const optionalFeatures = [];\n    if (domOverlay instanceof Element) {\n        domOverlay = true;\n    }\n    addXRSessionFeature(anchors, 'anchors', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(handTracking, 'hand-tracking', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(layers, 'layers', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(meshDetection, 'mesh-detection', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(planeDetection, 'plane-detection', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(depthSensing, 'depth-sensing', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(domOverlay, 'dom-overlay', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(hitTest, 'hit-test', requiredFeatures, optionalFeatures);\n    const init = {\n        requiredFeatures,\n        optionalFeatures,\n        domOverlay: { root: domOverlayRoot },\n    };\n    //TODO: replace with call to isSupportedFeature (unbounded, ...)\n    if (depthSensing) {\n        Object.assign(init, { depthSensing: { usagePreference: ['gpu-optimized'], dataFormatPreference: [] } });\n    }\n    return init;\n}\nfunction addXRSessionFeature(value, key, requiredFeatures, optionalFeatures) {\n    if (value === false) {\n        return;\n    }\n    if (value === true) {\n        optionalFeatures.push(key);\n        return;\n    }\n    requiredFeatures.push(key);\n}\n", "import { createStore } from 'zustand/vanilla';\nimport { updateXRHandState } from './hand/state.js';\nimport { updateXRControllerState } from './controller/index.js';\nimport { createSyncXRInputSourceStates } from './input.js';\nimport { buildXRSessionInit } from './init.js';\nexport function resolveInputSourceImplementation(implementation, handedness, defaultValue) {\n    if (typeof implementation === 'function') {\n        return implementation;\n    }\n    if (typeof implementation === 'object') {\n        if (handedness != null && hasKey(implementation, handedness)) {\n            implementation = implementation[handedness];\n        }\n        else if ('default' in implementation) {\n            implementation = implementation.default;\n        }\n    }\n    if (implementation === false) {\n        return false;\n    }\n    if (implementation === true) {\n        return defaultValue;\n    }\n    return implementation ?? defaultValue;\n}\nfunction hasKey(val, key) {\n    return key in val;\n}\nconst baseInitialState = {\n    session: undefined,\n    mediaBinding: undefined,\n    originReferenceSpace: undefined,\n    visibilityState: undefined,\n    mode: null,\n    frameRate: undefined,\n    inputSourceStates: [],\n    detectedMeshes: [],\n    detectedPlanes: [],\n    layerEntries: [],\n};\nfunction startEmulate(emulate, alert) {\n    Promise.all([navigator.xr?.isSessionSupported('immersive-vr'), navigator.xr?.isSessionSupported('immersive-ar')])\n        .then(([vr, ar]) => (!ar && !vr ? import('./emulate.js') : undefined))\n        .then((pkg) => {\n        if (alert) {\n            window.alert(`emulator started`);\n        }\n        pkg?.emulate(emulate === true ? 'metaQuest3' : emulate);\n    });\n}\nexport function createXRStore(options) {\n    const emulate = options?.emulate ?? 'metaQuest3';\n    let cleanupEmulate;\n    if (typeof window !== 'undefined' && emulate != false) {\n        if (window.location.hostname === 'localhost') {\n            startEmulate(emulate, false);\n        }\n        const keydownListener = (e) => {\n            if (e.altKey && e.metaKey && e.code === 'KeyE') {\n                startEmulate(emulate, true);\n            }\n        };\n        window.addEventListener('keydown', keydownListener);\n        cleanupEmulate = () => window.removeEventListener('keydown', keydownListener);\n    }\n    const domOverlayRoot = options?.domOverlay instanceof HTMLElement ? options.domOverlay : document.createElement('div');\n    const store = createStore(() => ({\n        ...baseInitialState,\n        controller: options?.controller,\n        hand: options?.hand,\n        gaze: options?.gaze,\n        screenInput: options?.screenInput,\n        transientPointer: options?.transientPointer,\n        domOverlayRoot,\n    }));\n    let cleanupDomOverlayRoot;\n    if (domOverlayRoot.parentNode == null) {\n        const setupDisplay = (state) => {\n            domOverlayRoot.style.display = state.session != null ? 'block' : 'none';\n        };\n        const unsubscribe = store.subscribe(setupDisplay);\n        setupDisplay(store.getState());\n        document.body.appendChild(domOverlayRoot);\n        cleanupDomOverlayRoot = () => {\n            domOverlayRoot.remove();\n            unsubscribe();\n        };\n    }\n    document.body.append(domOverlayRoot);\n    const syncXRInputSourceStates = createSyncXRInputSourceStates((state) => store.setState({ inputSourceStates: [...store.getState().inputSourceStates, state] }), options);\n    const bindToSession = createBindToSession(store, syncXRInputSourceStates, options?.secondaryInputSources ?? false);\n    const cleanupSessionGrantedListener = setupSessionGrantedListener(options?.enterGrantedSession, (mode) => enterXR(domOverlayRoot, mode, options, xrManager));\n    let cleanupSessionStartListener;\n    const frameRequests = [];\n    let xrManager;\n    return Object.assign(store, {\n        addLayerEntry(layerEntry) {\n            if (store.getState().session == null) {\n                return;\n            }\n            store.setState({ layerEntries: [...store.getState().layerEntries, layerEntry] });\n        },\n        removeLayerEntry(layerEntry) {\n            if (store.getState().session == null) {\n                return;\n            }\n            store.setState({ layerEntries: store.getState().layerEntries.filter((entry) => entry != layerEntry) });\n        },\n        requestFrame() {\n            return new Promise((resolve) => frameRequests.push(resolve));\n        },\n        setWebXRManager(newXrManager) {\n            if (xrManager === newXrManager) {\n                return;\n            }\n            xrManager = newXrManager;\n            const { foveation, bounded } = options ?? {};\n            newXrManager.setReferenceSpaceType(bounded ? 'bounded-floor' : 'local-floor');\n            if (foveation != null) {\n                newXrManager.setFoveation(foveation);\n            }\n        },\n        setFrameRate(value) {\n            const { session } = store.getState();\n            if (session == null) {\n                return;\n            }\n            setFrameRate(session, value);\n        },\n        setHand(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ hand: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().hand;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                hand: newControllerImplementation,\n            });\n        },\n        setController(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ controller: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().controller;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                controller: newControllerImplementation,\n            });\n        },\n        setTransientPointer(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ transientPointer: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().transientPointer;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                transientPointer: newControllerImplementation,\n            });\n        },\n        setGaze(implementation) {\n            store.setState({ gaze: implementation });\n        },\n        setScreenInput(implementation) {\n            store.setState({ screenInput: implementation });\n        },\n        destroy() {\n            cleanupEmulate?.();\n            cleanupDomOverlayRoot?.();\n            cleanupSessionStartListener?.();\n            cleanupSessionGrantedListener?.();\n            //unbinding the session\n            bindToSession(undefined);\n        },\n        enterXR: (mode) => enterXR(domOverlayRoot, mode, options, xrManager),\n        enterAR: () => enterXR(domOverlayRoot, 'immersive-ar', options, xrManager),\n        enterVR: () => enterXR(domOverlayRoot, 'immersive-vr', options, xrManager),\n        onBeforeFrame(scene, camera, frame) {\n            let update;\n            const referenceSpace = xrManager?.getReferenceSpace() ?? undefined;\n            const state = store.getState();\n            //update origin\n            const origin = camera.parent ?? scene;\n            if (state.origin != origin) {\n                origin.xrSpace = referenceSpace;\n                update ??= {};\n                update.origin = origin;\n            }\n            //update reference space\n            if (referenceSpace != state.originReferenceSpace) {\n                origin.xrSpace = referenceSpace;\n                update ??= {};\n                update.originReferenceSpace = referenceSpace;\n            }\n            if (frame != null) {\n                if (xrManager != null) {\n                    updateSession(store, frame, xrManager);\n                }\n                if (state.session == null && referenceSpace != null && frame.session != null) {\n                    update ??= {};\n                    Object.assign(update, bindToSession(frame.session));\n                }\n            }\n            if (update != null) {\n                store.setState(update);\n            }\n            if (frame != null) {\n                const length = frameRequests.length;\n                for (let i = 0; i < length; i++) {\n                    frameRequests[i](frame);\n                }\n                frameRequests.length = 0;\n            }\n        },\n        onBeforeRender() {\n            const { session, layerEntries } = store.getState();\n            if (session == null || xrManager == null) {\n                return;\n            }\n            const currentLayers = session?.renderState.layers;\n            if (currentLayers == null) {\n                return;\n            }\n            //TODO: sort by distance to camera\n            ;\n            layerEntries.sort((l1, l2) => l1.renderOrder - l2.renderOrder);\n            let changed = false;\n            const layers = layerEntries.map(({ layer }, i) => {\n                if (layer != currentLayers[i]) {\n                    changed = true;\n                }\n                return layer;\n            });\n            if (!changed) {\n                return;\n            }\n            layers.push(xrManager.getBaseLayer());\n            session.updateRenderState({\n                layers,\n            });\n        },\n    });\n}\nasync function setFrameRate(session, frameRate) {\n    if (frameRate === false) {\n        return;\n    }\n    const { supportedFrameRates } = session;\n    if (supportedFrameRates == null || supportedFrameRates.length === 0) {\n        return;\n    }\n    if (typeof frameRate === 'function') {\n        const value = frameRate(supportedFrameRates);\n        if (value === false) {\n            return;\n        }\n        return session.updateTargetFrameRate(value);\n    }\n    const multiplier = frameRate === 'high' ? 1 : frameRate === 'mid' ? 0.5 : 0;\n    return session.updateTargetFrameRate(supportedFrameRates[Math.ceil((supportedFrameRates.length - 1) * multiplier)]);\n}\nasync function enterXR(domOverlayRoot, mode, options, xrManager) {\n    if (navigator.xr == null) {\n        return Promise.reject(new Error(`WebXR not supported`));\n    }\n    if (xrManager == null) {\n        return Promise.reject(new Error(`not connected to three.js. Missing are <XR> component?`));\n    }\n    const session = await navigator.xr.requestSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));\n    setFrameRate(session, options?.frameRate ?? 'high');\n    setupXRManager(xrManager, session, options);\n    return session;\n}\nfunction setupXRManager(xr, session, options) {\n    if (xr == null) {\n        return;\n    }\n    const maxFrameBufferScalingFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);\n    let frameBufferScaling = options?.frameBufferScaling;\n    if (typeof frameBufferScaling === 'function') {\n        frameBufferScaling = frameBufferScaling(maxFrameBufferScalingFactor);\n    }\n    if (typeof frameBufferScaling === 'string') {\n        frameBufferScaling =\n            frameBufferScaling === 'high' ? maxFrameBufferScalingFactor : frameBufferScaling === 'mid' ? 1 : 0.5;\n    }\n    if (frameBufferScaling != null) {\n        xr?.setFramebufferScaleFactor(frameBufferScaling);\n    }\n    xr?.setSession(session);\n}\nconst allSessionModes = ['immersive-ar', 'immersive-vr', 'inline'];\nfunction setupSessionGrantedListener(enterGrantedSession = allSessionModes, enterXR) {\n    if (enterGrantedSession === false) {\n        return;\n    }\n    if (enterGrantedSession === true) {\n        enterGrantedSession = allSessionModes;\n    }\n    const sessionGrantedListener = async () => {\n        for (const mode of enterGrantedSession) {\n            if (!(await navigator.xr?.isSessionSupported(mode))) {\n                continue;\n            }\n            enterXR(mode);\n        }\n    };\n    navigator.xr?.addEventListener('sessiongranted', sessionGrantedListener);\n    return () => navigator.xr?.removeEventListener('sessiongranted', sessionGrantedListener);\n}\nfunction createBindToSession(store, syncXRInputSourceStates, secondayInputSources) {\n    let cleanupSession;\n    return (session) => {\n        cleanupSession?.();\n        if (session == null) {\n            return {};\n        }\n        //for debouncing the input source and tracked source changes\n        const inputSourceChangesList = [];\n        let inputSourceChangesTimeout;\n        const applySourcesChange = () => {\n            inputSourceChangesTimeout = undefined;\n            store.setState({\n                inputSourceStates: syncXRInputSourceStates(session, store.getState().inputSourceStates, inputSourceChangesList),\n            });\n            inputSourceChangesList.length = 0;\n        };\n        const onSourcesChange = (isPrimary, e) => {\n            inputSourceChangesList.push({ isPrimary, added: e.added, removed: e.removed });\n            if (inputSourceChangesTimeout != null) {\n                return;\n            }\n            if (secondayInputSources) {\n                inputSourceChangesTimeout = setTimeout(applySourcesChange, 100);\n            }\n            else {\n                applySourcesChange();\n            }\n        };\n        const onInputSourcesChange = onSourcesChange.bind(null, true);\n        session.addEventListener('inputsourceschange', onInputSourcesChange);\n        let cleanupSecondaryInputSources;\n        if (secondayInputSources) {\n            const onTrackedSourcesChange = onSourcesChange.bind(null, false);\n            session.addEventListener('trackedsourceschange', onTrackedSourcesChange);\n            cleanupSecondaryInputSources = () => session.removeEventListener('trackedsourceschange', onTrackedSourcesChange);\n        }\n        //frameratechange and visibilitychange handlers\n        const onChange = () => store.setState({ frameRate: session.frameRate, visibilityState: session.visibilityState });\n        session.addEventListener('frameratechange', onChange);\n        session.addEventListener('visibilitychange', onChange);\n        //end handler\n        const onEnd = () => {\n            cleanupSession?.();\n            cleanupSession = undefined;\n            store.setState(baseInitialState);\n        };\n        session.addEventListener('end', onEnd);\n        const initialChanges = [\n            { isPrimary: true, added: session.inputSources },\n        ];\n        if (secondayInputSources) {\n            initialChanges.push({ isPrimary: false, added: session.trackedSources });\n        }\n        const inputSourceStates = syncXRInputSourceStates(session, [], initialChanges);\n        cleanupSession = () => {\n            //cleanup\n            cleanupSecondaryInputSources?.();\n            clearTimeout(inputSourceChangesTimeout);\n            syncXRInputSourceStates(session, store.getState().inputSourceStates, 'remove-all');\n            session.removeEventListener('end', onEnd);\n            session.removeEventListener('frameratechange', onChange);\n            session.removeEventListener('visibilitychange', onChange);\n            session.removeEventListener('inputsourceschange', onInputSourcesChange);\n        };\n        return {\n            inputSourceStates,\n            frameRate: session.frameRate,\n            visibilityState: session.visibilityState,\n            detectedMeshes: [],\n            detectedPlanes: [],\n            mode: session.environmentBlendMode === 'opaque' ? 'immersive-vr' : 'immersive-ar',\n            session,\n            mediaBinding: typeof XRMediaBinding == 'undefined' ? undefined : new XRMediaBinding(session),\n        };\n    };\n}\nfunction updateSession(store, frame, manager) {\n    const referenceSpace = manager.getReferenceSpace();\n    const { detectedMeshes: prevMeshes, detectedPlanes: prevPlanes, session, inputSourceStates } = store.getState();\n    if (referenceSpace == null || session == null) {\n        //not in a XR session\n        return;\n    }\n    //update detected planes and meshes\n    const detectedPlanes = updateDetectedEntities(prevPlanes, frame.detectedPlanes);\n    const detectedMeshes = updateDetectedEntities(prevMeshes, frame.detectedMeshes);\n    if (prevPlanes != detectedPlanes || prevMeshes != detectedMeshes) {\n        store.setState({ detectedPlanes, detectedMeshes });\n    }\n    //update input sources\n    const inputSourceStatesLength = inputSourceStates.length;\n    for (let i = 0; i < inputSourceStatesLength; i++) {\n        const inputSourceState = inputSourceStates[i];\n        switch (inputSourceState.type) {\n            case 'controller':\n                updateXRControllerState(inputSourceState);\n                break;\n            case 'hand':\n                updateXRHandState(inputSourceState, frame, manager);\n                break;\n        }\n    }\n}\nconst emptyArray = [];\nfunction updateDetectedEntities(prevDetectedEntities, detectedEntities) {\n    if (detectedEntities == null) {\n        return emptyArray;\n    }\n    if (prevDetectedEntities != null && equalContent(detectedEntities, prevDetectedEntities)) {\n        return prevDetectedEntities;\n    }\n    return Array.from(detectedEntities);\n}\nfunction equalContent(set, arr) {\n    if (set.size != arr.length) {\n        return false;\n    }\n    for (const entry of arr) {\n        if (!set.has(entry)) {\n            return false;\n        }\n    }\n    return true;\n}\n", "import { BoxGeometry, Mesh, PlaneGeometry } from 'three';\nimport { onXRFrame } from './utils.js';\nimport { PointerRayMaterial, updatePointerRayModel } from '../pointer/ray.js';\nimport { PointerCursorMaterial, updatePointerCursorModel } from '../pointer/cursor.js';\nconst pointerRayGeometry = new BoxGeometry();\nexport class PointerRayModel extends Mesh {\n    constructor(pointer, options = {}) {\n        const material = new PointerRayMaterial();\n        super(pointerRayGeometry, material);\n        this.renderOrder = options.renderOrder ?? 2;\n        onXRFrame(() => updatePointerRayModel(this, material, pointer, options));\n    }\n}\nconst pointerCursorGeometry = new PlaneGeometry();\nexport class PointerCursorModel extends Mesh {\n    constructor(pointer, options = {}) {\n        const material = new PointerCursorMaterial();\n        super(pointerCursorGeometry, material);\n        this.renderOrder = options.renderOrder ?? 1;\n        onXRFrame(() => updatePointerCursorModel(this, material, pointer, options));\n    }\n}\n", "import { DefaultGltfLoader } from '../index.js';\nimport { Material, Mesh } from 'three';\nexport async function loadXRControllerModel(layout, loader = DefaultGltfLoader) {\n    const { scene } = await loader.loadAsync(layout.assetPath);\n    return scene.clone(true);\n}\nexport function configureXRControllerModel(model, options) {\n    model.renderOrder = options?.renderOrder ?? 0;\n    model.traverse((child) => {\n        if (child instanceof Mesh && child.material instanceof Material) {\n            child.material.colorWrite = options?.colorWrite ?? true;\n        }\n    });\n}\n", "import { Vector2 } from 'three';\nexport function createUpdateXRControllerVisuals(model, layout, gamepadState) {\n    const updateVisuals = [];\n    for (const componentName in layout.components) {\n        const component = layout.components[componentName];\n        let state = gamepadState[componentName];\n        if (state == null) {\n            gamepadState[componentName] = state = {\n                state: 'default',\n            };\n        }\n        updateVisuals.push(...Object.values(component.visualResponses).map((visualResponse) => createUpdateVisualResponse(model, state, visualResponse)));\n    }\n    return () => {\n        const length = updateVisuals.length;\n        for (let i = 0; i < length; i++) {\n            updateVisuals[i]();\n        }\n    };\n}\nfunction createUpdateVisualResponse(model, componentState, visualResponse) {\n    const valueNode = model.getObjectByName(visualResponse.valueNodeName);\n    componentState.object = valueNode;\n    if (valueNode == null) {\n        return () => { };\n    }\n    if (visualResponse.valueNodeProperty === 'visibility') {\n        return () => (valueNode.visible = visualResponse.states.includes(componentState.state));\n    }\n    const minNode = model.getObjectByName(visualResponse.minNodeName);\n    const maxNode = model.getObjectByName(visualResponse.maxNodeName);\n    if (minNode == null || maxNode == null) {\n        return () => { };\n    }\n    return () => {\n        const value = getVisualReponseValue(componentState, visualResponse);\n        valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);\n        valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n        valueNode.updateMatrix();\n    };\n}\n/**\n * @returns a value between 0 and 1\n */\nfunction getVisualReponseValue(componentState, { componentProperty, states }) {\n    const stateIsActive = states.includes(componentState.state);\n    switch (componentProperty) {\n        case 'xAxis':\n            return stateIsActive ? getNormalizesAxis(componentState).x : 0.5;\n        case 'yAxis':\n            return stateIsActive ? getNormalizesAxis(componentState).y : 0.5;\n        case 'button':\n            return stateIsActive ? (componentState.button ?? 0) : 0;\n        case 'state':\n            return stateIsActive ? 1.0 : 0.0;\n    }\n}\nconst vector2Helper = new Vector2();\n/**\n * project the point (x: [-1, 1], y: [-1, 1]) onto a circle\n */\nfunction getNormalizesAxis({ xAxis = 0, yAxis = 0 }) {\n    const hypotenuse = vector2Helper.lengthSq(); //we can use the length squared since \"1 * 1 = 1\"\n    if (hypotenuse > 1) {\n        const theta = Math.atan2(yAxis, xAxis);\n        vector2Helper.set(Math.cos(theta), Math.sin(theta));\n    }\n    else {\n        //point is inside the circle\n        vector2Helper.set(xAxis, yAxis);\n    }\n    vector2Helper.multiplyScalar(0.5).addScalar(0.5);\n    return vector2Helper;\n}\n", "export function hasObjectListeners({ _listeners, __r3f }) {\n    if (_listeners != null && Object.keys(_listeners).length > 0) {\n        return true;\n    }\n    if (__r3f != null && __r3f?.eventCount > 0) {\n        return true;\n    }\n    return false;\n}\nexport function getObjectListeners({ _listeners, __r3f }, forEvent) {\n    if (_listeners != null && forEvent in _listeners) {\n        return _listeners[forEvent];\n    }\n    //R3F compatibility\n    if (__r3f == null) {\n        return undefined;\n    }\n    const handler = __r3f.handlers[r3fEventToHandlerMap[forEvent]];\n    if (handler == null) {\n        return;\n    }\n    return [handler];\n}\nconst r3fEventToHandlerMap = {\n    click: 'onClick',\n    contextmenu: 'onContextMenu',\n    dblclick: 'onDoubleClick',\n    pointercancel: 'onPointerCancel',\n    pointerdown: 'onPointerDown',\n    pointerenter: 'onPointerEnter',\n    pointerleave: 'onPointerLeave',\n    pointermove: 'onPointerMove',\n    pointerout: 'onPointerOut',\n    pointerover: 'onPointerOver',\n    pointerup: 'onPointerUp',\n    wheel: 'onWheel',\n};\n", "import { getObjectListeners } from './utils.js';\nexport class PointerEvent {\n    type;\n    bubbles;\n    nativeEvent;\n    pointer;\n    intersection;\n    currentObject;\n    object;\n    //--- pointer events data\n    get pointerId() {\n        return this.pointer.id;\n    }\n    get pointerType() {\n        return this.pointer.type;\n    }\n    get pointerState() {\n        return this.pointer.state;\n    }\n    get timeStamp() {\n        return this.nativeEvent.timeStamp;\n    }\n    get button() {\n        return this.nativeEvent.button;\n    }\n    get shiftKey() {\n        return this.nativeEvent.shiftKey ?? false;\n    }\n    get metaKey() {\n        return this.nativeEvent.metaKey ?? false;\n    }\n    get ctrlKey() {\n        return this.nativeEvent.ctrlKey ?? false;\n    }\n    get altKey() {\n        return this.nativeEvent.altKey ?? false;\n    }\n    //--- intersection data\n    get distance() {\n        return this.intersection.distance;\n    }\n    get distanceToRay() {\n        return this.intersection.distanceToRay;\n    }\n    get point() {\n        return this.intersection.point;\n    }\n    get index() {\n        return this.intersection.index;\n    }\n    get face() {\n        return this.intersection.face;\n    }\n    get faceIndex() {\n        return this.intersection.faceIndex;\n    }\n    get uv() {\n        return this.intersection.uv;\n    }\n    get uv1() {\n        return this.intersection.uv1;\n    }\n    get normal() {\n        return this.intersection.normal;\n    }\n    get instanceId() {\n        return this.intersection.instanceId;\n    }\n    get pointOnLine() {\n        return this.intersection.pointOnLine;\n    }\n    get batchId() {\n        return this.intersection.batchId;\n    }\n    get pointerPosition() {\n        return this.intersection.pointerPosition;\n    }\n    get pointerQuaternion() {\n        return this.intersection.pointerQuaternion;\n    }\n    get pointOnFace() {\n        return this.intersection.pointOnFace;\n    }\n    get localPoint() {\n        return this.intersection.localPoint;\n    }\n    get details() {\n        return this.intersection.details;\n    }\n    /** same as target */\n    get target() {\n        return this.object;\n    }\n    /** same as currentTarget */\n    get currentTarget() {\n        return this.currentObject;\n    }\n    //the stop propagation functions will be set while propagating\n    stopPropagation;\n    stopImmediatePropagation;\n    constructor(type, bubbles, nativeEvent, pointer, intersection, currentObject = intersection.object, object = currentObject) {\n        this.type = type;\n        this.bubbles = bubbles;\n        this.nativeEvent = nativeEvent;\n        this.pointer = pointer;\n        this.intersection = intersection;\n        this.currentObject = currentObject;\n        this.object = object;\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        const { type, bubbles, nativeEvent, pointer, intersection, target } = this;\n        return new PointerEvent(type, bubbles, nativeEvent, pointer, intersection, currentObject, target);\n    }\n}\nexport class WheelEvent extends PointerEvent {\n    get deltaX() {\n        return this.nativeEvent.deltaX;\n    }\n    get deltaY() {\n        return this.nativeEvent.deltaY;\n    }\n    get deltaZ() {\n        return this.nativeEvent.deltaZ;\n    }\n    constructor(nativeEvent, pointer, intersection, currentObject, object) {\n        super('wheel', true, nativeEvent, pointer, intersection, currentObject, object);\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        const { type, bubbles, nativeEvent, pointer, intersection, target } = this;\n        return new WheelEvent(nativeEvent, pointer, intersection, currentObject, target);\n    }\n}\nexport function emitPointerEvent(event) {\n    emitPointerEventRec(event, event.currentObject);\n}\nfunction emitPointerEventRec(baseEvent, currentObject) {\n    if (currentObject == null) {\n        return;\n    }\n    const listeners = getObjectListeners(currentObject, baseEvent.type);\n    let propagationStopped = !baseEvent.bubbles;\n    if (listeners != null && listeners.length > 0) {\n        const event = baseEvent.retarget(currentObject);\n        const length = listeners.length;\n        event.stopPropagation = () => (propagationStopped = true);\n        let loopStopped = false;\n        event.stopImmediatePropagation = () => {\n            propagationStopped = true;\n            loopStopped = true;\n        };\n        for (let i = 0; i < length && !loopStopped; i++) {\n            listeners[i](event);\n        }\n    }\n    if (propagationStopped) {\n        return;\n    }\n    emitPointerEventRec(baseEvent, currentObject.parent);\n}\n", "import { Object3D } from 'three';\nimport { PointerEvent, WheelEvent, emitPointerEvent } from './event.js';\nconst buttonsDownTimeKey = Symbol('buttonsDownTime');\nconst buttonsClickTimeKey = Symbol('buttonsClickTime');\nconst pointerMap = new Map();\nObject3D.prototype.setPointerCapture = function (pointerId) {\n    getPointerById(pointerId)?.setCapture(this);\n};\nObject3D.prototype.releasePointerCapture = function (pointerId) {\n    const pointer = getPointerById(pointerId);\n    if (pointer == null || !pointer.hasCaptured(this)) {\n        return;\n    }\n    pointer.setCapture(undefined);\n};\nObject3D.prototype.hasPointerCapture = function (pointerId) {\n    return getPointerById(pointerId)?.hasCaptured(this) ?? false;\n};\nexport function getPointerById(pointerId) {\n    return pointerMap.get(pointerId);\n}\nexport class Pointer {\n    id;\n    type;\n    state;\n    computeIntersection;\n    onMoveCommited;\n    parentSetPointerCapture;\n    parentReleasePointerCapture;\n    options;\n    //state\n    prevIntersection;\n    intersection;\n    prevEnabled = true;\n    enabled = true;\n    //derived state\n    /**\n     * ordered leaf -> root (bottom -> top)\n     */\n    pointerEntered = [];\n    pointerEnteredHelper = [];\n    pointerCapture;\n    buttonsDownTime = new Map();\n    buttonsDown = new Set();\n    //to handle interaction before first move\n    wasMoved = false;\n    onFirstMove = [];\n    constructor(id, type, state, computeIntersection, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {\n        this.id = id;\n        this.type = type;\n        this.state = state;\n        this.computeIntersection = computeIntersection;\n        this.onMoveCommited = onMoveCommited;\n        this.parentSetPointerCapture = parentSetPointerCapture;\n        this.parentReleasePointerCapture = parentReleasePointerCapture;\n        this.options = options;\n        pointerMap.set(id, this);\n    }\n    hasCaptured(object) {\n        return this.pointerCapture?.object === object;\n    }\n    setCapture(object) {\n        if (this.pointerCapture?.object === object) {\n            return;\n        }\n        if (this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        if (object != null && this.intersection != null) {\n            this.pointerCapture = { object, intersection: this.intersection };\n            this.parentSetPointerCapture?.();\n        }\n    }\n    getButtonsDown() {\n        return this.buttonsDown;\n    }\n    getIntersection() {\n        return this.intersection;\n    }\n    getEnabled() {\n        return this.enabled;\n    }\n    setEnabled(enabled, nativeEvent, commit = true) {\n        if (this.enabled === enabled) {\n            return;\n        }\n        if (!enabled && this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        this.enabled = enabled;\n        if (commit) {\n            this.commit(nativeEvent);\n        }\n    }\n    /**\n     * allows to separately compute and afterwards commit a move\n     * => do not forget to call commitMove after computeMove\n     * can be used to compute the current intersection and disable or enable the pointer before commiting the move\n     */\n    computeMove(scene, nativeEvent) {\n        this.intersection = this.computeIntersection(scene, nativeEvent, this.pointerCapture);\n    }\n    commit(nativeEvent) {\n        const prevIntersection = this.prevEnabled ? this.prevIntersection : undefined;\n        const intersection = this.enabled ? this.intersection : undefined;\n        //pointer out\n        if (prevIntersection != null && prevIntersection.object != intersection?.object) {\n            emitPointerEvent(new PointerEvent('pointerout', true, nativeEvent, this, prevIntersection));\n        }\n        const pointerLeft = this.pointerEntered;\n        this.pointerEntered = [];\n        this.pointerEnteredHelper.length = 0;\n        computeEnterLeave(intersection?.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);\n        //pointerleave\n        const length = pointerLeft.length;\n        for (let i = 0; i < length; i++) {\n            const object = pointerLeft[i];\n            emitPointerEvent(new PointerEvent('pointerleave', false, nativeEvent, this, prevIntersection, object));\n        }\n        //pointer over\n        if (intersection != null && prevIntersection?.object != intersection.object) {\n            emitPointerEvent(new PointerEvent('pointerover', true, nativeEvent, this, intersection));\n        }\n        //pointer enter\n        //inverse loop so that we emit enter from top -> bottom (root -> leaf)\n        for (let i = this.pointerEnteredHelper.length - 1; i >= 0; i--) {\n            const object = this.pointerEnteredHelper[i];\n            emitPointerEvent(new PointerEvent('pointerenter', false, nativeEvent, this, intersection, object));\n        }\n        //pointer move\n        if (intersection != null) {\n            emitPointerEvent(new PointerEvent('pointermove', true, nativeEvent, this, intersection));\n        }\n        this.prevIntersection = this.intersection;\n        this.prevEnabled = this.enabled;\n        if (!this.wasMoved) {\n            this.wasMoved = true;\n            const length = this.onFirstMove.length;\n            for (let i = 0; i < length; i++) {\n                this.onFirstMove[i]();\n            }\n            this.onFirstMove.length = 0;\n        }\n        this.onMoveCommited?.(this);\n    }\n    /**\n     * computes and commits a move\n     */\n    move(scene, nativeEvent) {\n        this.computeMove(scene, nativeEvent);\n        this.commit(nativeEvent);\n    }\n    down(nativeEvent) {\n        this.buttonsDown.add(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.down.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer down\n        emitPointerEvent(new PointerEvent('pointerdown', true, nativeEvent, this, this.intersection));\n        //store button down times on object and on pointer\n        const { object } = this.intersection;\n        object[buttonsDownTimeKey] ??= new Map();\n        object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);\n        this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);\n    }\n    up(nativeEvent) {\n        this.buttonsDown.delete(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.up.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        const { contextMenuButton = 2, dblClickThresholdMs = 500, clickThesholdMs = 300 } = this.options;\n        this.pointerCapture = undefined;\n        const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThesholdMs);\n        //context menu\n        if (isClicked && nativeEvent.button === contextMenuButton) {\n            emitPointerEvent(new PointerEvent('contextmenu', true, nativeEvent, this, this.intersection));\n        }\n        //poinerup\n        emitPointerEvent(new PointerEvent('pointerup', true, nativeEvent, this, this.intersection));\n        if (!isClicked || nativeEvent.button === contextMenuButton) {\n            return;\n        }\n        //click\n        emitPointerEvent(new PointerEvent('click', true, nativeEvent, this, this.intersection));\n        //dblclick\n        const { object } = this.intersection;\n        const buttonsClickTime = (object[buttonsClickTimeKey] ??= new Map());\n        const buttonClickTime = buttonsClickTime.get(nativeEvent.button);\n        if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {\n            buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);\n            return;\n        }\n        emitPointerEvent(new PointerEvent('dblclick', true, nativeEvent, this, this.intersection));\n        buttonsClickTime.delete(nativeEvent.button);\n    }\n    cancel(nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.cancel.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer cancel\n        emitPointerEvent(new PointerEvent('pointercancel', true, nativeEvent, this, this.intersection));\n    }\n    wheel(scene, nativeEvent, useCurrentIntersection) {\n        if (!this.enabled) {\n            return;\n        }\n        let intersection = this.intersection;\n        if (!useCurrentIntersection) {\n            intersection = this.computeIntersection(scene, nativeEvent, this.pointerCapture);\n        }\n        if (!this.wasMoved && useCurrentIntersection) {\n            this.onFirstMove.push(this.cancel.bind(this, nativeEvent));\n            return;\n        }\n        if (intersection == null) {\n            return;\n        }\n        //wheel\n        emitPointerEvent(new WheelEvent(nativeEvent, this, intersection));\n    }\n    exit(nativeEvent) {\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.exit.bind(this, nativeEvent));\n            return;\n        }\n        //reset state\n        if (this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        this.intersection = undefined;\n        this.commit(nativeEvent);\n    }\n}\n/**\n * @returns an array that contains the object and all its ancestors ordered leaf -> root (bottom -> top)\n */\nfunction computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {\n    if (currentObject == null) {\n        return;\n    }\n    const index = targeDiffRemovedAncestors.indexOf(currentObject);\n    if (index != -1) {\n        targeDiffRemovedAncestors.splice(index, 1);\n    }\n    else {\n        targetDiffAddedAncestors.push(currentObject);\n    }\n    targetAllAncestors.push(currentObject);\n    computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);\n}\nfunction getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThesholdMs) {\n    if (objectButtonsDownTime == null) {\n        return false;\n    }\n    const objectButtonPressTime = objectButtonsDownTime.get(button);\n    if (objectButtonPressTime == null) {\n        return false;\n    }\n    if (buttonUpTime - objectButtonPressTime > clickThesholdMs) {\n        return false;\n    }\n    if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {\n        //we have released the button somewhere else\n        return false;\n    }\n    return true;\n}\n", "import { hasObjectListeners } from '../utils.js';\nexport function computeIntersectionWorldPlane(target, intersection, object) {\n    if (intersection.face == null) {\n        return false;\n    }\n    target.setFromNormalAndCoplanarPoint(intersection.face.normal, intersection.localPoint);\n    target.applyMatrix4(object.matrixWorld);\n    return true;\n}\nfunction isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType, pointerId, pointerType, pointerState) {\n    if (pointerEvents === 'none') {\n        return false;\n    }\n    if (pointerEvents === 'listener' && !hasListener) {\n        return false;\n    }\n    if (pointerEventsType === 'all') {\n        return true;\n    }\n    if (typeof pointerEventsType === 'function') {\n        return pointerEventsType(pointerId, pointerType, pointerState);\n    }\n    let value;\n    let invert;\n    if ('deny' in pointerEventsType) {\n        invert = true;\n        value = pointerEventsType.deny;\n    }\n    else {\n        invert = false;\n        value = pointerEventsType.allow;\n    }\n    let result;\n    if (Array.isArray(value)) {\n        result = value.includes(pointerType);\n    }\n    else {\n        result = value === pointerType;\n    }\n    return invert ? !result : result;\n}\nexport function traversePointerEventTargets(object, pointerId, pointerType, pointerState, callback, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {\n    const hasListener = parentHasListener || hasObjectListeners(object);\n    const pointerEvents = object.pointerEvents ?? parentPointerEvents;\n    const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType;\n    const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder;\n    const isAllowed = isPointerEventsAllowed(hasListener, pointerEvents ?? 'listener', pointerEventsType ?? 'all', pointerId, pointerType, pointerState);\n    if (isAllowed) {\n        callback(object, pointerEventsOrder);\n    }\n    const length = object.children.length;\n    for (let i = 0; i < length; i++) {\n        traversePointerEventTargets(object.children[i], pointerId, pointerType, pointerState, callback, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);\n    }\n}\n/**\n * @returns undefined if `i1` is the dominant intersection\n */\nexport function getDominantIntersectionIndex(i1, pointerEventsOrder1, i2, pointerEventsOrder2, { customFilter, customSort: compare = defaultSort } = {}) {\n    let index = undefined;\n    const length = i2.length;\n    for (let i = 0; i < length; i++) {\n        const intersection = i2[i];\n        if (!(customFilter?.(intersection) ?? true)) {\n            continue;\n        }\n        if (i1 == null || compare(i1, pointerEventsOrder1, intersection, pointerEventsOrder2) > 0) {\n            i1 = intersection;\n            index = i;\n        }\n    }\n    return index;\n}\n/**\n * @returns a negative number if i1 should be sorted before i2\n */\nfunction defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {\n    if (pointerEventsOrder1 != pointerEventsOrder2) {\n        //inverted order because order is sorted highest first\n        return pointerEventsOrder2 - pointerEventsOrder1;\n    }\n    //i1 - i2 because negative values mean the sorting i1 before i2 is correct\n    return i1.distance - i2.distance;\n}\n", "import { Line3, Matrix4, Plane, Quaternion, Ray, Raycaster, Vector3, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, traversePointerEventTargets } from './utils.js';\nconst raycaster = new Raycaster();\nconst invertedMatrixHelper = new Matrix4();\nconst intersectsHelper = [];\nexport function intersectLines(fromMatrixWorld, linePoints, scene, pointerId, pointerType, pointerState, pointerCapture, options) {\n    if (pointerCapture != null) {\n        return intersectLinesPointerCapture(fromMatrixWorld, linePoints, pointerCapture);\n    }\n    let intersection;\n    let pointerEventsOrder;\n    traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {\n        let prevAccLineLength = 0;\n        const length = (intersection?.details.lineIndex ?? linePoints.length - 2) + 2;\n        for (let i = 1; i < length; i++) {\n            const start = linePoints[i - 1];\n            const end = linePoints[i];\n            //transform from local object to world\n            raycaster.ray.origin.copy(start).applyMatrix4(fromMatrixWorld);\n            raycaster.ray.direction.copy(end).applyMatrix4(fromMatrixWorld);\n            //compute length & normalized direction\n            raycaster.ray.direction.sub(raycaster.ray.origin);\n            const lineLength = raycaster.ray.direction.length();\n            raycaster.ray.direction.divideScalar(lineLength);\n            raycaster.far = lineLength;\n            object.raycast(raycaster, intersectsHelper);\n            //we're adding the details and the prev acc line length so that the intersections are correctly sorted\n            const length = intersectsHelper.length;\n            for (let intersectionIndex = 0; intersectionIndex < length; intersectionIndex++) {\n                const int = intersectsHelper[intersectionIndex];\n                const distanceOnLine = int.distance;\n                int.distance += prevAccLineLength;\n                Object.assign(int, {\n                    details: {\n                        lineIndex: i - 1,\n                        distanceOnLine,\n                    },\n                });\n            }\n            const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, options);\n            if (index != null) {\n                intersection = intersectsHelper[index];\n                pointerEventsOrder = objectPointerEventsOrder;\n            }\n            intersectsHelper.length = 0;\n            prevAccLineLength += lineLength;\n        }\n    });\n    if (intersection == null) {\n        return undefined;\n    }\n    return Object.assign(intersection, {\n        details: {\n            ...intersection.details,\n            type: 'lines',\n        },\n        pointerPosition: new Vector3().setFromMatrixPosition(fromMatrixWorld),\n        pointerQuaternion: new Quaternion().setFromRotationMatrix(fromMatrixWorld),\n        pointOnFace: intersection.point,\n        localPoint: intersection.point\n            .clone()\n            .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n    });\n}\nconst lineHelper = new Line3();\nconst planeHelper = new Plane();\nfunction intersectLinesPointerCapture(fromMatrixWorld, linePoints, { intersection, object }) {\n    const details = intersection.details;\n    if (details.type != 'lines') {\n        return undefined;\n    }\n    lineHelper.set(linePoints[details.lineIndex], linePoints[details.lineIndex + 1]).applyMatrix4(fromMatrixWorld);\n    const point = lineHelper.at(details.distanceOnLine / lineHelper.distance(), new Vector3());\n    computeIntersectionWorldPlane(planeHelper, intersection, object);\n    const pointOnFace = backwardsIntersectionLinesWithPlane(fromMatrixWorld, linePoints, planeHelper) ?? point;\n    return {\n        ...intersection,\n        pointOnFace,\n        point,\n        pointerPosition: new Vector3().setFromMatrixPosition(fromMatrixWorld),\n        pointerQuaternion: new Quaternion().setFromRotationMatrix(fromMatrixWorld),\n    };\n}\nconst vectorHelper = new Vector3();\nconst rayHelper = new Ray();\nfunction backwardsIntersectionLinesWithPlane(fromMatrixWorld, linePoints, plane) {\n    for (let i = linePoints.length - 1; i > 0; i--) {\n        const start = linePoints[i - 1];\n        const end = linePoints[i];\n        rayHelper.origin.copy(start).applyMatrix4(fromMatrixWorld);\n        rayHelper.direction.copy(end).applyMatrix4(fromMatrixWorld).sub(raycaster.ray.origin).normalize();\n        const point = rayHelper.intersectPlane(plane, vectorHelper);\n        if (point != null) {\n            return vectorHelper.clone();\n        }\n    }\n    return undefined;\n}\n", "import { Matrix4, Plane, Ray, Raycaster, Vector3, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, traversePointerEventTargets } from './utils.js';\nconst raycaster = new Raycaster();\nconst directionHelper = new Vector3();\nconst planeHelper = new Plane();\nconst invertedMatrixHelper = new Matrix4();\nconst intersectsHelper = [];\nexport function intersectRay(fromPosition, fromQuaternion, direction, scene, pointerId, pointerType, pointerState, pointerCapture, options) {\n    if (pointerCapture != null) {\n        return intersectRayPointerCapture(fromPosition, fromQuaternion, direction, pointerCapture);\n    }\n    let intersection;\n    let pointerEventsOrder;\n    raycaster.ray.origin.copy(fromPosition);\n    raycaster.ray.direction.copy(direction).applyQuaternion(fromQuaternion);\n    traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {\n        object.raycast(raycaster, intersectsHelper);\n        const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, options);\n        if (index != null) {\n            intersection = intersectsHelper[index];\n            pointerEventsOrder = objectPointerEventsOrder;\n        }\n        intersectsHelper.length = 0;\n    });\n    if (intersection == null) {\n        return undefined;\n    }\n    return Object.assign(intersection, {\n        details: {\n            type: 'ray',\n        },\n        pointerPosition: fromPosition.clone(),\n        pointerQuaternion: fromQuaternion.clone(),\n        pointOnFace: intersection.point,\n        localPoint: intersection.point\n            .clone()\n            .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n    });\n}\nconst rayHelper = new Ray();\nfunction intersectRayPointerCapture(fromPosition, fromQuaternion, direction, { intersection, object }) {\n    if (intersection.details.type != 'ray') {\n        return undefined;\n    }\n    directionHelper.copy(direction).applyQuaternion(fromQuaternion);\n    rayHelper.set(fromPosition, directionHelper);\n    computeIntersectionWorldPlane(planeHelper, intersection, object);\n    const pointOnFace = rayHelper.intersectPlane(planeHelper, new Vector3()) ?? intersection.point;\n    return {\n        ...intersection,\n        object,\n        pointOnFace,\n        point: directionHelper.clone().multiplyScalar(intersection.distance).add(fromPosition),\n        pointerPosition: fromPosition.clone(),\n        pointerQuaternion: fromQuaternion.clone(),\n    };\n}\nexport function intersectRayFromCamera(from, coords, fromPosition, fromQuaternion, scene, pointerId, pointerType, pointerState, pointerCapture, options) {\n    if (pointerCapture != null) {\n        return intersectRayFromCameraPointerCapture(from, coords, fromPosition, fromQuaternion, pointerCapture);\n    }\n    let intersection;\n    let pointerEventsOrder;\n    raycaster.setFromCamera(coords, from);\n    planeHelper.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), raycaster.ray.origin);\n    traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {\n        object.raycast(raycaster, intersectsHelper);\n        const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, options);\n        if (index != null) {\n            intersection = intersectsHelper[index];\n            pointerEventsOrder = objectPointerEventsOrder;\n        }\n        intersectsHelper.length = 0;\n    });\n    if (intersection == null) {\n        return undefined;\n    }\n    invertedMatrixHelper.copy(intersection.object.matrixWorld).invert();\n    return Object.assign(intersection, {\n        details: {\n            type: 'camera-ray',\n            distanceViewPlane: planeHelper.distanceToPoint(intersection.point),\n        },\n        pointOnFace: intersection.point,\n        pointerPosition: fromPosition.clone(),\n        pointerQuaternion: fromQuaternion.clone(),\n        localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper),\n    });\n}\nfunction intersectRayFromCameraPointerCapture(from, coords, fromPosition, fromQuaternion, { intersection, object }) {\n    const details = intersection.details;\n    if (details.type != 'camera-ray') {\n        return undefined;\n    }\n    raycaster.setFromCamera(coords, from);\n    from.getWorldDirection(directionHelper);\n    //set the plane to the viewPlane + the distance of the prev intersection in the camera distance\n    planeHelper.setFromNormalAndCoplanarPoint(directionHelper, raycaster.ray.origin);\n    planeHelper.constant -= details.distanceViewPlane;\n    //find captured intersection point by intersecting the ray to the plane of the camera\n    const point = raycaster.ray.intersectPlane(planeHelper, new Vector3());\n    if (point == null) {\n        return undefined;\n    }\n    computeIntersectionWorldPlane(planeHelper, intersection, object);\n    const pointOnFace = raycaster.ray.intersectPlane(planeHelper, new Vector3()) ?? point;\n    return {\n        ...intersection,\n        object,\n        point,\n        pointOnFace,\n        pointerPosition: fromPosition.clone(),\n        pointerQuaternion: fromQuaternion.clone(),\n    };\n}\n", "import { InstancedMesh, Matrix4, Mesh, Vector3, Sphere, Quaternion, Plane, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, traversePointerEventTargets } from './utils.js';\nconst collisionSphere = new Sphere();\nconst intersectsHelper = [];\nexport function intersectSphere(fromPosition, fromQuaternion, radius, scene, pointerId, pointerType, pointerState, pointerCapture, options) {\n    if (pointerCapture != null) {\n        return intersectSpherePointerCapture(fromPosition, fromQuaternion, pointerCapture);\n    }\n    let intersection;\n    let pointerEventsOrder;\n    collisionSphere.center.copy(fromPosition);\n    collisionSphere.radius = radius;\n    traversePointerEventTargets(scene, pointerId, pointerType, pointerState, (object, objectPointerEventsOrder) => {\n        intersectSphereWithObject(collisionSphere, object, intersectsHelper);\n        const index = getDominantIntersectionIndex(intersection, pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, options);\n        if (index != null) {\n            intersection = intersectsHelper[index];\n            pointerEventsOrder = objectPointerEventsOrder;\n        }\n        intersectsHelper.length = 0;\n    });\n    if (intersection == null) {\n        return undefined;\n    }\n    return Object.assign(intersection, {\n        details: {\n            type: 'sphere',\n        },\n        pointOnFace: intersection.point,\n        pointerPosition: fromPosition.clone(),\n        pointerQuaternion: fromQuaternion.clone(),\n        localPoint: intersection.point\n            .clone()\n            .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n    });\n}\nconst matrixHelper = new Matrix4();\nfunction isSpherecastable(obj) {\n    return 'spherecast' in obj;\n}\nfunction intersectSphereWithObject(pointerSphere, object, target) {\n    object.updateWorldMatrix(true, false);\n    if (isSpherecastable(object)) {\n        object.spherecast(pointerSphere, target);\n        return;\n    }\n    if (object instanceof InstancedMesh) {\n        if (object.geometry.boundingSphere == null) {\n            object.geometry.computeBoundingSphere();\n        }\n        if (object.geometry.boundingBox == null) {\n            object.geometry.computeBoundingBox();\n        }\n        for (let i = 0; i < object.count; i++) {\n            object.getMatrixAt(i, matrixHelper);\n            matrixHelper.premultiply(object.matrixWorld);\n            if (!isSphereIntersectingMesh(pointerSphere, object, matrixHelper)) {\n                continue;\n            }\n            const intersection = intersectSphereMesh(pointerSphere, object, matrixHelper, i);\n            if (intersection == null) {\n                continue;\n            }\n            target.push(intersection);\n        }\n    }\n    if (!(object instanceof Mesh)) {\n        return;\n    }\n    if (!isSphereIntersectingMesh(pointerSphere, object, object.matrixWorld)) {\n        return;\n    }\n    invertedMatrixHelper.copy(object.matrixWorld).invert();\n    const intersection = intersectSphereMesh(pointerSphere, object, object.matrixWorld);\n    if (intersection == null) {\n        return;\n    }\n    target.push(intersection);\n}\nconst oldInputDevicePointOffset = new Vector3();\nconst inputDeviceQuaternionOffset = new Quaternion();\nconst planeHelper = new Plane();\nfunction intersectSpherePointerCapture(fromPosition, fromQuaterion, { intersection, object }) {\n    if (intersection.details.type != 'sphere') {\n        return undefined;\n    }\n    //compute old inputDevicePosition-point offset\n    oldInputDevicePointOffset.copy(intersection.point).sub(intersection.pointerPosition);\n    //compute oldInputDeviceQuaternion-newInputDeviceQuaternion offset\n    inputDeviceQuaternionOffset.copy(intersection.pointerQuaternion).invert().multiply(fromQuaterion);\n    //apply quaternion offset to old inputDevicePosition-point offset and add to new inputDevicePosition\n    const point = oldInputDevicePointOffset.clone().applyQuaternion(inputDeviceQuaternionOffset).add(fromPosition);\n    computeIntersectionWorldPlane(planeHelper, intersection, object);\n    const pointOnFace = planeHelper.projectPoint(fromPosition, new Vector3());\n    return {\n        details: {\n            type: 'sphere',\n        },\n        distance: intersection.distance,\n        pointerPosition: fromPosition.clone(),\n        pointerQuaternion: fromQuaterion.clone(),\n        object,\n        point,\n        pointOnFace,\n        face: intersection.face,\n        localPoint: intersection.localPoint,\n    };\n}\nconst helperSphere = new Sphere();\nfunction isSphereIntersectingMesh(pointerSphere, { geometry }, meshMatrixWorld) {\n    if (geometry.boundingSphere == null) {\n        geometry.computeBoundingSphere();\n    }\n    helperSphere.copy(geometry.boundingSphere).applyMatrix4(meshMatrixWorld);\n    return helperSphere.center.distanceToSquared(pointerSphere.center) < (pointerSphere.radius + helperSphere.radius) ** 2;\n}\nconst vectorHelper = new Vector3();\nconst boxSizeHelper = new Vector3();\nconst boxCenterHelper = new Vector3();\nconst vec0_0001 = new Vector3(0.0001, 0.0001, 0.0001);\nconst invertedMatrixHelper = new Matrix4();\nfunction intersectSphereMesh(pointerSphere, mesh, meshMatrixWorld, instanceId) {\n    invertedMatrixHelper.copy(meshMatrixWorld).invert();\n    helperSphere.copy(pointerSphere).applyMatrix4(invertedMatrixHelper);\n    const { geometry } = mesh;\n    if (geometry.boundingBox == null) {\n        geometry.computeBoundingBox();\n    }\n    geometry.boundingBox.getSize(boxSizeHelper);\n    geometry.boundingBox.getCenter(boxCenterHelper);\n    geometry.boundingBox.clampPoint(helperSphere.center, vectorHelper);\n    vectorHelper.applyMatrix4(meshMatrixWorld); //world coordinates\n    const distanceToSphereCenterSquared = vectorHelper.distanceToSquared(pointerSphere.center);\n    if (distanceToSphereCenterSquared > pointerSphere.radius * pointerSphere.radius) {\n        return undefined;\n    }\n    boxSizeHelper.max(vec0_0001);\n    const normal = helperSphere.center.clone().sub(boxCenterHelper);\n    normal.divide(boxSizeHelper);\n    maximizeAxisVector(normal);\n    const point = vectorHelper.clone();\n    return {\n        distance: Math.sqrt(distanceToSphereCenterSquared),\n        face: {\n            a: 0,\n            b: 0,\n            c: 0,\n            materialIndex: 0,\n            normal,\n        },\n        normal,\n        point,\n        instanceId,\n        object: mesh,\n    };\n}\nfunction maximizeAxisVector(vec) {\n    const absX = Math.abs(vec.x);\n    const absY = Math.abs(vec.y);\n    const absZ = Math.abs(vec.z);\n    if (absX >= absY && absX >= absZ) {\n        //x biggest\n        vec.set(vec.x < 0 ? -1 : 1, 0, 0);\n        return;\n    }\n    if (absY >= absX && absY >= absZ) {\n        //y biggest\n        vec.set(0, vec.y < 0 ? -1 : 1, 0);\n        return;\n    }\n    //z biggest\n    vec.set(0, 0, vec.z < 0 ? -1 : 1);\n}\n", "import { Quaternion, Vector3 } from 'three';\nimport { Pointer } from '../pointer.js';\nimport { intersectSphere } from '../intersections/sphere.js';\nimport { generateUniquePointerId } from './index.js';\nexport const defaultGrabPointerOptions = {\n    radius: 0.07,\n};\nexport function createGrabPointer(space, pointerState, options = defaultGrabPointerOptions, pointerType = 'grab') {\n    const fromPosition = new Vector3();\n    const fromQuaternion = new Quaternion();\n    const poinerId = generateUniquePointerId();\n    return new Pointer(poinerId, pointerType, pointerState, (scene, _, pointerCapture) => {\n        const spaceObject = space.current;\n        if (spaceObject == null) {\n            return undefined;\n        }\n        spaceObject.updateWorldMatrix(true, false);\n        fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);\n        fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);\n        return intersectSphere(fromPosition, fromQuaternion, options.radius ?? defaultGrabPointerOptions.radius, scene, poinerId, pointerType, pointerState, pointerCapture, options);\n    }, undefined, undefined, undefined, options);\n}\n", "import { Quaternion, Vector3 } from 'three';\nimport { Pointer } from '../pointer.js';\nimport { intersectLines, intersectRay } from '../intersections/index.js';\nimport { generateUniquePointerId } from './index.js';\nconst NegZAxis = new Vector3(0, 0, -1);\nconst vectorHelper = new Vector3();\nexport const defaultRayPointerOptions = {\n    direction: NegZAxis,\n    minDistance: 0,\n    linePoints: null,\n};\nexport function createRayPointer(space, pointerState, options = defaultRayPointerOptions, pointerType = 'ray') {\n    const fromPosition = new Vector3();\n    const fromQuaternion = new Quaternion();\n    const pointerId = generateUniquePointerId();\n    return new Pointer(pointerId, pointerType, pointerState, (scene, _, pointerCapture) => {\n        const spaceObject = space.current;\n        if (spaceObject == null) {\n            return undefined;\n        }\n        spaceObject.updateWorldMatrix(true, false);\n        let intersection;\n        const linePoints = options.linePoints ?? defaultRayPointerOptions.linePoints;\n        if (linePoints == null) {\n            fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);\n            fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);\n            intersection = intersectRay(fromPosition, fromQuaternion, options.direction ?? defaultRayPointerOptions.direction, scene, pointerId, pointerType, pointerState, pointerCapture, options);\n        }\n        else {\n            intersection = intersectLines(spaceObject.matrixWorld, linePoints, scene, pointerId, pointerType, pointerState, pointerCapture, options);\n        }\n        if (intersection == null) {\n            return undefined;\n        }\n        const localDistance = intersection.distance * spaceObject.getWorldScale(vectorHelper).x;\n        if (localDistance < (options.minDistance ?? defaultRayPointerOptions.minDistance)) {\n            return undefined;\n        }\n        return intersection;\n    }, undefined, undefined, undefined, options);\n}\n", "import { Quaternion, Vector3 } from 'three';\nimport { Pointer } from '../pointer.js';\nimport { intersectSphere } from '../intersections/index.js';\nimport { generateUniquePointerId } from './index.js';\nexport const defaultTouchPointerOptions = {\n    button: 0,\n    downRadius: 0.03,\n    hoverRadius: 0.1,\n};\nexport function createTouchPointer(space, pointerState, options = defaultTouchPointerOptions, pointerType = 'touch') {\n    const fromPosition = new Vector3();\n    const fromQuaternion = new Quaternion();\n    const pointerId = generateUniquePointerId();\n    return new Pointer(pointerId, pointerType, pointerState, (scene, _, pointerCapture) => {\n        const spaceObject = space.current;\n        if (spaceObject == null) {\n            return undefined;\n        }\n        spaceObject.updateWorldMatrix(true, false);\n        fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);\n        fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);\n        return intersectSphere(fromPosition, fromQuaternion, options.hoverRadius ?? defaultTouchPointerOptions.hoverRadius, scene, pointerId, pointerType, pointerState, pointerCapture, options);\n    }, createUpdateTouchPointer(options), undefined, undefined, options);\n}\nfunction createUpdateTouchPointer(options = defaultTouchPointerOptions) {\n    let wasPointerDown = false;\n    return (pointer) => {\n        if (!pointer.getEnabled()) {\n            return;\n        }\n        const intersection = pointer.getIntersection();\n        const isPointerDown = computeIsPointerDown(intersection, options.downRadius ?? defaultTouchPointerOptions.downRadius);\n        if (isPointerDown === wasPointerDown) {\n            return;\n        }\n        const nativeEvent = { timeStamp: performance.now(), button: options.button ?? defaultTouchPointerOptions.button };\n        if (isPointerDown) {\n            pointer.down(nativeEvent);\n        }\n        else {\n            pointer.up(nativeEvent);\n        }\n        wasPointerDown = isPointerDown;\n    };\n}\nfunction computeIsPointerDown(intersection, downRadius) {\n    if (intersection == null) {\n        return false;\n    }\n    return intersection.distance <= downRadius;\n}\n", "let pointerIdCounter = 23412;\nexport function generateUniquePointerId() {\n    return pointerIdCounter++;\n}\nexport * from './grab.js';\nexport * from './ray.js';\nexport * from './touch.js';\n", "import { Quaternion, Vector2, Vector3 } from 'three';\nimport { Pointer } from './pointer.js';\nimport { PointerEvent } from './event.js';\nimport { intersectRayFromCamera } from './intersections/ray.js';\nimport { generateUniquePointerId } from './pointer/index.js';\nconst vectorHelper = new Vector3();\nconst vector2Helper = new Vector2();\nconst quaternionHelper = new Quaternion();\nfunction htmlEventToCoords(element, e, target) {\n    if (!(e instanceof globalThis.MouseEvent)) {\n        return target.set(0, 0);\n    }\n    const { width, height, top, left } = element.getBoundingClientRect();\n    const x = e.pageX - left;\n    const y = e.pageY - top;\n    return target.set((x / width) * 2 - 1, -(y / height) * 2 + 1);\n}\n/**\n * sets the `pointerTypePrefix` to `\"screen-\"`. Therefore, a event with pointerType `touch` is forwarded to the scene as `\"screen-touch\"`\n */\nexport function forwardHtmlEvents(fromElement, toCamera, toScene, options) {\n    return forwardEvents(fromElement, toCamera, toScene, htmlEventToCoords.bind(null, fromElement), fromElement.setPointerCapture.bind(fromElement), fromElement.releasePointerCapture.bind(fromElement), {\n        pointerTypePrefix: 'screen-',\n        ...options,\n    });\n}\nfunction portalEventToCoords(e, target) {\n    if (!(e instanceof PointerEvent)) {\n        return target.set(0, 0);\n    }\n    if (e.uv == null) {\n        return target.set(0, 0);\n    }\n    target.copy(e.uv).multiplyScalar(2).addScalar(-1);\n    return target;\n}\nexport function forwardObjectEvents(fromPortal, toCamera, toScene, options) {\n    return forwardEvents(fromPortal, toCamera, toScene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);\n}\n/**\n * @returns cleanup function\n */\nfunction forwardEvents(from, toCamera, toScene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {\n    const forwardPointerCapture = options?.forwardPointerCapture ?? true;\n    const pointerMap = new Map();\n    const pointerTypePrefix = options.pointerTypePrefix ?? 'forward-';\n    const getInnerPointer = ({ pointerId = -1, pointerType = 'mouse', pointerState }) => {\n        let innerPointer = pointerMap.get(pointerId);\n        if (innerPointer != null) {\n            return innerPointer;\n        }\n        pointerType = `${pointerTypePrefix}${pointerType}`;\n        const computeIntersection = (scene, nativeEvent, pointerCapture) => intersectRayFromCamera(toCamera, toCoords(nativeEvent, vector2Helper), toCamera.getWorldPosition(vectorHelper), toCamera.getWorldQuaternion(quaternionHelper), scene, pointerId, pointerType, pointerState, pointerCapture, options);\n        pointerMap.set(pointerId, (innerPointer = new Pointer(generateUniquePointerId(), pointerType, pointerState, computeIntersection, undefined, forwardPointerCapture ? setPointerCapture.bind(null, pointerId) : undefined, forwardPointerCapture ? releasePointerCapture.bind(null, pointerId) : undefined, options)));\n        return innerPointer;\n    };\n    const pointerMoveListener = (e) => getInnerPointer(e).move(toScene, e);\n    const pointerCancelListener = (e) => getInnerPointer(e).cancel(e);\n    const pointerDownListener = (e) => void (hasButton(e) && getInnerPointer(e).down(e));\n    const pointerUpListener = (e) => void (hasButton(e) && getInnerPointer(e).up(e));\n    const pointerLeaveListener = (e) => getInnerPointer(e).exit(e);\n    const wheelListener = (e) => getInnerPointer(e).wheel(toScene, e, false);\n    from.addEventListener('pointermove', pointerMoveListener);\n    from.addEventListener('pointercancel', pointerCancelListener);\n    from.addEventListener('pointerdown', pointerDownListener);\n    from.addEventListener('pointerup', pointerUpListener);\n    from.addEventListener('pointerleave', pointerLeaveListener);\n    from.addEventListener('wheel', wheelListener);\n    return () => {\n        from.removeEventListener('pointermove', pointerMoveListener);\n        from.removeEventListener('pointercancel', pointerCancelListener);\n        from.removeEventListener('pointerdown', pointerDownListener);\n        from.removeEventListener('pointerup', pointerUpListener);\n        from.removeEventListener('pointerleave', pointerLeaveListener);\n        from.removeEventListener('wheel', wheelListener);\n    };\n}\nfunction hasButton(val) {\n    return val.button != null;\n}\n", "export class CombinedPointer {\n    pointers = [];\n    isDefaults = [];\n    enabled = true;\n    register(pointer, isDefault) {\n        this.pointers.push(pointer);\n        this.isDefaults.push(isDefault);\n        return this.unregister.bind(this, pointer);\n    }\n    unregister(pointer) {\n        const index = this.pointers.indexOf(pointer);\n        if (index === -1) {\n            return;\n        }\n        this.isDefaults.splice(index, 1);\n        this.pointers.splice(index, 1);\n    }\n    move(scene, nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        const length = this.pointers.length;\n        if (length === 0) {\n            return;\n        }\n        for (let i = 0; i < length; i++) {\n            this.pointers[i].computeMove(scene, nativeEvent);\n        }\n        let smallestIndex = 0;\n        let smallestDistance = this.pointers[0].getIntersection()?.distance ?? Infinity;\n        for (let i = 1; i < length; i++) {\n            const distance = this.pointers[i].getIntersection()?.distance ?? Infinity;\n            const isDefault = this.isDefaults[i];\n            if ((isDefault && distance === smallestDistance) || distance < smallestDistance) {\n                smallestIndex = i;\n                smallestDistance = distance;\n            }\n        }\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(i === smallestIndex, nativeEvent, false);\n            pointer.commit(nativeEvent);\n        }\n    }\n    setEnabled(enabled, nativeEvent) {\n        this.enabled = enabled;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            this.pointers[i].setEnabled(enabled, nativeEvent);\n        }\n    }\n}\n", "import { BufferAttribute, BufferGeometry } from 'three';\nexport function updateXRMeshGeometry(mesh, geometry) {\n    if (geometry != null && geometry.createdAt != null && geometry.createdAt >= mesh.lastChangedTime) {\n        return geometry;\n    }\n    const newGeometry = new BufferGeometry();\n    newGeometry.setIndex(new BufferAttribute(mesh.indices, 1));\n    newGeometry.setAttribute('position', new BufferAttribute(mesh.vertices, 3));\n    return Object.assign(newGeometry, { creationTime: mesh.lastChangedTime });\n}\n", "import { Box2, BufferGeometry, Shape, ShapeGeometry, Vector2 } from 'three';\nexport function updateXRPlaneGeometry(plane, geometry) {\n    if (geometry != null && geometry.createdAt != null && geometry.createdAt >= plane.lastChangedTime) {\n        return geometry;\n    }\n    return Object.assign(createGeometryFromPolygon(plane.polygon), { createdAt: plane.lastChangedTime });\n}\nconst boxHelper = new Box2();\nconst sizeHelper = new Vector2();\nfunction createGeometryFromPolygon(polygon) {\n    if (polygon.length === 0) {\n        return new BufferGeometry();\n    }\n    const shape = new Shape();\n    const points = polygon.map(({ x, z }) => new Vector2(x, z));\n    //we measure the size and scale & unscale to have normalized UVs for the geometry\n    boxHelper.setFromPoints(points);\n    boxHelper.getSize(sizeHelper);\n    for (const point of points) {\n        point.sub(boxHelper.min);\n        point.divide(sizeHelper);\n    }\n    shape.setFromPoints(points);\n    const geometry = new ShapeGeometry(shape);\n    geometry.scale(sizeHelper.x, sizeHelper.y, 1);\n    geometry.translate(boxHelper.min.x, boxHelper.min.y, 0);\n    geometry.rotateX(Math.PI / 2);\n    return geometry;\n}\n", "import { CylinderGeometry, Matrix4, PlaneGeometry, Quaternion, SphereGeometry, SRGBColorSpace, Texture, Vector3, VideoTexture, WebGLRenderTarget, } from 'three';\nimport { getSpaceFromAncestors } from './space.js';\nconst DefaultCentralAngle = (60 / 180) * Math.PI;\nconst DefaultCentralHorizontalAngle = (60 / 180) * Math.PI;\nconst DefaultLowerVerticalAngle = (-30 / 180) * Math.PI;\nconst DefaultUpperVerticalAngle = (30 / 180) * Math.PI;\nexport function createXRLayer(src, state, xrManager, relativeTo, options, properties) {\n    return src instanceof HTMLVideoElement\n        ? createXRVideoLayer(src, state, relativeTo, options, properties)\n        : createXRNormalLayer(src, state, xrManager, relativeTo, options, properties);\n}\nfunction createXRVideoLayer(src, state, relativeTo, { invertStereo, layout, shape = 'quad' }, properties = {}) {\n    const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    if (space == null) {\n        return undefined;\n    }\n    const transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    const init = {\n        invertStereo,\n        layout,\n        space,\n        transform,\n    };\n    applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);\n    const fnName = `create${capitalize(shape)}Layer`;\n    const layer = state.mediaBinding?.[fnName](src, init);\n    if (layer == null) {\n        return;\n    }\n    updateXRLayerProperties(layer, properties);\n    return layer;\n}\nfunction createXRNormalLayer(src, state, xrManager, relativeTo, { shape = 'quad', ...options }, properties = {}) {\n    const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    if (space == null) {\n        return undefined;\n    }\n    const transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    const init = {\n        ...options,\n        isStatic: !(src instanceof WebGLRenderTarget),\n        textureType: 'texture',\n        viewPixelWidth: options.layout === 'stereo-left-right' ? src.width / 2 : src.width,\n        viewPixelHeight: options.layout === 'stereo-top-bottom' ? src.height / 2 : src.height,\n        space,\n        transform,\n    };\n    applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);\n    const fnName = `create${capitalize(shape)}Layer`;\n    const layer = xrManager.getBinding()?.[fnName](init);\n    if (layer == null) {\n        return;\n    }\n    updateXRLayerProperties(layer, properties);\n    return layer;\n}\nconst matrixHelper = new Matrix4();\nconst vectorHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nconst scaleHelper = new Vector3();\nfunction matrixToRigidTransform(matrix, scaleTarget = scaleHelper) {\n    matrix.decompose(vectorHelper, quaternionHelper, scaleTarget);\n    return new XRRigidTransform({ ...vectorHelper, w: 1.0 }, { ...quaternionHelper });\n}\nexport function setXRLayerRenderTarget(renderer, renderTarget, layerEntry, frame) {\n    if (layerEntry != null && frame != null) {\n        const subImage = renderer.xr.getBinding().getSubImage(layerEntry.layer, frame);\n        renderer.setRenderTargetTextures(renderTarget, subImage.colorTexture);\n    }\n    renderer.setRenderTarget(renderTarget);\n}\nexport function createXRLayerGeometry(shape, properties) {\n    switch (shape) {\n        case 'cylinder':\n            const centralAngle = properties.centralAngle ?? DefaultCentralAngle;\n            return new CylinderGeometry(1, 1, 1, 32, 1, true, Math.PI - centralAngle / 2, centralAngle).scale(-1, 1, 1);\n        case 'equirect': {\n            const centralHorizontalAngle = properties.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;\n            const upperVerticalAngle = properties.upperVerticalAngle ?? DefaultUpperVerticalAngle;\n            return new SphereGeometry(1, 32, 16, -Math.PI / 2 - centralHorizontalAngle / 2, centralHorizontalAngle, Math.PI / 2 - upperVerticalAngle, upperVerticalAngle - (properties.lowerVerticalAngle ?? DefaultLowerVerticalAngle)).scale(-1, 1, 1);\n        }\n        case 'quad':\n            return new PlaneGeometry();\n    }\n}\nfunction capitalize(text) {\n    return `${text[0].toUpperCase()}${text.slice(1)}`;\n}\nexport function updateXRLayerProperties(target, properties = {}) {\n    target.chromaticAberrationCorrection = properties.chromaticAberrationCorrection;\n    target.quality = properties.quality ?? 'default';\n    target.blendTextureSourceAlpha = properties.blendTextureSourceAlpha ?? false;\n    if (target instanceof XRCylinderLayer) {\n        target.centralAngle = properties?.centralAngle ?? DefaultCentralAngle;\n        return;\n    }\n    if (target instanceof XREquirectLayer) {\n        target.centralHorizontalAngle = properties?.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;\n        target.lowerVerticalAngle = properties?.lowerVerticalAngle ?? DefaultLowerVerticalAngle;\n        target.upperVerticalAngle = properties?.upperVerticalAngle ?? DefaultUpperVerticalAngle;\n    }\n}\nexport function setupXRImageLayer(renderer, store, layer, src) {\n    let stop = false;\n    const draw = async () => {\n        const frame = await store.requestFrame();\n        if (stop) {\n            return;\n        }\n        writeContentToXRLayer(renderer, layer, frame, src);\n    };\n    layer.addEventListener('redraw', draw);\n    draw();\n    return () => {\n        stop = true;\n        layer.removeEventListener('redraw', draw);\n    };\n}\nexport async function waitForXRLayerSrcSize(src) {\n    if (src instanceof HTMLImageElement && !src.complete) {\n        await new Promise((resolve) => {\n            const onResolve = () => {\n                resolve();\n                src.removeEventListener('load', onResolve);\n            };\n            src.addEventListener('load', onResolve);\n        });\n    }\n    if (src instanceof HTMLVideoElement && src.readyState < 1) {\n        return new Promise((resolve) => {\n            const onResolve = () => {\n                resolve();\n                src.removeEventListener('loadedmetadata', onResolve);\n            };\n            src.addEventListener('loadedmetadata', onResolve);\n        });\n    }\n}\nexport function getXRLayerSrcTexture(src) {\n    if (src instanceof WebGLRenderTarget) {\n        return src.texture;\n    }\n    const texture = src instanceof HTMLVideoElement ? new VideoTexture(src) : new Texture(src);\n    texture.colorSpace = SRGBColorSpace;\n    texture.needsUpdate = true;\n    return texture;\n}\nfunction writeContentToXRLayer(renderer, layer, frame, content) {\n    const context = renderer.getContext();\n    const subImage = renderer.xr.getBinding().getSubImage(layer, frame);\n    renderer.state.bindTexture(context.TEXTURE_2D, subImage.colorTexture);\n    context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);\n    context.texSubImage2D(context.TEXTURE_2D, 0, 0, 0, content.width, content.height, context.RGBA, context.UNSIGNED_BYTE, content);\n}\nexport function updateXRLayerTransform(state, target, centralAngle, relativeTo) {\n    target.space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    target.transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    applyXRLayerScale(getLayerShape(target), target, centralAngle, scaleHelper);\n}\nfunction applyXRLayerScale(shape, target, centralAngle, scale) {\n    if (shape === 'cylinder') {\n        //0.5 * avg of x and z axis\n        const scaleXZ = (scale.x + scale.z) / 2;\n        const radius = scaleXZ;\n        const layerWidth = radius * (centralAngle ?? DefaultCentralAngle);\n        target.radius = radius;\n        target.aspectRatio = layerWidth / scale.y;\n    }\n    else if (shape === 'quad') {\n        target.width = scale.x / 2;\n        target.height = scale.y / 2;\n    }\n    else {\n        target.radius = (scale.x + scale.y + scale.z) / 3;\n    }\n}\nexport function getLayerShape(layer) {\n    if (layer instanceof XRCylinderLayer) {\n        return 'cylinder';\n    }\n    if (layer instanceof XREquirectLayer) {\n        return 'equirect';\n    }\n    return 'quad';\n}\n", "import { Quaternion, Vector3 } from 'three';\nconst vectorHelper = new Vector3();\nconst directionHelper = new Vector3();\nconst positionHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nexport function isFacingCamera(camera, object, direction, angle) {\n    //compute object world direction -> directionHelper\n    object.getWorldQuaternion(quaternionHelper);\n    directionHelper.copy(direction).applyQuaternion(quaternionHelper);\n    //compute guardToCamera direction (guard - camera) -> vectorHelper\n    object.getWorldPosition(positionHelper);\n    camera.getWorldPosition(vectorHelper);\n    vectorHelper.sub(positionHelper);\n    //compute the angle between guardToCamera and object world direction\n    return vectorHelper.angleTo(directionHelper) < angle / 2;\n}\n", "import { Euler, Mesh, QuadraticBezierCurve3, Quaternion, Vector3, } from 'three';\nimport { MeshLineGeometry, MeshLineMaterial } from 'meshline';\nimport { clamp } from 'three/src/math/MathUtils.js';\n/**\n * marks its children as teleportable\n */\nexport function makeTeleportTarget(root, camera, onTeleport) {\n    root.traverse((object) => (object.userData.teleportTarget = true));\n    const listener = (e) => {\n        if ('point' in e && e.point instanceof Vector3) {\n            const c = typeof camera === 'function' ? camera() : camera;\n            const point = new Vector3().setFromMatrixPosition(c.matrix).negate().setComponent(1, 0).add(e.point);\n            onTeleport(point, e);\n        }\n    };\n    root.addEventListener('pointerup', listener);\n    return () => {\n        root.traverse((object) => (object.userData.teleportTarget = false));\n        root.removeEventListener('pointerup', listener);\n    };\n}\nconst eulerHelper = new Euler(0, 0, 0, 'YXZ');\nconst quaternionHelper = new Quaternion();\n/**\n * @param space\n * @param rayGroup must be placed directly into the scene\n */\nexport function syncTeleportPointerRayGroup(space, rayGroup, deltaTimeMs) {\n    space.matrixWorld.decompose(rayGroup.position, quaternionHelper, rayGroup.scale);\n    eulerHelper.setFromQuaternion(quaternionHelper);\n    eulerHelper.z = 0;\n    eulerHelper.x = clamp(eulerHelper.x - (10 * Math.PI) / 180, -Math.PI / 2, (1.1 * Math.PI) / 4);\n    quaternionHelper.setFromEuler(eulerHelper);\n    rayGroup.quaternion.slerp(quaternionHelper, deltaTimeMs / 100);\n}\n/**\n * check if the object is marked as teleportable\n */\nexport function isTeleportTarget(object) {\n    return object.userData.teleportTarget === true;\n}\nexport function buildTeleportTargetFilter(options = {}) {\n    return (interaction) => {\n        if (!isTeleportTarget(interaction.object)) {\n            return false;\n        }\n        if (options.customFilter != null && !options.customFilter(interaction)) {\n            return false;\n        }\n        return true;\n    };\n}\nexport function createTeleportRayLine() {\n    const curve = new QuadraticBezierCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, -8), new Vector3(0, -20, -15));\n    return curve.getPoints(20);\n}\nexport class TeleportPointerRayModel extends Mesh {\n    multiplier;\n    lineLengths;\n    options = {};\n    constructor(points) {\n        const geometry = new MeshLineGeometry();\n        const float32Array = new Float32Array(points.length * 3);\n        for (let i = 0; i < points.length; i++) {\n            points[i].toArray(float32Array, i * 3);\n        }\n        geometry.setPoints(float32Array);\n        const multiplier = (points.length * 3 - 3) / (points.length * 3 - 1);\n        const material = new MeshLineMaterial({\n            lineWidth: 0.1,\n            resolution: undefined,\n            visibility: multiplier,\n        });\n        super(geometry, material);\n        this.material.transparent = true;\n        this.multiplier = multiplier;\n        this.material = material;\n        this.lineLengths = points.slice(0, -1).map((p, i) => p.distanceTo(points[i + 1]));\n    }\n    update(pointer) {\n        const enabled = pointer.getEnabled();\n        if (!enabled || pointer.getButtonsDown().size === 0) {\n            this.visible = false;\n            return;\n        }\n        this.visible = true;\n        const intersection = pointer.getIntersection();\n        if (intersection?.details.type != 'lines') {\n            this.material.visibility = this.multiplier;\n            return;\n        }\n        const { distanceOnLine, lineIndex } = intersection.details;\n        const lineLength = this.lineLengths[lineIndex];\n        this.material.visibility = (this.multiplier * (lineIndex + distanceOnLine / lineLength)) / this.lineLengths.length;\n        const { color = 'white', opacity = 0.4, size = 0.01 } = this.options;\n        this.material.lineWidth = size;\n        this.material.opacity = typeof opacity === 'function' ? opacity(pointer) : opacity;\n        const resolvedColor = typeof color === 'function' ? color(pointer) : color;\n        if (Array.isArray(resolvedColor)) {\n            this.material.color.set(...resolvedColor);\n        }\n        else {\n            this.material.color.set(resolvedColor);\n        }\n    }\n}\n", "import { Matrix4, Quaternion, Vector3 } from 'three';\nimport { getSpaceFromAncestors } from './internals.js';\nconst matrixHelper = new Matrix4();\nconst vectorHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nexport async function createXRHitTestSource(store, relativeTo, trackableType = ['point', 'plane', 'mesh']) {\n    let offsetRay;\n    let space;\n    let object;\n    const state = store.getState();\n    if (typeof relativeTo === 'string') {\n        const { session } = store.getState();\n        if (session == null) {\n            return undefined;\n        }\n        relativeTo = await session.requestReferenceSpace(relativeTo);\n    }\n    if (relativeTo instanceof XRSpace) {\n        space = relativeTo;\n        object = state.origin;\n    }\n    else {\n        if (state.originReferenceSpace == null) {\n            return undefined;\n        }\n        object = relativeTo;\n        space =\n            getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper) ??\n                state.originReferenceSpace;\n        vectorHelper.setFromMatrixPosition(matrixHelper);\n        const point = { ...vectorHelper };\n        quaternionHelper.setFromRotationMatrix(matrixHelper);\n        vectorHelper.set(0, 0, -1).applyQuaternion(quaternionHelper);\n        const direction = { ...vectorHelper };\n        offsetRay = new XRRay(point, direction);\n    }\n    const source = await store.getState().session?.requestHitTestSource?.({\n        space,\n        entityTypes: Array.isArray(trackableType) ? trackableType : [trackableType],\n        offsetRay,\n    });\n    if (source == null) {\n        return undefined;\n    }\n    return {\n        source,\n        getWorldMatrix: computeWorldMatrixFromXRHitTestResult.bind(null, space, object),\n    };\n}\nexport async function requestXRHitTest(store, relativeTo, trackableType) {\n    const sourceData = await createXRHitTestSource(store, relativeTo, trackableType);\n    if (sourceData == null) {\n        return undefined;\n    }\n    const { source, getWorldMatrix } = sourceData;\n    const frame = await store.requestFrame();\n    const results = frame.getHitTestResults?.(source) ?? [];\n    source.cancel();\n    if (results == null) {\n        return undefined;\n    }\n    return { results, getWorldMatrix };\n}\nfunction computeWorldMatrixFromXRHitTestResult(space, object, target, result) {\n    const pose = result.getPose(space);\n    if (pose == null) {\n        return false;\n    }\n    //target = ObjectMatrixWorld? * HitTestMatrix\n    target.fromArray(pose.transform.matrix);\n    if (object != null) {\n        target.premultiply(object.matrixWorld);\n    }\n    return true;\n}\n", "import { Matrix4, Quaternion, Vector3 } from 'three';\nconst OneVector = new Vector3(1, 1, 1);\nconst ZeroVector = new Vector3(0, 0, 0);\nconst NeutralQuaternion = new Quaternion();\nconst matrixHelper1 = new Matrix4();\nconst matrixHelper2 = new Matrix4();\nconst quaternionHelper = new Quaternion();\nconst positionHelper = new Vector3();\nconst vectorHelper = new Vector3();\nexport async function requestXRAnchor(store, options) {\n    if (options.relativeTo === 'hit-test-result') {\n        return options.hitTestResult.createAnchor?.(new XRRigidTransform(options.offsetPosition == null ? undefined : { ...options.offsetPosition, w: 1 }, options.offsetQuaternion == null ? undefined : { ...options.offsetQuaternion }));\n    }\n    let frame;\n    let space;\n    if (options.relativeTo === 'world') {\n        frame = options.frame ?? (await store.requestFrame());\n        const { origin, originReferenceSpace } = store.getState();\n        if (originReferenceSpace == null) {\n            return undefined;\n        }\n        space = originReferenceSpace;\n        const { worldPosition, worldQuaternion } = options;\n        if (origin != null) {\n            //compute vectorHelper and quaternionHelper in the local space of the origin\n            matrixHelper1.copy(origin.matrixWorld).invert();\n            matrixHelper2.compose(worldPosition, worldQuaternion, OneVector).multiply(matrixHelper1);\n            matrixHelper2.decompose(positionHelper, quaternionHelper, vectorHelper);\n            quaternionHelper.setFromRotationMatrix(matrixHelper2);\n        }\n        else {\n            positionHelper.copy(worldPosition);\n            quaternionHelper.copy(worldQuaternion);\n        }\n    }\n    else {\n        frame = options.frame ?? (await store.requestFrame());\n        space = options.space;\n        const { offsetPosition, offsetQuaternion } = options;\n        positionHelper.copy(offsetPosition ?? ZeroVector);\n        quaternionHelper.copy(offsetQuaternion ?? NeutralQuaternion);\n    }\n    return frame.createAnchor?.(new XRRigidTransform({ ...positionHelper, w: 1 }, { ...quaternionHelper }), space);\n}\n", "import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nexport const DefaultGltfLoader = new GLTFLoader();\nexport const DefaultAssetBasePath = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/';\nexport { isXRInputSourceState, } from './input.js';\nexport * from './visible.js';\nexport * from './pointer/index.js';\nexport * from './vanilla/index.js';\nexport * from './misc.js';\nexport * from './teleport.js';\nexport * from './hit-test.js';\nexport * from './anchor.js';\nexport * from './layer.js';\n", "export function syncAsync(fn, ...fns) {\n    let value = fn();\n    for (const fnEntry of fns) {\n        if (value instanceof Promise) {\n            value = value.then(fnEntry);\n        }\n        else {\n            value = fnEntry(value);\n        }\n    }\n    return value;\n}\n", "import { DefaultAssetBasePath } from '../index.js';\nimport { syncAsync } from './utils.js';\nconst DefaultDefaultControllerProfileId = 'generic-trigger';\nexport class XRControllerLayoutLoader {\n    baseAssetPath;\n    defaultProfileId;\n    //cache\n    profilesListCache;\n    profileCacheMap = new Map();\n    constructor(options) {\n        this.baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;\n        this.defaultProfileId = options?.defaultControllerProfileId ?? DefaultDefaultControllerProfileId;\n    }\n    load(inputSourceProfileIds, handedness) {\n        return syncAsync(\n        //load profile\n        () => this.loadProfile(inputSourceProfileIds), \n        //get controller layout from profile\n        (profile) => {\n            for (const key in profile.layouts) {\n                if (!key.includes(handedness)) {\n                    continue;\n                }\n                return profile.layouts[key];\n            }\n            throw new Error(`No matching layout for \"${handedness}\", in profile ${profile.profileId} with layouts ${Object.keys(profile.layouts).join(', ')}.`);\n        });\n    }\n    //alias for Loader compatibility\n    loadAsync = this.load;\n    loadProfile(inputSourceProfileIds) {\n        return syncAsync(\n        //load profiles list\n        () => this.profilesListCache ??\n            fetchJson(new URL('profilesList.json', this.baseAssetPath).href).then((profilesList) => (this.profilesListCache = profilesList)), \n        //load profile\n        (profilesList) => {\n            const length = inputSourceProfileIds.length;\n            let profileInfo;\n            for (let i = 0; i < length; i++) {\n                profileInfo = profilesList[inputSourceProfileIds[i]];\n                if (profileInfo != null) {\n                    break;\n                }\n            }\n            profileInfo ??= profilesList[this.defaultProfileId];\n            if (profileInfo == null) {\n                throw new Error(`no matching profile found for profiles \"${inputSourceProfileIds.join(', ')}\" in profile list ${JSON.stringify(profilesList)}`);\n            }\n            return this.loadProfileFromPath(profileInfo.path);\n        });\n    }\n    loadProfileFromPath(relativeProfilePath) {\n        const result = this.profileCacheMap.get(relativeProfilePath);\n        if (result != null) {\n            return result;\n        }\n        const absoluteProfilePath = new URL(relativeProfilePath, this.baseAssetPath).href;\n        return fetchJson(absoluteProfilePath).then((profile) => {\n            //overwrite the relative assetPath into an absolute path\n            for (const key in profile.layouts) {\n                const layout = profile.layouts[key];\n                if (layout == null) {\n                    continue;\n                }\n                layout.assetPath = new URL(layout.assetPath, absoluteProfilePath).href;\n            }\n            this.profileCacheMap.set(relativeProfilePath, profile);\n            return profile;\n        });\n    }\n}\nasync function fetchJson(url) {\n    let response = await fetch(url);\n    if (!response.ok) {\n        return Promise.reject(new Error(response.statusText));\n    }\n    return response.json();\n}\n", "import { updateXRControllerGamepadState } from './gamepad.js';\nimport { syncAsync } from './utils.js';\nexport function createXRControllerState(id, inputSource, layoutLoader, events, isPrimary) {\n    return syncAsync(() => layoutLoader.load(inputSource.profiles, inputSource.handedness), (layout) => {\n        const gamepad = {};\n        updateXRControllerGamepadState(gamepad, inputSource, layout);\n        return {\n            id,\n            isPrimary,\n            events,\n            type: 'controller',\n            inputSource,\n            gamepad,\n            layout,\n        };\n    });\n}\nexport function updateXRControllerState({ gamepad, inputSource, layout }) {\n    updateXRControllerGamepadState(gamepad, inputSource, layout);\n}\n", "import { createContext } from 'react';\nexport const xrContext = createContext(undefined);\nexport const xrInputSourceStateContext = createContext(undefined);\nexport const xrSpaceContext = createContext(undefined);\nexport const combinedPointerContext = createContext(undefined);\n", "import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { createXRStore as createXRStoreImpl, } from '@pmndrs/xr/internals';\nimport { useFrame, useThree, useStore as useRootStore } from '@react-three/fiber';\nimport { useContext, useEffect } from 'react';\nimport { useStore } from 'zustand';\nimport { xrContext } from './contexts.js';\nimport { XRElements } from './elements.js';\n/**\n * starting point for each XR application\n * allows to configure the session's features and defaults such as what controllers are rendered and how they can interact with the scene\n * @returns an xr store\n */\nexport function createXRStore(options) {\n    return createXRStoreImpl(options);\n}\n/**\n * core XR component for connectin the xr store with the scene\n * requires the xr store which it will provide to its children\n */\nexport function XR({ children, store }) {\n    store.setWebXRManager(useThree((s) => s.gl.xr));\n    const rootStore = useRootStore();\n    useEffect(() => {\n        let initialCamera;\n        return store.subscribe((state, prevState) => {\n            if (state.session === prevState.session) {\n                return;\n            }\n            //session has changed\n            if (state.session != null) {\n                const { camera, gl } = rootStore.getState();\n                initialCamera = camera;\n                rootStore.setState({ camera: gl.xr.getCamera() });\n                return;\n            }\n            if (initialCamera == null) {\n                //we always were in xr?\n                return;\n            }\n            rootStore.setState({ camera: initialCamera });\n        });\n    }, [rootStore, store]);\n    useFrame((state, _delta, frame) => store.onBeforeFrame(state.scene, state.camera, frame), -1000);\n    useFrame(() => store.onBeforeRender());\n    return (_jsxs(xrContext.Provider, { value: store, children: [_jsx(XRElements, {}), children] }));\n}\n/**\n * hook for getting the xr store from the context\n */\nexport function useXRStore() {\n    const store = useContext(xrContext);\n    if (store == null) {\n        throw new Error(`XR features can only be used inside the <XR> component`);\n    }\n    return store;\n}\n/**\n * hook for reading the state from the xr store\n */\nexport function useXR(selector = (state) => state, equalityFn) {\n    return useStore(useXRStore(), selector, equalityFn);\n}\n", "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { context, reconciler, useStore } from '@react-three/fiber';\nimport { Suspense, useMemo } from 'react';\nimport { xrInputSourceStateContext, xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\nimport { objectToKey } from './utils.js';\nimport { XRSpace } from './space.js';\nimport { resolveInputSourceImplementation } from '@pmndrs/xr/internals';\nimport { useXRSessionVisibilityState } from './hooks.js';\nimport { DefaultXRController, DefaultXRGaze, DefaultXRHand, DefaultXRScreenInput, DefaultXRTransientPointer, } from './default.js';\nimport { shallow } from 'zustand/shallow';\nexport function XRElements({ children }) {\n    const referenceSpace = useXR((xr) => xr.originReferenceSpace);\n    const origin = useXR((xr) => xr.origin);\n    const visible = useXRSessionVisibilityState() === 'visible';\n    const store = useStore();\n    const storeWithOriginAsScene = useMemo(() => Object.assign({}, store, {\n        getState() {\n            return { ...store.getState(), scene: origin };\n        },\n    }), [origin, store]);\n    if (origin == null || referenceSpace == null) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: reconciler.createPortal(_jsx(context.Provider, { value: store, children: _jsxs(xrSpaceContext.Provider, { value: referenceSpace, children: [_jsxs(\"group\", { matrixAutoUpdate: false, visible: visible, children: [_jsx(XRControllers, {}), _jsx(XRHands, {}), _jsx(XRTransientPointers, {}), _jsx(XRGazes, {}), _jsx(XRScreenInputs, {})] }), children] }) }), storeWithOriginAsScene, null) }));\n}\nfunction XRControllers() {\n    const controllerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'controller'), shallow);\n    let Implementation = useXR((xr) => xr.controller);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: controllerStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(XRSpace, { space: state.inputSource.gripSpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? _jsx(ResolvedImpl, {}) : _jsx(DefaultXRController, { ...ResolvedImpl }) }) }) }, state.id));\n        }) }));\n}\nfunction XRHands() {\n    const handStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'hand'), shallow);\n    const Implementation = useXR((xr) => xr.hand);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: handStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(XRSpace, { space: state.inputSource.hand.get('wrist'), children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? _jsx(ResolvedImpl, {}) : _jsx(DefaultXRHand, { ...ResolvedImpl }) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRTransientPointers() {\n    const transientPointerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'transientPointer'), shallow);\n    const Implementation = useXR((xr) => xr.transientPointer);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: transientPointerStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(XRSpace, { space: state.inputSource.targetRaySpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? (_jsx(ResolvedImpl, {})) : (_jsx(DefaultXRTransientPointer, { ...ResolvedImpl })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRGazes() {\n    const gazeStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'gaze'), shallow);\n    const Implementation = useXR((xr) => xr.gaze);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: gazeStates.map((state) => {\n            return (_jsx(XRSpace, { space: state.inputSource.targetRaySpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof Implementation === 'function' ? (_jsx(Implementation, {})) : (_jsx(DefaultXRGaze, { ...spreadable(Implementation) })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRScreenInputs() {\n    const screenInputStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'screenInput'), shallow);\n    const Implementation = useXR((xr) => xr.screenInput);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: screenInputStates.map((state) => {\n            return (_jsx(XRSpace, { space: state.inputSource.targetRaySpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof Implementation === 'function' ? (_jsx(Implementation, {})) : (_jsx(DefaultXRScreenInput, { ...spreadable(Implementation) })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction spreadable(value) {\n    if (value === true) {\n        return undefined;\n    }\n    return value;\n}\n", "let i = 0;\nconst map = new Map();\nexport function objectToKey(object) {\n    let key = map.get(object);\n    if (key == null) {\n        map.set(object, (key = i++));\n    }\n    return key;\n}\n", "import { useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';\nimport { useXR } from './xr.js';\nexport function useHover(ref, onChange) {\n    let setHover;\n    let hover;\n    if (onChange == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const [_hover, _setHover] = useState(false);\n        setHover = _setHover;\n        hover = _hover;\n    }\n    else {\n        setHover = onChange;\n    }\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        const set = new Set();\n        const enter = (e) => {\n            if (set.size === 0) {\n                setHover(true);\n            }\n            set.add(e.pointerId);\n        };\n        const leave = (e) => {\n            set.delete(e.pointerId);\n            if (set.size === 0) {\n                setHover(false);\n            }\n        };\n        current.addEventListener('pointerenter', enter);\n        current.addEventListener('pointerleave', leave);\n        return () => {\n            current.removeEventListener('pointerenter', enter);\n            current.removeEventListener('pointerleave', leave);\n        };\n    }, [ref, setHover]);\n    return hover;\n}\n/**\n * hook for getting the session visibility state\n */\nexport function useXRSessionVisibilityState() {\n    return useXR((xr) => xr.visibilityState);\n}\n/**\n * hook for getting the function to initialize the room capture for scanning the room\n */\nexport function useInitRoomCapture() {\n    return useXR((xr) => xr.session?.initiateRoomCapture?.bind(xr.session));\n}\n/**\n * hook for checking if a session mode is supported\n * @param onError callback executed when an error happens while checking if the session mode is supported\n */\nexport function useSessionModeSupported(mode, onError) {\n    const onErrorRef = useRef(onError);\n    onErrorRef.current = onError;\n    const [subscribe, getSnapshot] = useMemo(() => {\n        let sessionSupported = undefined;\n        return [\n            (onChange) => {\n                let canceled = false;\n                if (navigator.xr == null) {\n                    sessionSupported = false;\n                    return () => { };\n                }\n                navigator.xr\n                    .isSessionSupported(mode)\n                    .then((isSupported) => {\n                    sessionSupported = isSupported;\n                    if (canceled) {\n                        return;\n                    }\n                    onChange();\n                })\n                    .catch((e) => {\n                    if (canceled) {\n                        return;\n                    }\n                    onErrorRef.current?.(e);\n                });\n                return () => (canceled = true);\n            },\n            () => sessionSupported,\n        ];\n    }, [mode]);\n    return useSyncExternalStore(subscribe, getSnapshot);\n}\nexport function useSessionFeatureEnabled(feature) {\n    return useXR(({ session }) => session?.enabledFeatures?.includes(feature) ?? false);\n}\n", "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, createTeleportRayLine, syncTeleportPointerRayGroup, buildTeleportTargetFilter, } from '@pmndrs/xr/internals';\nimport { useRef, Suspense, useContext, useMemo } from 'react';\nimport { XRControllerModel } from './controller.js';\nimport { XRHandModel } from './hand.js';\nimport { CombinedPointer, PointerCursorModel, PointerRayModel, useGrabPointer, usePointerXRInputSourceEvents, useRayPointer, useTouchPointer, } from './pointer.js';\nimport { XRSpace as XRSpaceImpl } from './space.js';\nimport { xrInputSourceStateContext } from './contexts.js';\nimport { TeleportPointerRayModel } from './teleport.js';\nimport { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { useXRInputSourceStateContext } from './input.js';\nexport { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, } from '@pmndrs/xr/internals';\nfunction DefaultXRInputSourceGrabPointer(event, getSpace, options) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`DefaultXRInputSourceGrabPointer can only be used inside a XRInputSource`);\n    }\n    const ref = useRef(null);\n    const pointer = useGrabPointer(ref, state, options);\n    usePointerXRInputSourceEvents(pointer, state.inputSource, event, state.events);\n    const cursorModelOptions = options.cursorModel;\n    return (_jsx(XRSpaceImpl, { ref: ref, space: getSpace(state.inputSource), children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultGrabPointerOpacity, ...spreadable(cursorModelOptions) })) }));\n}\n/**\n * grab pointer for the XRHand\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `cursorModel` properties for configuring how the cursor should look\n * - `radius` the size of the intersection sphere\n */\nexport const DefaultXRHandGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'select', (inputSource) => inputSource.hand.get('index-finger-tip'));\n/**\n * grab pointer for the XRController\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `cursorModel` properties for configuring how the cursor should look\n * - `radius` the size of the intersection sphere\n */\nexport const DefaultXRControllerGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'squeeze', (inputSource) => inputSource.gripSpace);\n/**\n * ray pointer for the XRInputSource\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `radius` the size of the intersection sphere\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n * - `rayModel` properties for configuring how the ray should look\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRInputSourceRayPointer(options) {\n    const state = useXRInputSourceStateContext();\n    const ref = useRef(null);\n    const pointer = useRayPointer(ref, state, options);\n    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);\n    const rayModelOptions = options.rayModel;\n    const cursorModelOptions = options.cursorModel;\n    return (_jsxs(XRSpaceImpl, { ref: ref, space: state.inputSource.targetRaySpace, children: [rayModelOptions !== false && (_jsx(PointerRayModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }));\n}\n/**\n * touch pointer for the XRHand\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `cursorModel` properties for configuring how the cursor should look\n * - `hoverRadius` the size of the intersection sphere\n * - `downRadius` the distance to the touch center to trigger a pointerdown event\n * - `button` the id of the button that is triggered when touching\n */\nexport function DefaultXRHandTouchPointer(options) {\n    const state = useXRInputSourceStateContext('hand');\n    const ref = useRef(null);\n    const pointer = useTouchPointer(ref, state, options);\n    const cursorModelOptions = options.cursorModel;\n    return (_jsx(XRSpaceImpl, { ref: ref, space: state.inputSource.hand.get('index-finger-tip'), children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultTouchPointerOpacity, ...spreadable(cursorModelOptions) })) }));\n}\n/**\n * default controller implementation with grab and ray pointers\n *\n * properties\n * - `model` options for configuring the controller apperance\n * - `grabPointer` options for configuring the grab pointer\n * - `rayPointer` options for configuring the ray pointer\n */\nexport function DefaultXRController(options) {\n    const modelOptions = options.model;\n    const grabPointerOptions = options.grabPointer;\n    const rayPointerOptions = options.rayPointer;\n    const teleportPointerOptions = options.teleportPointer ?? false;\n    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRControllerModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRControllerGrabPointer, { ...spreadable(grabPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions) })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));\n}\n/**\n * default hand implementation with touch, grab and ray pointers\n *\n * properties\n * - `model` options for configuring the hand appearance\n * - `grabPointer` options for configuring the grab pointer\n * - `rayPointer` options for configuring the ray pointer\n * - `touchPointer` options for configuring the touch pointer\n */\nexport function DefaultXRHand(options) {\n    const modelOptions = options.model;\n    const grabPointerOptions = options.grabPointer;\n    const rayPointerOptions = options.rayPointer;\n    const touchPointerOptions = options.touchPointer;\n    const teleportPointerOptions = options.teleportPointer ?? false;\n    const rayPointerRayModelOptions = rayPointerOptions === false ? false : spreadable(rayPointerOptions)?.rayModel;\n    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRHandModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRHandGrabPointer, { ...spreadable(grabPointerOptions) }), touchPointerOptions !== false && _jsx(DefaultXRHandTouchPointer, { ...spreadable(touchPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions), rayModel: rayPointerRayModelOptions === false ? false : { maxLength: 0.2, ...spreadable(rayPointerRayModelOptions) } })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));\n}\n/**\n * default transient-pointer implementation with ray pointer\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRTransientPointer(options) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });\n}\n/**\n * default gaze implementation with ray pointer\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRGaze(options) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });\n}\n/**\n * default screen-input implementation with ray pointer\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n */\nexport function DefaultXRScreenInput(options) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...options, cursorModel: false, rayModel: false });\n}\n/**\n * telport pointer for the XRInputSource\n * emits a downwards bend ray that only interesects with meshes marked as teleportable\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `radius` the size of the intersection sphere\n * - `minDistance` minimal distance to trigger interactions\n * - `direction` the direction of the ray\n * - `rayModel` properties for configuring how the ray should look\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRInputSourceTeleportPointer(options) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`DefaultXRInputSourceRayPointer can only be used inside a XRInputSource`);\n    }\n    const ref = useRef(null);\n    const groupRef = useRef(null);\n    const linePoints = useMemo(() => createTeleportRayLine(), []);\n    const pointer = useRayPointer(groupRef, state, {\n        ...options,\n        linePoints,\n        customFilter: buildTeleportTargetFilter(options),\n    }, 'teleport');\n    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);\n    const rayModelOptions = options.rayModel;\n    const cursorModelOptions = options.cursorModel;\n    const scene = useThree((state) => state.scene);\n    const cursorRef = useRef(null);\n    useFrame((_, delta) => {\n        if (cursorRef.current != null) {\n            cursorRef.current.visible = pointer.getEnabled() && pointer.getButtonsDown().size > 0;\n        }\n        const target = groupRef.current;\n        const source = ref.current;\n        if (target == null || source == null) {\n            return;\n        }\n        syncTeleportPointerRayGroup(source, target, delta * 1000);\n    });\n    return (_jsxs(_Fragment, { children: [_jsx(XRSpaceImpl, { ref: ref, space: state.inputSource.targetRaySpace }), createPortal(_jsxs(\"group\", { ref: groupRef, children: [rayModelOptions !== false && (_jsx(TeleportPointerRayModel, { linePoints: linePoints, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { ref: cursorRef, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }), scene)] }));\n}\nfunction spreadable(value) {\n    if (value === true) {\n        return undefined;\n    }\n    return value;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { suspend } from 'suspend-react';\nimport { configureXRControllerModel, createUpdateXRControllerVisuals, loadXRControllerModel, } from '@pmndrs/xr/internals';\nimport { createPortal, useFrame } from '@react-three/fiber';\nimport { useXRInputSourceStateContext } from './input.js';\n/**\n * component for placing content in the controller anchored at a specific component such as the Thumbstick\n *\n * properties\n * - `id` is the id of the component (e.g. `\"a-button\"`)\n * - `onPress` is an optional callback to receive when the component is pressed\n * - `onRelease` is an optional callback to receive when the component is released\n *\n * the component allows children to be placed inside for e.g. visualizing a tooltip over the button/...\n */\nexport const XRControllerComponent = forwardRef(({ id, children, onPress, onRelease }, ref) => {\n    const state = useXRInputSourceStateContext('controller');\n    const [object, setObject] = useState(undefined);\n    useImperativeHandle(ref, () => object, [object]);\n    useXRControllerButtonEvent(state, id, (state) => (state === 'pressed' ? onPress?.() : onRelease?.()));\n    useFrame(() => setObject(state.gamepad[id]?.object));\n    if (object == null) {\n        return;\n    }\n    return createPortal(children, object);\n});\n/**\n * hook for subscribing to a button state change event on the controller\n * @param id of the button\n * @param onChange callback that gets executed when the state of the button changes\n * @param handedness of the controller\n */\nexport function useXRControllerButtonEvent(controller, id, onChange) {\n    const state = useRef();\n    useFrame(() => {\n        const currentState = controller?.gamepad[id]?.state;\n        if (currentState != null && currentState != state.current) {\n            onChange(currentState);\n        }\n        state.current = currentState;\n    });\n}\nconst LoadXRControllerModelSymbol = Symbol('loadXRControllerModel');\n/**\n * component for rendering a 3D model for the XRController\n *\n * properties\n * - `colorWrite`\n * - `renderOrder`\n */\nexport const XRControllerModel = forwardRef((options, ref) => {\n    const state = useXRInputSourceStateContext('controller');\n    const model = suspend(loadXRControllerModel, [state.layout, undefined, LoadXRControllerModelSymbol]);\n    configureXRControllerModel(model, options);\n    state.object = model;\n    useImperativeHandle(ref, () => model, [model]);\n    const update = useMemo(() => createUpdateXRControllerVisuals(model, state.layout, state.gamepad), [model, state.layout, state.gamepad]);\n    useFrame(update);\n    return _jsx(\"primitive\", { object: model });\n});\n", "import { bindXRInputSourceEvent, } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\nimport { xrInputSourceStateContext } from './contexts.js';\nimport { useContext, useEffect } from 'react';\nexport function useXRInputSourceStates() {\n    return useXR((xr) => xr.inputSourceStates);\n}\nexport function useXRInputSourceState(type, handedness) {\n    return useXR((s) => s.inputSourceStates.find((state) => state.type === type && (handedness == null || state.inputSource.handedness === handedness)));\n}\nexport function useXRInputSourceStateContext(type) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null || (type != null && state.type != type)) {\n        throw new Error(`useXRInputSourceStateContext() can only be used inside a the xr store config`);\n    }\n    return state;\n}\n/**\n * hook for listening to xr input source events\n */\nexport function useXRInputSourceEvent(inputSource, event, fn, deps) {\n    const session = useXR((xr) => xr.session);\n    useEffect(() => {\n        if (session == null || inputSource == null) {\n            return;\n        }\n        return bindXRInputSourceEvent(session, inputSource, event, fn);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [event, inputSource, session, ...deps]);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { cloneXRHandGltf, configureXRHandModel, createUpdateXRHandVisuals, } from '@pmndrs/xr/internals';\nimport { forwardRef, useImperativeHandle, useMemo } from 'react';\nimport { XRSpace, useXRSpace } from './space.js';\nimport { useFrame, useLoader } from '@react-three/fiber';\nimport { useXRInputSourceStateContext } from './input.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n/**\n * component for rendering a 3D model for the XRHand\n *\n * properties\n * - `colorWrite`\n * - `renderOrder`\n */\nexport const XRHandModel = forwardRef((options, ref) => {\n    const state = useXRInputSourceStateContext('hand');\n    const gltf = useLoader(GLTFLoader, state.assetPath);\n    const model = useMemo(() => cloneXRHandGltf(gltf), [gltf]);\n    configureXRHandModel(model, options);\n    useImperativeHandle(ref, () => model, [model]);\n    const referenceSpace = useXRSpace();\n    const update = useMemo(() => createUpdateXRHandVisuals(state.inputSource.hand, model, referenceSpace), [state.inputSource, model, referenceSpace]);\n    useFrame((_state, _delta, frame) => update(frame));\n    return _jsx(\"primitive\", { object: model });\n});\n/**\n * component for placing content in the hand anchored at a specific joint such as the index finger tip\n *\n * properties\n * - `joint` is the name of the joint (e.g. `\"wrist\"`)\n *\n * the component allows children to be placed inside for e.g. visualizing a tooltip over the index finger tip\n */\nexport const XRHandJoint = forwardRef(({ joint, children }, ref) => {\n    const state = useXRInputSourceStateContext('hand');\n    return (_jsx(XRSpace, { ref: ref, space: state.inputSource.hand.get(joint), children: children }));\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\nimport { CombinedPointer as CombinedPointerImpl, createGrabPointer, createRayPointer, createTouchPointer, defaultGrabPointerOptions, defaultRayPointerOptions, defaultTouchPointerOptions, } from '@pmndrs/pointer-events';\nimport { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { PointerCursorMaterial, PointerRayMaterial, bindPointerXRInputSourceEvent, updatePointerCursorModel, updatePointerRayModel, } from '@pmndrs/xr/internals';\nimport { useXR, useXRStore } from './xr.js';\nimport { setupSyncIsVisible } from '@pmndrs/xr';\nimport { combinedPointerContext } from './contexts.js';\n//for checking if `event.pointerState` is from an xr input source\nexport { isXRInputSourceState } from '@pmndrs/xr/internals';\n/**\n * component for combining multiple pointer into one so that only one pointer is active at each time\n */\nexport function CombinedPointer({ children }) {\n    const pointer = useMemo(() => new CombinedPointerImpl(), []);\n    usePointerXRSessionVisibility(pointer);\n    useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);\n    return _jsx(combinedPointerContext.Provider, { value: pointer, children: children });\n}\n/**\n * hook for creating a grab pointer\n */\nexport function useGrabPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    Object.assign(options, defaultGrabPointerOptions, currentOptions);\n    const pointer = useMemo(() => createGrabPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * hook for creating a ray pointer\n */\nexport function useRayPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    Object.assign(options, defaultRayPointerOptions, currentOptions);\n    const pointer = useMemo(() => createRayPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * hook for creating a touch pointer\n */\nexport function useTouchPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    Object.assign(options, defaultTouchPointerOptions, currentOptions);\n    const pointer = useMemo(() => createTouchPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * component for rendering a ray for a pointer\n */\nexport const PointerRayModel = forwardRef((props, ref) => {\n    const material = useMemo(() => new PointerRayMaterial(), []);\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useFrame(() => internalRef.current != null && updatePointerRayModel(internalRef.current, material, props.pointer, props));\n    return (_jsx(\"mesh\", { matrixAutoUpdate: false, renderOrder: props.renderOrder ?? 2, ref: internalRef, material: material, children: _jsx(\"boxGeometry\", {}) }));\n});\n/**\n * component for rendering a cursor for a pointer\n */\nexport const PointerCursorModel = forwardRef((props, ref) => {\n    const material = useMemo(() => new PointerCursorMaterial(), []);\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useFrame(() => internalRef.current != null && updatePointerCursorModel(internalRef.current, material, props.pointer, props));\n    const scene = useThree((s) => s.scene);\n    return createPortal(_jsx(\"mesh\", { renderOrder: props.renderOrder ?? 1, ref: internalRef, matrixAutoUpdate: false, material: material, children: _jsx(\"planeGeometry\", {}) }), scene);\n});\n/**\n * hook for binding the xr session events such as `selectstart` to the provided pointer down/up events\n */\nexport function usePointerXRInputSourceEvents(pointer, inputSource, event, missingEvents) {\n    const session = useXR((xr) => xr.session);\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        return bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents);\n    }, [event, inputSource, pointer, session, missingEvents]);\n}\nfunction useSetupPointer(pointer, makeDefault = false) {\n    const combinedPointer = useContext(combinedPointerContext);\n    if (combinedPointer == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        usePointerXRSessionVisibility(pointer);\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);\n    }\n    else {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEffect(() => combinedPointer.register(pointer, makeDefault), [combinedPointer, pointer, makeDefault]);\n    }\n    useEffect(() => () => pointer.exit({ timeStamp: performance.now() }), [pointer]);\n}\nfunction usePointerXRSessionVisibility(pointer) {\n    const store = useXRStore();\n    useEffect(() => setupSyncIsVisible(store, (visible) => pointer.setEnabled(visible, { timeStamp: performance.now() })), [store, pointer]);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { makeTeleportTarget, TeleportPointerRayModel as TeleportPointerRayModelImpl, } from '@pmndrs/xr';\nimport { useFrame, useStore } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\n/**\n * component that allows to declare its children as teleport targets.\n */\nexport function TeleportTarget({ children, onTeleport, }) {\n    const ref = useRef(null);\n    const teleportRef = useRef(onTeleport);\n    teleportRef.current = onTeleport;\n    const store = useStore();\n    useEffect(() => {\n        if (ref.current == null) {\n            return;\n        }\n        return makeTeleportTarget(ref.current, () => store.getState().camera, (point, event) => teleportRef.current?.(point, event));\n    }, [store]);\n    return (_jsx(\"group\", { pointerEventsType: { allow: 'teleport' }, ref: ref, children: children }));\n}\nexport const TeleportPointerRayModel = forwardRef(({ pointer, linePoints, ...options }, ref) => {\n    const mesh = useMemo(() => new TeleportPointerRayModelImpl(linePoints), [linePoints]);\n    useImperativeHandle(ref, () => mesh, [mesh]);\n    mesh.options = options;\n    useFrame(() => mesh.update(pointer));\n    return _jsx(\"primitive\", { object: mesh });\n});\n", "function shallow$1(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar shallow = (objA, objB) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.\"\n    );\n  }\n  return shallow$1(objA, objB);\n};\n\nexport { shallow as default, shallow$1 as shallow };\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useEffect, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { updateXRMeshGeometry } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\n/**\n * component for rendering a mesh for the XRMesh based on the detected mesh geometry\n */\nexport const XRMeshModel = forwardRef(({ mesh, ...rest }, ref) => {\n    const geometry = useXRMeshGeometry(mesh);\n    return _jsx(\"mesh\", { ref: ref, geometry: geometry, ...rest });\n});\n/**\n * hook for getting all dected meshes with the provided semantic label\n */\nexport function useXRMeshes(semanticLabel) {\n    const meshes = useXR((xr) => xr.detectedMeshes);\n    return useMemo(() => (semanticLabel == null ? meshes : meshes.filter((mesh) => mesh.semanticLabel === semanticLabel)), [meshes, semanticLabel]);\n}\n/**\n * hook for getting the geometry from the detected mesh\n * @param mesh the detected mesh\n * @param disposeBuffer allows to disable auto disposing the geometry buffer\n */\nexport function useXRMeshGeometry(mesh, disposeBuffer = true) {\n    const [geometry, setGeometry] = useState(updateXRMeshGeometry(mesh, undefined));\n    useFrame(() => setGeometry((geometry) => updateXRMeshGeometry(mesh, geometry)));\n    useEffect(() => {\n        if (!disposeBuffer) {\n            return;\n        }\n        return () => geometry.dispose();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [geometry]);\n    return geometry;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useEffect, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { updateXRPlaneGeometry } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\n/**\n * component for rendering a mesh for the XRPlane based on the detected plane geometry\n */\nexport const XRPlaneModel = forwardRef(({ plane, ...rest }, ref) => {\n    const geometry = useXRPlaneGeometry(plane);\n    return _jsx(\"mesh\", { ref: ref, geometry: geometry, ...rest });\n});\n/**\n * hook for getting all dected planes with the provided semantic label\n */\nexport function useXRPlanes(semanticLabel) {\n    const planes = useXR((xr) => xr.detectedPlanes);\n    return useMemo(() => (semanticLabel == null ? planes : planes.filter((plane) => plane.semanticLabel === semanticLabel)), [planes, semanticLabel]);\n}\n/**\n * hook for getting the geometry from the detected plane\n * @param plane the detected plane\n * @param disposeBuffer allows to disable auto disposing the geometry buffer\n */\nexport function useXRPlaneGeometry(plane, disposeBuffer = true) {\n    const [geometry, setGeometry] = useState(updateXRPlaneGeometry(plane, undefined));\n    useFrame(() => setGeometry((geometry) => updateXRPlaneGeometry(plane, geometry)));\n    useEffect(() => {\n        if (!disposeBuffer) {\n            return;\n        }\n        return () => geometry.dispose();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [geometry]);\n    return geometry;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { isFacingCamera } from '@pmndrs/xr';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { useRef, useState } from 'react';\nfunction useIsFacingCamera(ref, set, direction, angle) {\n    const camera = useThree((state) => state.camera);\n    useFrame(() => {\n        if (ref.current == null) {\n            return;\n        }\n        set(isFacingCamera(camera, ref.current, direction, angle));\n    });\n}\n/**\n * guard that only shows its shildren if the camera towards the object based on the provided angle and direction\n */\nexport function ShowIfFacingCamera({ children, direction, angle = Math.PI / 2, }) {\n    const ref = useRef(null);\n    useIsFacingCamera(ref, (visible) => {\n        if (ref.current == null) {\n            return;\n        }\n        ref.current.visible = visible;\n    }, direction, angle);\n    return _jsx(\"group\", { ref: ref, children: children });\n}\n/**\n * guard that only renders its shildren if the camera towards the object based on the provided angle and direction\n */\nexport function IfFacingCamera({ children, direction, angle = Math.PI / 2, }) {\n    const ref = useRef(null);\n    const [show, setShow] = useState(false);\n    useIsFacingCamera(ref, setShow, direction, angle);\n    return show ? _jsx(_Fragment, { children: children }) : null;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXR } from '../index.js';\nfunction useIsInSessionMode(allow, deny) {\n    const mode = useXR((state) => state.mode);\n    if (deny != null) {\n        return Array.isArray(deny) ? !deny.includes(mode) : deny != mode;\n    }\n    if (allow != null) {\n        return Array.isArray(allow) ? allow.includes(mode) : allow === mode;\n    }\n    return true;\n}\n/**\n * guard that shows its children based on the current session mode\n */\nexport function ShowIfInSessionMode({ children, allow, deny, }) {\n    const visible = useIsInSessionMode(allow, deny);\n    return _jsx(\"group\", { visible: visible, children: children });\n}\n/**\n * guard that renders its children based on the current session mode\n */\nexport function IfInSessionMode({ children, allow, deny, }) {\n    const visible = useIsInSessionMode(allow, deny);\n    return visible ? _jsx(_Fragment, { children: children }) : null;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useSessionModeSupported } from '../index.js';\n/**\n * guard that only show its children if the session mode is supported\n */\nexport function ShowIfSessionModeSupported({ children, mode }) {\n    const supported = useSessionModeSupported(mode);\n    return _jsx(\"group\", { visible: supported, children: children });\n}\n/**\n * guard that only renders its visible if the session mode is supported\n */\nexport function IfSessionModeSupported({ children, mode }) {\n    const supported = useSessionModeSupported(mode);\n    if (!supported) {\n        return null;\n    }\n    return _jsx(_Fragment, { children: children });\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXRSessionVisibilityState } from '../index.js';\n/**\n * guard that only makes its children visible when the session is not blurred or when not in a session\n */\nexport function ShowIfSessionVisible({ children }) {\n    const state = useXRSessionVisibilityState();\n    return _jsx(\"group\", { visible: state == null || state === 'visible', children: children });\n}\n/**\n * guard that only renders its children when the session is not blurred or when not in a session\n */\nexport function IfSessionVisible({ children }) {\n    const state = useXRSessionVisibilityState();\n    if (state != 'visible' && state != null) {\n        return null;\n    }\n    return _jsx(_Fragment, { children: children });\n}\n", "import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useThree } from '@react-three/fiber';\nimport { forwardRef } from 'react';\nimport { xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\n/**\n * component for setting the origin of the player (their feet)\n */\nexport const XROrigin = forwardRef(({ children, ...props }, ref) => {\n    const xrCamera = useThree((s) => s.gl.xr.getCamera());\n    const referenceSpace = useXR((xr) => xr.originReferenceSpace);\n    if (referenceSpace == null) {\n        return null;\n    }\n    return (_jsxs(\"group\", { ref: ref, ...props, children: [_jsx(\"primitive\", { object: xrCamera }), _jsx(xrSpaceContext.Provider, { value: referenceSpace, children: children })] }));\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { createXRHitTestSource, requestXRHitTest } from '@pmndrs/xr';\nimport { useXRStore } from './xr.js';\nimport { useFrame } from '@react-three/fiber';\nexport { createXRHitTestSource, requestXRHitTest } from '@pmndrs/xr';\n/**\n * hook for creating a hit test source originating from the provided object or xrspace\n */\nexport function useXRHitTestSource(relativeTo, trackableType) {\n    const [source, setState] = useState();\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useCreateXRHitTestSource(relativeTo, trackableType, setState);\n    return source;\n}\n/**\n * hook for setting up a continous hit test originating from the provided object or xrspace\n */\nexport function useXRHitTest(fn, relativeTo, trackableType) {\n    const sourceRef = useRef(undefined);\n    useCreateXRHitTestSource(relativeTo, trackableType, useCallback((source) => (sourceRef.current = source), []));\n    useFrame((_s, _d, frame) => {\n        if (fn == null || frame == null || sourceRef.current == null) {\n            return;\n        }\n        fn(frame.getHitTestResults(sourceRef.current.source), sourceRef.current.getWorldMatrix);\n    });\n}\nfunction useCreateXRHitTestSource(relativeTo, trackableType, onLoad) {\n    const store = useXRStore();\n    useEffect(() => {\n        let storedResult;\n        let cancelled = false;\n        const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === 'string' ? relativeTo : relativeTo?.current;\n        if (relativeToResolved == null) {\n            return;\n        }\n        createXRHitTestSource(store, relativeToResolved, trackableType).then((result) => {\n            if (cancelled) {\n                return;\n            }\n            storedResult = result;\n            onLoad(result);\n        });\n        return () => {\n            onLoad(undefined);\n            cancelled = true;\n            storedResult?.source.cancel();\n        };\n    }, [store, relativeTo, trackableType, onLoad]);\n}\n/**\n * hook that returns a function to request a single hit test\n */\nexport function useXRRequestHitTest() {\n    const store = useXRStore();\n    return useCallback((relativeTo, trackableType) => {\n        const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === 'string' ? relativeTo : relativeTo.current;\n        if (relativeToResolved == null) {\n            return;\n        }\n        return requestXRHitTest(store, relativeToResolved, trackableType);\n    }, [store]);\n}\n/**\n * component for getting hit tests originating based on its position in the scene graph\n */\nexport const XRHitTest = forwardRef(({ trackableType, onResults, space, ...rest }, ref) => {\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current);\n    useXRHitTest(onResults, space ?? internalRef, trackableType);\n    return _jsx(\"group\", { ...rest, ref: internalRef });\n});\n", "import { requestXRAnchor } from '@pmndrs/xr';\nimport { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { useXRStore } from './xr.js';\nexport { requestXRAnchor,\n//requestXRPersistentAnchor,\n//loadXRPersistentAnchor,\n//deleteXRPersistentAnchor,\n } from '@pmndrs/xr';\n/**\n * hook that returns a function that allows to request a xr anchor\n */\nexport function useRequestXRAnchor() {\n    const store = useXRStore();\n    return useMemo(() => requestXRAnchor.bind(null, store), [store]);\n}\n/**\n * hook that returns a function that allows to request a xr persistent anchor\n *\nexport function useRequestXRPersistentAnchor() {\n  const store = useXRStore()\n  return useMemo(() => requestXRPersistentAnchor.bind(null, store), [store])\n}*/\n/**\n * hook that returns a function that allows to load a xr persistent anchor\n *\nexport function useLoadXRPersistentAnchor() {\n  const session = useXR((xr) => xr.session)\n  return useMemo(() => (session != null ? loadXRPersistentAnchor.bind(null, session) : undefined), [session])\n}*/\n/**\n * hook that returns a function that allows to delete a xr persistent anchor\n *\nexport function useDeleteXRPersistentAnchor() {\n  const store = useXRStore()\n  return useMemo(() => deleteXRPersistentAnchor.bind(null, store), [store])\n}*/\n/*\nexport function useXRPersistentAnchor(\n  id: string,\n): [anchor: XRAnchor | undefined, createAnchor: (options: XRAnchorOptions) => Promise<XRAnchor | undefined>] {\n  const cleanup = useRef<(() => void) | undefined>(() => {})\n  const store = useXRStore()\n  const session = useXR((xr) => xr.session)\n  const [anchor, setAnchor] = useState<XRAnchor | undefined>(undefined)\n  useEffect(() => {\n    if (session == null) {\n      return\n    }\n    cleanup.current?.()\n    cleanup.current = undefined\n    let cancelled = false\n    cleanup.current = () => (cancelled = true)\n    loadXRPersistentAnchor(session, id).then((anchor) => {\n      if (cancelled) {\n        anchor?.delete()\n        return\n      }\n      cleanup.current = () => anchor?.delete()\n      setAnchor(anchor)\n    })\n    return () => {\n      cleanup.current?.()\n      cleanup.current = undefined\n    }\n  }, [session, id])\n  const create = useCallback(\n    async (options: XRAnchorOptions) => {\n      await deleteXRPersistentAnchor(store, id)\n      cleanup.current?.()\n      cleanup.current = undefined\n      const abortRef = { current: false }\n      cleanup.current = () => (abortRef.current = true)\n      const anchor = await requestXRPersistentAnchor(store, id, options, abortRef)\n      if (abortRef.current) {\n        anchor?.delete()\n        return undefined\n      }\n      cleanup.current = () => anchor?.delete()\n      setAnchor(anchor)\n      return anchor\n    },\n    [id, store],\n  )\n  return [anchor, create]\n}*/\n/**\n * hook for requesting and storing a single xr anchor\n */\nexport function useXRAnchor() {\n    const [anchor, setAnchor] = useState(undefined);\n    const cleanup = useRef(() => { });\n    const store = useXRStore();\n    const create = useCallback(async (options) => {\n        cleanup.current?.();\n        cleanup.current = undefined;\n        let cancelled = false;\n        cleanup.current = () => (cancelled = true);\n        const anchor = await requestXRAnchor(store, options);\n        if (cancelled) {\n            anchor?.delete();\n            return undefined;\n        }\n        cleanup.current = () => anchor?.delete();\n        setAnchor(anchor);\n        return anchor;\n    }, [store]);\n    useEffect(() => () => void cleanup.current?.(), []);\n    return [anchor, create];\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useXR } from './xr.js';\nimport { forwardRef, useEffect, useMemo } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport tunnel from 'tunnel-rat';\n/**\n * component to render html elements as overlay for handheld AR experiences\n */\nexport const XRDomOverlay = forwardRef((props, ref) => {\n    const domOverlayRoot = useXR((xr) => xr.domOverlayRoot);\n    const { In, Out } = useMemo(tunnel, []);\n    useEffect(() => {\n        const root = createRoot(domOverlayRoot);\n        root.render(_jsx(Out, {}));\n        return () => root.unmount();\n    }, [domOverlayRoot, Out]);\n    return (_jsx(In, { children: _jsx(\"div\", { ...props, ref: ref }) }));\n});\n", "import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { createXRLayerGeometry, updateXRLayerProperties, updateXRLayerTransform, createXRLayer, waitForXRLayerSrcSize, getXRLayerSrcTexture, setupXRImageLayer, setXRLayerRenderTarget, } from '@pmndrs/xr';\nimport { context, reconciler, useFrame, useStore, useThree, } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState, } from 'react';\nimport { useSessionFeatureEnabled } from './hooks.js';\nimport { useXRStore } from './xr.js';\nimport { DepthTexture, HalfFloatType, LinearFilter, OrthographicCamera, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3, WebGLRenderTarget, } from 'three';\nimport { create } from 'zustand';\nimport { forwardObjectEvents } from '@pmndrs/pointer-events';\nexport function XRLayer({ src, pixelWidth = 1024, pixelHeight = 1024, renderPriority = 0, children, ...props }) {\n    const [hasSize, setHasSize] = useState(false);\n    const ref = useRef(null);\n    const renderTargetRef = useRef(undefined);\n    const layerEntryRef = useRef(undefined);\n    useEffect(() => {\n        setHasSize(false);\n        let aborted = false;\n        waitForXRLayerSrcSize(src).then(() => !aborted && setHasSize(true));\n        return () => void (aborted = true);\n    }, [src]);\n    const layersEnabled = useSessionFeatureEnabled('layers');\n    const geometry = useMemo(() => createXRLayerGeometry(props.shape ?? 'quad', {\n        centralAngle: props.centralAngle,\n        centralHorizontalAngle: props.centralHorizontalAngle,\n        lowerVerticalAngle: props.lowerVerticalAngle,\n        upperVerticalAngle: props.upperVerticalAngle,\n    }), [props.centralAngle, props.centralHorizontalAngle, props.lowerVerticalAngle, props.shape, props.upperVerticalAngle]);\n    const store = useLayerStore(pixelWidth, pixelHeight);\n    useForwardEvents(store, ref, [hasSize, layersEnabled]);\n    if (!hasSize) {\n        return null;\n    }\n    return (_jsxs(_Fragment, { children: [src == null && (_jsx(ChildrenToRenderTarget, { store: store, renderPriority: renderPriority, renderTargetRef: renderTargetRef, layerEntryRef: layersEnabled ? layerEntryRef : undefined, children: children })), layersEnabled ? (_jsx(XRLayerImplementation, { renderTargetRef: renderTargetRef, layerEntryRef: layerEntryRef, pixelWidth: pixelWidth, pixelHeight: pixelHeight, ref: ref, ...props, src: src, geometry: geometry })) : (_jsx(FallbackXRLayerImplementation, { renderTargetRef: renderTargetRef, ref: ref, ...props, src: src, pixelWidth: pixelWidth, pixelHeight: pixelHeight, geometry: geometry }))] }));\n}\nexport const XRLayerImplementation = forwardRef(({ src, shape, colorFormat, depthFormat, layout, mipLevels, renderOrder = 0, blendTextureSourceAlpha, centralAngle, centralHorizontalAngle, chromaticAberrationCorrection, lowerVerticalAngle, quality, upperVerticalAngle, invertStereo, pixelWidth, pixelHeight, renderTargetRef, layerEntryRef, ...props }, ref) => {\n    const internalRef = useRef(null);\n    const renderer = useThree((state) => state.gl);\n    const store = useXRStore();\n    const layerProperties = {\n        blendTextureSourceAlpha,\n        centralAngle,\n        centralHorizontalAngle,\n        chromaticAberrationCorrection,\n        lowerVerticalAngle,\n        quality,\n        upperVerticalAngle,\n    };\n    const layerPropertiesRef = useRef(layerProperties);\n    layerPropertiesRef.current = layerProperties;\n    const renderOrderRef = useRef(renderOrder);\n    renderOrderRef.current = renderOrder;\n    //create layer\n    useEffect(() => {\n        if (internalRef.current == null) {\n            return;\n        }\n        const resolvedSrc = src ?? createXRLayerRenderTarget(pixelWidth, pixelHeight, renderTargetRef);\n        const layer = createXRLayer(resolvedSrc, store.getState(), renderer.xr, internalRef.current, {\n            colorFormat,\n            depthFormat,\n            invertStereo,\n            layout,\n            mipLevels,\n            shape,\n        }, layerPropertiesRef.current);\n        if (layer == null) {\n            return;\n        }\n        const layerEntry = (layerEntryRef.current = { layer, renderOrder: renderOrderRef.current });\n        store.addLayerEntry(layerEntry);\n        if (resolvedSrc instanceof HTMLVideoElement || resolvedSrc instanceof WebGLRenderTarget) {\n            return () => {\n                store.removeLayerEntry(layerEntry);\n                layer.destroy();\n            };\n        }\n        const cleanupXRImageLayer = setupXRImageLayer(renderer, store, layer, resolvedSrc);\n        return () => {\n            store.removeLayerEntry(layerEntry);\n            cleanupXRImageLayer();\n            layer.destroy();\n        };\n    }, [\n        colorFormat,\n        depthFormat,\n        invertStereo,\n        layerEntryRef,\n        layout,\n        mipLevels,\n        pixelHeight,\n        pixelWidth,\n        renderTargetRef,\n        renderer,\n        shape,\n        src,\n        store,\n    ]);\n    //update render order\n    if (layerEntryRef.current != null) {\n        layerEntryRef.current.renderOrder = renderOrder;\n    }\n    //update layer properties\n    if (layerEntryRef.current != null) {\n        updateXRLayerProperties(layerEntryRef.current.layer, layerPropertiesRef.current);\n    }\n    //update layer transform\n    useFrame(() => {\n        if (layerEntryRef.current == null || internalRef.current == null) {\n            return;\n        }\n        updateXRLayerTransform(store.getState(), layerEntryRef.current.layer, layerPropertiesRef.current.centralAngle, internalRef.current);\n    });\n    useImperativeHandle(ref, () => internalRef.current, []);\n    return (_jsx(\"mesh\", { ...props, renderOrder: -Infinity, ref: internalRef, children: _jsx(\"meshBasicMaterial\", { colorWrite: false }) }));\n});\nexport const FallbackXRLayerImplementation = forwardRef(({ src, renderTargetRef, renderOrder, pixelWidth, pixelHeight, ...props }, ref) => {\n    const materialRef = useRef(null);\n    useEffect(() => {\n        if (materialRef.current == null) {\n            return;\n        }\n        const resolvedSrc = src ?? createXRLayerRenderTarget(pixelWidth, pixelHeight, renderTargetRef);\n        const texture = getXRLayerSrcTexture(resolvedSrc);\n        materialRef.current.map = texture;\n        materialRef.current.needsUpdate = true;\n        return () => {\n            if (resolvedSrc instanceof WebGLRenderTarget) {\n                resolvedSrc.dispose();\n                return;\n            }\n            texture.dispose();\n        };\n    }, [src, pixelWidth, pixelHeight, renderTargetRef]);\n    return (_jsx(\"mesh\", { ref: ref, ...props, children: _jsx(\"meshBasicMaterial\", { ref: materialRef, toneMapped: false }) }));\n});\nfunction createXRLayerRenderTarget(pixelWidth, pixelHeight, renderTargetRef) {\n    return (renderTargetRef.current = new WebGLRenderTarget(pixelWidth, pixelHeight, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        type: HalfFloatType,\n        depthTexture: new DepthTexture(pixelWidth, pixelHeight),\n    }));\n}\nfunction useForwardEvents(store, ref, deps) {\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        let cleanup;\n        const update = (state, prevState) => {\n            if (state.camera === prevState?.camera && state.scene === prevState.scene) {\n                return;\n            }\n            cleanup?.();\n            cleanup = forwardObjectEvents(current, state.camera, state.scene);\n        };\n        update(store.getState());\n        const unsubscribe = store.subscribe(update);\n        return () => {\n            unsubscribe();\n            cleanup?.();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [store, ref, ...deps]);\n}\n// Keys that shouldn't be copied between R3F stores\nexport const privateKeys = [\n    'set',\n    'get',\n    'setSize',\n    'setFrameloop',\n    'setDpr',\n    'events',\n    'invalidate',\n    'advance',\n    'size',\n    'viewport',\n];\nexport function useLayerStore(width, height) {\n    const previousRoot = useStore();\n    const layerStore = useMemo(() => {\n        let previousState = previousRoot.getState();\n        // We have our own camera in here, separate from the main scene.\n        const camera = new PerspectiveCamera(50, 1, 0.1, 1000);\n        camera.position.set(0, 0, 5);\n        const pointer = new Vector2();\n        let ownState = {\n            events: { enabled: false, priority: 0 },\n            size: { width: 1, height: 1, left: 0, top: 0 },\n            camera,\n            scene: new Scene(),\n            raycaster: new Raycaster(),\n            pointer: pointer,\n            mouse: pointer,\n            previousRoot,\n        };\n        //we now merge in order previousState, injectState, ownState\n        const store = create((innerSet, get) => {\n            const merge = () => {\n                const result = {};\n                for (const key in previousState) {\n                    if (privateKeys.includes(key)) {\n                        continue;\n                    }\n                    result[key] = previousState[key];\n                }\n                return Object.assign(result, ownState, {\n                    events: { ...previousState.events, ...ownState.events },\n                    viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector3(), ownState.size)),\n                });\n            };\n            const update = () => innerSet(merge());\n            return {\n                ...previousState,\n                // Set and get refer to this root-state\n                set(newOwnState) {\n                    if (typeof newOwnState === 'function') {\n                        newOwnState = newOwnState(get());\n                    }\n                    Object.assign(ownState, newOwnState);\n                    update();\n                },\n                setPreviousState(prevState) {\n                    previousState = prevState;\n                    update();\n                },\n                get,\n                setEvents() { },\n                ...merge(),\n            };\n        });\n        return Object.assign(store, {\n            setState(state) {\n                store.getState().set(state);\n            },\n        });\n    }, [previousRoot]);\n    //syncing up previous store with the current store\n    useEffect(() => previousRoot.subscribe(layerStore.getState().setPreviousState), [previousRoot, layerStore]);\n    useEffect(() => layerStore.setState({\n        size: { width, height, top: 0, left: 0 },\n        viewport: { ...previousRoot.getState().viewport, width, height, aspect: width / height },\n    }), [width, height, layerStore, previousRoot]);\n    return layerStore;\n}\nfunction ChildrenToRenderTarget({ renderPriority, children, layerEntryRef, renderTargetRef, store, }) {\n    useEffect(() => {\n        const update = (state, prevState) => {\n            const { size, camera } = state;\n            if (camera instanceof OrthographicCamera) {\n                camera.left = size.width / -2;\n                camera.right = size.width / 2;\n                camera.top = size.height / 2;\n                camera.bottom = size.height / -2;\n            }\n            else {\n                camera.aspect = size.width / size.height;\n            }\n            if (size !== prevState?.size || camera !== prevState.camera) {\n                camera.updateProjectionMatrix();\n                // https://github.com/pmndrs/react-three-fiber/issues/178\n                // Update matrix world since the renderer is a frame late\n                camera.updateMatrixWorld();\n            }\n        };\n        update(store.getState());\n        return store.subscribe(update);\n    }, [store]);\n    let oldAutoClear;\n    let oldXrEnabled;\n    let oldIsPresenting;\n    let oldRenderTarget;\n    useFrame((_state, _delta, frame) => {\n        if (renderTargetRef.current == null ||\n            (layerEntryRef != null && (layerEntryRef.current == null || frame == null))) {\n            return;\n        }\n        const { gl, scene, camera } = store.getState();\n        oldAutoClear = gl.autoClear;\n        oldXrEnabled = gl.xr.enabled;\n        oldIsPresenting = gl.xr.isPresenting;\n        oldRenderTarget = gl.getRenderTarget();\n        gl.autoClear = true;\n        gl.xr.enabled = false;\n        gl.xr.isPresenting = false;\n        const renderTarget = renderTargetRef.current;\n        setXRLayerRenderTarget(gl, renderTarget, layerEntryRef?.current, frame);\n        gl.render(scene, camera);\n        gl.setRenderTarget(oldRenderTarget);\n        gl.autoClear = oldAutoClear;\n        gl.xr.enabled = oldXrEnabled;\n        gl.xr.isPresenting = oldIsPresenting;\n    }, renderPriority);\n    return _jsx(_Fragment, { children: reconciler.createPortal(_jsx(context.Provider, { value: store, children: children }), store, null) });\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef } from 'react';\nimport { useSessionModeSupported } from '../hooks.js';\nimport { useStore } from 'zustand';\n/**\n * @deprecated use <button onClick={() => store.enterXR()}> instead\n */\nexport const XRButton = forwardRef(({ store, mode, onError, children, ...props }, ref) => {\n    const session = useStore(store, (xr) => xr.session);\n    const supported = useSessionModeSupported(mode, onError);\n    return (_jsx(\"button\", { ref: ref, ...props, onClick: () => (session != null ? session.end() : store.enterXR(mode).catch(onError)), children: typeof children === 'function'\n            ? children(supported ? (session != null ? 'entered' : 'exited') : 'unsupported')\n            : children }));\n});\n/**\n * @deprecated use <button onClick={() => store.enterAR()}> instead\n */\nexport const ARButton = forwardRef((props, ref) => {\n    return _jsx(XRButton, { ref: ref, mode: \"immersive-ar\", ...props });\n});\n/**\n * @deprecated use <button onClick={() => store.enterVR()}> instead\n */\nexport const VRButton = forwardRef((props, ref) => {\n    return _jsx(XRButton, { ref: ref, mode: \"immersive-vr\", ...props });\n});\n", "import { useEffect, useRef } from 'react';\nimport { PointerEvent } from '@pmndrs/pointer-events';\nimport { useXR } from '../xr.js';\nimport { useXRInputSourceState, useXRInputSourceStateContext } from '../input.js';\nimport { useXRSpace } from '../space.js';\nconst eventTranslations = {\n    onBlur: 'pointerleave',\n    onHover: 'pointerenter',\n    onMove: 'pointermove',\n    onSelect: {\n        type: 'click',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSelectEnd: {\n        type: 'pointerup',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSelectStart: {\n        type: 'pointerdown',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSqueeze: {\n        type: 'click',\n        filter: (e) => e.pointerType === 'grab',\n    },\n    onSqueezeEnd: {\n        type: 'pointerup',\n        filter: (e) => e.pointerType === 'grab',\n    },\n    onSqueezeStart: {\n        type: 'pointerdown',\n        filter: (e) => e.pointerType === 'grab',\n    },\n};\n/**\n * @deprecated use normal react-three/fiber event listeners instead (e.g. <mesh onClick={...} />)\n */\nexport function useInteraction(ref, type, handler) {\n    const handlerRef = useRef(handler);\n    handlerRef.current = handler;\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        const translation = eventTranslations[type];\n        const fn = typeof translation === 'string'\n            ? (event) => handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState })\n            : (event) => {\n                if (event instanceof PointerEvent && !translation.filter(event)) {\n                    return;\n                }\n                handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState });\n            };\n        const eventName = typeof translation === 'string' ? translation : translation.type;\n        current.addEventListener(eventName, fn);\n        return () => current.removeEventListener(eventName, fn);\n    }, [ref, type]);\n}\n/**\n * @deprecated\n */\nexport function useXREvent(type, handler, { handedness } = {}) {\n    const session = useXR((xr) => xr.session);\n    const handlerRef = useRef(handler);\n    handlerRef.current = handler;\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        const fn = (e) => {\n            handlerRef.current?.({\n                type: e.type,\n                data: e.inputSource,\n            });\n        };\n        session.addEventListener(type, fn);\n        return session.removeEventListener(type, fn);\n    }, [session, handedness, type]);\n}\nexport function useXRTransientPointerState(handedness) {\n    return handedness == null\n        ? // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceStateContext('transientPointer')\n        : // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceState('transientPointer', handedness);\n}\n/**\n * @deprecated use `useXRInputSourceStateContext(\"gaze\")` instead\n * hook for getting the gaze state\n */\nexport function useXRGazeState() {\n    return useXRInputSourceStateContext('gaze');\n}\n/**\n * @deprecated `useXRInputSourceStateContext(\"screenInput\")` instead\n * hook for getting the screen-input state\n */\nexport function useXRScreenInputState() {\n    return useXRInputSourceStateContext('screenInput');\n}\nexport function useXRHandState(handedness) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return handedness == null ? useXRInputSourceStateContext('hand') : useXRInputSourceState('hand', handedness);\n}\nexport function useXRControllerState(handedness) {\n    return handedness == null\n        ? // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceStateContext('controller')\n        : // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceState('controller', handedness);\n}\n/**\n * @deprecated use useXRSpace instead\n */\nexport const useXRReferenceSpace = useXRSpace;\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useRef } from 'react';\nimport { useInteraction } from './hooks.js';\n/**\n * @deprecated just use <group onClick/... />\n */\nexport const Interactive = forwardRef(({ onHover, onBlur, onSelectStart, onSelectEnd, onSelect, onSqueezeStart, onSqueezeEnd, onSqueeze, onMove, children, }, passedRef) => {\n    const ref = useRef(null);\n    useImperativeHandle(passedRef, () => ref.current);\n    useInteraction(ref, 'onHover', onHover);\n    useInteraction(ref, 'onBlur', onBlur);\n    useInteraction(ref, 'onSelectStart', onSelectStart);\n    useInteraction(ref, 'onSelectEnd', onSelectEnd);\n    //useInteraction(ref, 'onSelectMissed', onSelectMissed)\n    useInteraction(ref, 'onSelect', onSelect);\n    useInteraction(ref, 'onSqueezeStart', onSqueezeStart);\n    useInteraction(ref, 'onSqueezeEnd', onSqueezeEnd);\n    //useInteraction(ref, 'onSqueezeMissed', onSqueezeMissed)\n    useInteraction(ref, 'onSqueeze', onSqueeze);\n    useInteraction(ref, 'onMove', onMove);\n    return _jsx(\"group\", { ref: ref, children: children });\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useMemo, useRef } from 'react';\nimport { Interactive } from './interactive.js';\nimport { Matrix4 } from 'three';\nimport { useFrame } from '@react-three/fiber';\nimport { isXRInputSourceState } from '@pmndrs/xr/internals';\n/**\n * @deprecated use DragControls instead\n */\nexport const RayGrab = forwardRef(function RayGrab({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {\n    const grabbingController = useRef();\n    const groupRef = useRef(null);\n    const previousTransform = useMemo(() => new Matrix4(), []);\n    useImperativeHandle(forwardedRef, () => groupRef.current);\n    useFrame(() => {\n        const controller = grabbingController.current;\n        const group = groupRef.current;\n        if (!group || !controller)\n            return;\n        group.applyMatrix4(previousTransform);\n        group.applyMatrix4(controller.matrixWorld);\n        group.updateMatrixWorld();\n        previousTransform.copy(controller.matrixWorld).invert();\n    });\n    return (_jsx(Interactive, { ref: groupRef, onSelectStart: (e) => {\n            if (isXRInputSourceState(e.target) &&\n                (e.target.type === 'controller' || e.target.type === 'hand') &&\n                e.target.object != null) {\n                grabbingController.current = e.target.object;\n                previousTransform.copy(e.target.object.matrixWorld).invert();\n                onSelectStart?.(e);\n            }\n        }, onSelectEnd: (e) => {\n            if (e.target.controller === grabbingController.current) {\n                grabbingController.current = undefined;\n            }\n            onSelectEnd?.(e);\n        }, ...rest, children: children }));\n});\n"],
  "mappings": "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",
  "names": ["import_jsx_runtime", "i", "clone", "i", "i", "event", "i", "i", "enterXR", "_a", "i", "i", "i", "length", "i", "i", "length", "raycaster", "planeHelper", "invertedMatrixHelper", "intersectsHelper", "rayHelper", "intersectsHelper", "invertedMatrixHelper", "matrixHelper", "i", "intersection", "planeHelper", "vectorHelper", "vectorHelper", "vectorHelper", "vector2Helper", "quaternionHelper", "pointerMap", "vector2Helper", "vectorHelper", "quaternionHelper", "i", "matrixHelper", "vectorHelper", "quaternionHelper", "context", "vectorHelper", "directionHelper", "quaternionHelper", "quaternionHelper", "i", "matrixHelper", "vectorHelper", "quaternionHelper", "matrixHelper2", "quaternionHelper", "positionHelper", "vectorHelper", "i", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "map", "import_react", "import_jsx_runtime", "import_react", "import_react", "import_react", "state", "XRControllerModel", "_jsx", "import_jsx_runtime", "import_react", "XRHandModel", "_jsx", "XRSpace", "import_jsx_runtime", "import_react", "CombinedPointer", "_jsx", "PointerRayModel", "PointerCursorModel", "import_jsx_runtime", "import_react", "_jsx", "TeleportPointerRayModel", "_jsx", "XRSpace", "PointerCursorModel", "_jsxs", "PointerRayModel", "_Fragment", "XRControllerModel", "CombinedPointer", "XRHandModel", "state", "TeleportPointerRayModel", "_jsx", "_Fragment", "_jsxs", "XRSpace", "spreadable", "createXRStore", "_jsxs", "_jsx", "useStore", "XRSpace", "_jsx", "context", "import_jsx_runtime", "import_react", "_jsx", "geometry", "import_jsx_runtime", "import_react", "_jsx", "geometry", "import_jsx_runtime", "import_react", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "import_react", "_jsxs", "_jsx", "import_jsx_runtime", "import_react", "_jsx", "import_react", "create", "anchor", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "_jsxs", "_Fragment", "_jsx", "import_jsx_runtime", "import_react", "useStore", "_jsx", "import_react", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "RayGrab", "_jsx"]
}
