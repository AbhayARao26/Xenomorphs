import { jsx as _jsx } from "react/jsx-runtime";
import { createGetXRSpaceMatrix } from '@pmndrs/xr/internals';
import { useFrame } from '@react-three/fiber';
import { forwardRef, useContext, useImperativeHandle, useMemo, useRef } from 'react';
import { xrReferenceSpaceContext } from './contexts.js';
import { useXR } from './xr.js';
/**
 * component that puts its children at the provided space
 */
export const XRSpace = forwardRef(({ space, children }, ref) => {
    const internalRef = useRef(null);
    useImperativeHandle(ref, () => internalRef.current, []);
    useApplyXRSpaceMatrix(internalRef, space, (_state, _delta, frame) => {
        if (internalRef.current == null) {
            return;
        }
        internalRef.current.visible = frame != null;
    });
    return (_jsx("group", { xrSpace: space, visible: false, matrixAutoUpdate: false, ref: internalRef, children: _jsx(xrReferenceSpaceContext.Provider, { value: space, children: children }) }));
});
/**
 * hook for retrieving getting xr reference space from the context
 */
export function useXRReferenceSpace() {
    const context = useContext(xrReferenceSpaceContext);
    if (context == null) {
        throw new Error(`XR objects must be placed inside the XROrigin`);
    }
    return context;
}
/**
 * hook that returns a function to compute a matrix that contains the transformation of the provided xr space
 */
export function useGetXRSpaceMatrix(space) {
    const localReferenceSpace = useContext(xrReferenceSpaceContext);
    const referenceSpace = useXR((xr) => localReferenceSpace ?? xr.originReferenceSpace);
    return useMemo(() => (referenceSpace == null ? undefined : createGetXRSpaceMatrix(space, referenceSpace)), [space, referenceSpace]);
}
/**
 * hook that applies the transformation of the provided xr space to the provided object reference
 * @param onFrame optional callback that gets executed after the matrix of the reference object was updated
 * @requires that matrixAutoUpdate is disabled for the referenced object
 */
export function useApplyXRSpaceMatrix(ref, space, onFrame) {
    const getXRSpaceMatrix = useGetXRSpaceMatrix(space);
    useFrame((state, delta, frame) => {
        if (ref.current == null || getXRSpaceMatrix == null) {
            return;
        }
        getXRSpaceMatrix(ref.current.matrix, frame);
        onFrame?.(state, delta, frame);
        //makes sure we update the frame before using the space transformation anywhere
    }, -100);
}
